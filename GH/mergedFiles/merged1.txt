C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\3Sum.java
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < nums.length; i ++){
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            if (nums[i] > 0){
                break;
            }
            int start = i + 1;
            int end = nums.length - 1;
            while (start < end){
                if (end < nums.length - 1 && nums[end] == nums[end + 1]){
                    end --;
                    continue;
                } 
                if (start > i + 1 && nums[start] == nums[start - 1]){
                    start ++;
                    continue;
                }
                if (nums[start] + nums[end] + nums[i] == 0){

                    result.add(Arrays.asList(nums[start], nums[end], nums[i]));
                    start ++;
                    end --;
                }
                else if(nums[start] + nums[end] + nums[i] < 0){
                    start ++;
                }
                else{
                    end --;
                }
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\3Sum_Closest.java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int min = Integer.MAX_VALUE;
        int result = 0;
        for (int i = 0; i < nums.length; i ++) {
            int head = 0;
            int tail = nums.length - 1;
            
            while (head < tail) {
                if (head == i) {
                    head ++;
                    continue;
                }
                if (tail == i) {
                    tail --;
                    continue;
                }
                if (Math.abs(nums[head] + nums[tail] + nums[i] - target) < min){
                    min = Math.abs(nums[head] + nums[tail] + nums[i] - target);
                    result = nums[head] + nums[tail] + nums[i];
                };
                if (nums[head] + nums[tail] + nums[i] > target) {
                    tail --;
                }
                else if (nums[head] + nums[tail] + nums[i] < target) {
                    head ++;
                }
                else {
                    return target;
                }
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\3Sum_Smaller.java
public class Solution {
    public int threeSumSmaller(int[] nums, int n) {
        Arrays.sort(nums);
        int result = 0;
        for (int i = 0; i < nums.length; i ++){

            int start = i + 1;
            int end = nums.length - 1;
            while (start < end){

                if(nums[start] + nums[end] + nums[i] < n){
                    result += (end - start);
                    start ++;
                }
                else{
                    end --;
                }
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\4Sum.java
public class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int j = 0; j < nums.length - 3; j++){
            if (j > 0 && nums[j] == nums[j - 1]){
                continue;
            }
            List<List<Integer>> sum3 = threeSum(nums, target - nums[j], j + 1);
            for (List<Integer> ls: sum3){
                ls.add(nums[j]);
                result.add(ls);
            }
        }
        return result;
    }
    
    public List<List<Integer>> threeSum(int[] nums, int n, int init) {

        List<List<Integer>> result = new ArrayList<>();
        for (int i = init; i < nums.length; i ++){

            if (i > init && nums[i] == nums[i - 1]){
                continue;
            }
            int start = i + 1;
            int end = nums.length - 1;
            while (start < end){

                if (end < nums.length - 1 && nums[end] == nums[end + 1]){
                    end --;
                    continue;
                } 
                if (start > i + 1 && nums[start] == nums[start - 1]){
                    start ++;
                    continue;
                }
                if (nums[start] + nums[end] + nums[i] == n){

                    result.add(new ArrayList<Integer>(Arrays.asList(nums[start], nums[end], nums[i])));
                    start ++;
                    end --;
                }
                else if(nums[start] + nums[end] + nums[i] < n){
                    start ++;
                }
                else{
                    end --;
                }
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Add_Binary.java
public class Solution {
    public String addBinary(String a, String b) {
        int len = Math.max(a.length(), b.length());
        int add = 0;
        StringBuilder result = new StringBuilder();
        int n = 1;
        while (n <= len){
            int numa = 0;
            int numb = 0;
            if (n <= a.length()){
                numa = Integer.parseInt(""+a.charAt(a.length() - n));
            }
            if (n <= b.length()){
                numb = Integer.parseInt(""+b.charAt(b.length() - n));
            }
            add = numb + numa + add;
            result.insert(0,add % 2);
            if (add > 1){
                add = 1;
            }
            else {
                add = 0;
            }
            n ++;
        }
        if (add > 0){
            result.insert(0, "1");
        }
        return result.toString();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Add_Two_Numbers.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode ln1 = l1;
        ListNode ln2 = l2;
        ListNode result = new ListNode(0);
        ListNode cursor = result;
        int temp = 0;
        while (l1 != null || l2 != null){
            if (l1 == null){
                cursor.next = new ListNode((l2.val + temp) % 10);
                temp = (l2.val + temp) / 10;
                l2 = l2.next;
            }
            else if (l2 == null){
                cursor.next = new ListNode((l1.val + temp) % 10);
                temp = (l1.val + temp) / 10;
                l1 = l1.next;
            }
            else {
                cursor.next = new ListNode((l1.val + l2.val + temp) % 10);
                temp = (l1.val + l2.val + temp) / 10;
                l1 = l1.next;
                l2 = l2.next;
            }

            cursor = cursor.next;
        }
        if (temp != 0){
            cursor.next = new ListNode(1);
        }
        return result.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Balanced_Binary_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isBalanced(TreeNode root) {
        if(maxDepth(root) == -1){
            return false;
        }
        return true;
    }
    
    public int maxDepth(TreeNode node){
        if(node == null){
            return 0;
        }
        int left = 0;
        int right = 0;
        if (node.left != null){
            left = maxDepth(node.left);
        }
        if (node.right != null){
            right = maxDepth(node.right);
        }
        if (left == -1 || right == -1){
            return -1;
        }
        if (Math.abs(left - right) < 2){
            return Math.max(left,right)+1;
        }
        else {
            return -1;
        }
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Basic_Calculator_II.java
public class Solution {
    public int calculate(String a) {
        String s = "+" + a + "+";
        int plus = 0;
        int multiply = 0;
        int ans = 0;
        int part = 0;
        for (int i = 1; i < s.length(); i++){
            if (s.charAt(i) == '+' || s.charAt(i) == '-'){
                if (s.charAt(multiply) == '*'){
                    part = part * Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                else if (s.charAt(multiply) == '/'){
                    part = part / Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                else if (s.charAt(multiply) == '+'){
                    part = Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                else if (s.charAt(multiply) == '-'){
                    part = Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                if (s.charAt(plus) == '+'){
                    ans = ans + part;
                }
                if (s.charAt(plus) == '-'){
                    ans = ans - part;
                }
                part = 0;
                plus = i;
                multiply = i;
            }
            else if (s.charAt(i) == '*' || s.charAt(i) == '/'){
                if (s.charAt(multiply) == '*'){
                    part = part * Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                else if (s.charAt(multiply) == '/'){
                    part = part / Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                else if (s.charAt(multiply) == '+'){
                    part = Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                else if (s.charAt(multiply) == '-'){
                    part = Integer.parseInt(s.substring(multiply + 1, i).trim());
                }
                multiply = i;
            }
            
        }
        return ans;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Best_Time_to_Buy_and_Sell_Stock.java
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0){
            return 0;
        }
        int min = prices[0];
        int max = 0;
        for (int i = 1; i < prices.length; i++){
            int num = prices[i];
            min = Math.min(num,min);
            max = Math.max(num - min, max);          
        }
        return max;
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Best_Time_to_Buy_and_Sell_Stock_II.java
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        for (int i = 1; i < prices.length; i++){
            if(prices[i] > prices[i - 1]){
                max += (prices[i] - prices[i - 1]);
            }
        }
        return max;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Best_Time_to_Buy_and_Sell_Stock_with_Cooldown.java
public class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length <= 1) return 0;

        int b0 = -prices[0], b1 = b0;
        int s0 = 0, s1 = 0, s2 = 0;

        for(int i = 1; i < prices.length; i++) {
            b0 = Math.max(b1, s2 - prices[i]);
            s0 = Math.max(s1, b1 + prices[i]);
            b1 = b0; s2 = s1; s1 = s0; 
        }
        return s0;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Search_Tree_Iterator.java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
    
    Queue<TreeNode> queue = new LinkedList<>();
    public void DFS(TreeNode node){
        if(node == null){
            return;
        }
        if(node.left != null){
            DFS(node.left);
        }
        queue.offer(node);
        if(node.right != null){
            DFS(node.right);
        }
        return;
    }
    public BSTIterator(TreeNode root) {
        DFS(root);
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        if(queue.size() == 0){
            return false;
        }
        return true;
    }

    /** @return the next smallest number */
    public int next() {
        return queue.poll().val;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Inorder_Traversal.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> lst = new ArrayList<>();
        inorderHelper(root,lst);
        return lst;
    }
    
    private void inorderHelper(TreeNode node,List<Integer> lst){
        if (node == null){
            return;
        }
        if (node.left != null){
            inorderHelper(node.left,lst);
        }
        lst.add(node.val); 
        if (node.right != null){
            inorderHelper(node.right,lst);
        }
        return;
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Level_Order_Traversal.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
   public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        levelHelper(res, root, 0);
        return res;
    }
    
    public void levelHelper(List<List<Integer>> res, TreeNode root, int height) {
        if (root == null) return;
        if (height >= res.size()) {
            res.add(new LinkedList<Integer>());
        }
        res.get(height).add(root.val);
        levelHelper(res, root.left, height+1);
        levelHelper(res, root.right, height+1);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Level_Order_Traversal_II.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {

        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            ArrayList<Integer> list = new ArrayList<>();

            while (len > 0) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);

                }
                if (node.right != null) {
                    queue.offer(node.right);

                }
                len--;
            }
            result.add(0, list);
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Maximum_Path_Sum.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxPathSum(TreeNode root) {
        return maxPathSumHelper(root)[1];
    }
    
    public int[] maxPathSumHelper(TreeNode node){
        int[] result = new int[2];
        if (node == null){
            result[0] = 0;
            result[1] = Integer.MIN_VALUE;
            return result;
        }
        
        int[] left = maxPathSumHelper(node.left);
        int[] right = maxPathSumHelper(node.right);
        
        result[1] = Math.max(Math.max(left[0],0) + Math.max(right[0],0) + node.val, Math.max(left[1], right[1]));
        result[0] = Math.max(Math.max(left[0],0), Math.max(right[0],0)) + node.val;
        return result;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Postorder_Traversal.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> lst = new ArrayList<>();
        postorderHelper(root,lst);
        return lst;
    }
    
    private void postorderHelper(TreeNode node,List<Integer> lst){
        if (node == null){
            return;
        }
        if (node.left != null){
            postorderHelper(node.left,lst);
        }
        
        if (node.right != null){
            postorderHelper(node.right,lst);
        }
        lst.add(node.val);
        return;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Preorder_Traversal.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> lst = new ArrayList<>();
        preorderHelper(root,lst);
        return lst;
    }
    
    private void preorderHelper(TreeNode node,List<Integer> lst){
        if (node == null){
            return;
        }
        lst.add(node.val);
        if (node.left != null){
            preorderHelper(node.left,lst);
        }
        
        if (node.right != null){
            preorderHelper(node.right,lst);
        }
        return;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Right_Side_View.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        Stack<TreeNode> path = new Stack<>();
        int depth = 0;
        
        while (stack.size() != 0){
            TreeNode node = stack.pop();
            while((!path.isEmpty()) && path.peek().left != node && path.peek().right != node){
                path.pop();
            }
            path.push(node);
            if (node.left != null){
                stack.push(node.left);
            }
            if (node.right != null){
                stack.push(node.right);
            }
            
            if (path.size() > depth){
                depth = path.size();
                result.add(node.val);
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Vertical_Order_Traversal.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        HashMap<Integer, ArrayList<Integer>> vertMap = new HashMap<>();
        HashMap<TreeNode, Integer> locMap = new HashMap<>();
        queue.offer(root);
        vertMap.putIfAbsent(0, new ArrayList<Integer>());
        locMap.put(root, 0);
        vertMap.get(locMap.get(root)).add(root.val);
        int step = 0;
        while (!queue.isEmpty()) {
            step++;
            int len = queue.size();

            while (len > 0) {
                TreeNode node = queue.poll();
                int loc = locMap.get(node);
                if (node.left != null) {
                    queue.offer(node.left);
                    vertMap.putIfAbsent(loc - 1, new ArrayList<Integer>());
                    locMap.put(node.left, loc - 1);
                    vertMap.get(locMap.get(node.left)).add(node.left.val);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                    vertMap.putIfAbsent(loc + 1, new ArrayList<Integer>());
                    locMap.put(node.right, loc + 1);
                    vertMap.get(locMap.get(node.right)).add(node.right.val);
                }
                len--;
            }
        }
        for (int i = 1 - step; i < step; i++) {
            ArrayList<Integer> list = vertMap.get(i);
            if (list != null) {
                result.add(list);
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Binary_Tree_Zigzag_Level_Order_Traversal.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (root == null){return result;}
        List<Integer> interList = new ArrayList<Integer>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int flag = 0;
        while(!queue.isEmpty()){
            interList = new ArrayList<>();
            int leng = queue.size();
            while(leng > 0){
                TreeNode node = queue.poll();
                if(flag == 0){
                    interList.add(node.val);
                }
                else{
                    interList.add(0,node.val);
                }
                if(!(node.left == null)){
                    queue.offer(node.left);
                }
                if(!(node.right == null)){
                    queue.offer(node.right);
                }
                leng--;
            }
            result.add(new ArrayList<>(interList));
            flag = (flag+1) % 2;
        }
        return result;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Bomb_Enemy.java
/*public class Solution {
    public int maxKilledEnemies(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length ==0){
            return 0;
        }
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++){
            for (int j = 0; j < grid[0].length; j++){
                if (grid[i][j] != 'E'){
                    continue;
                }
                int cur = j;
                while ( cur < grid[0].length && grid[i][cur] != 'W'){
                    if (grid[i][cur] == '0'){
                        dp[i][cur] ++;
                    }
                    cur++;
                }
                cur = j;
                while (cur >= 0 && grid[i][cur] != 'W' ){
                    if (grid[i][cur] == '0'){
                        dp[i][cur] ++;
                    }
                    cur--;
                }
                cur = i;
                while (cur < grid.length && grid[cur][j] != 'W'){
                    if (grid[cur][j] == '0'){
                        dp[cur][j] ++;
                    }
                    cur++;
                }
                cur = i;
                while (cur >= 0 && grid[cur][j] != 'W'){
                    if (grid[cur][j] == '0'){
                        dp[cur][j] ++;
                    }
                    cur--;
                }
            }
        }
        int max = 0;
        for (int m = 0; m < grid.length; m++){
            for (int n = 0; n < grid[0].length; n++){
                max = Math.max(max, dp[m][n]);
            }
        }
        return max;
        
    }
}*/
public class Solution {
    public int maxKilledEnemies(char[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) return 0;
        int m = grid.length, n = grid[0].length;
        int[][] count = new int[m][n];
        int res = 0;
        for (int i = 0; i < m; i++) {
            int tmp = 0;
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'E') tmp++;
                if (grid[i][j] == 'W') tmp = 0;
                if (grid[i][j] == '0') {
                    count[i][j] += tmp;
                    res = Math.max(count[i][j], res);
                }
            }
            tmp = 0;
            for (int j = n-1; j >= 0; j--) {
                if (grid[i][j] == 'E') tmp++;
                if (grid[i][j] == 'W') tmp = 0;
                if (grid[i][j] == '0') {
                    count[i][j] += tmp;
                    res = Math.max(count[i][j], res);
                }
            }
        }
        for (int j = 0; j < n; j++) {
            int tmp = 0;
            for (int i = 0; i < m; i++) {
                if (grid[i][j] == 'E') tmp++;
                if (grid[i][j] == 'W') tmp = 0;
                if (grid[i][j] == '0') {
                    count[i][j] += tmp;
                    res = Math.max(count[i][j], res);
                }
            }
            tmp = 0;
            for (int i = m-1; i >= 0; i--) {
                if (grid[i][j] == 'E') tmp++;
                if (grid[i][j] == 'W') tmp = 0;
                if (grid[i][j] == '0') {
                    count[i][j] += tmp;
                    res = Math.max(count[i][j], res);
                }
            }
        }
        return res;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Bulls_and_Cows.java
public class Solution {
    public String getHint(String secret, String guess) {
        int bull = 0,cow = 0;
        int[] array = new int[10];
        for(int i = 0; i < secret.length(); i++){
            char a = secret.charAt(i);
            char b = guess.charAt(i);
            if (a == b){
                bull ++;
            } else{
                if (array[a - '0'] < 0){
                    cow ++;
                }
                if (array[b - '0'] > 0){
                    cow ++;
                }
                array[a - '0'] ++;
                array[b - '0'] --;
            }
            
        }
        return bull + "A" + cow + "B";
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Climbing_Stairs.java
public class Solution {
    public int climbStairs(int n) {
        if (n < 3){
            return n;
        }
        int dp[] = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++){
            dp[i] = dp[i - 2] + dp[i - 1] ;
        }
        return dp[n - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Closest_Binary_Search_Tree_Value.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int closestValue(TreeNode root, double target) {
        int close = 0; 
        if(root == null){
            return -1;
        }
        if (target < root.val){
            close = closestValue(root.left, target);
        }
        else{
            close = closestValue(root.right, target);
        }
        if(close == -1){
            return root.val;
        }
        double closeDiff = Math.abs(close - target);
        double rootDiff = Math.abs(root.val - target);
        if(closeDiff > rootDiff){
            return root.val;
        }
        else {
            return close;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Coin_Change.java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount == 0){
            return 0;
        }
        if (coins == null || coins.length == 0){
            return -1;
        }
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        for (int i = 1; i < amount + 1; i ++){
            dp[i] = Integer.MAX_VALUE;
            for (int j: coins){
                if (j > i || dp[i - j] == -1){
                    continue;
                }
                dp[i] = Math.min(dp[i], dp[i - j] + 1);
            }
            if (dp[i] == Integer.MAX_VALUE){
                dp[i] = -1;
            }
        }
        return dp[amount];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Combination_Sum.java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result = new ArrayList<>();
        DFS(result, new ArrayList<>(), 0, candidates, target, 0);
        return result;
    }
    
    public void DFS(List<List<Integer>> result, List<Integer> temp, int sum, int[] candidates, int target, int start){
        if (sum > target){
            return;
        }
        if (sum == target){
            result.add(new ArrayList(temp));
        }
        for (int i = start; i < candidates.length; i ++){
            if (target < candidates[i]) {
                break;
            }
            temp.add(candidates[i]);
            DFS(result, temp, sum + candidates[i], candidates, target, i);
            temp.remove(temp.size() - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Combination_Sum_II.java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result = new ArrayList<>();
        DFS(result, new ArrayList<>(), 0, candidates, target, 0);
        return result;
    }
    
    public void DFS(List<List<Integer>> result, List<Integer> temp, int sum, int[] candidates, int target, int start){
        if (sum == target){
            result.add(new ArrayList(temp));
            return;
        }
        if (sum > target || start == candidates.length){
            return;
        }
        int cur = candidates[start];
        for (int i = start; i < candidates.length; i ++){
            if (i > start && candidates[i] == cur){
                continue;
            }
            cur = candidates[i];
            temp.add(candidates[i]);
            DFS(result, temp, sum + candidates[i], candidates, target, i + 1);
            temp.remove(temp.size() - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Combination_Sum_III.java
class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> result = new ArrayList<>();
        DFS(result, new ArrayList<>(), k, n, 1, 0);
        return result;
    }
    
    private void DFS(List<List<Integer>> result, List<Integer> temp, int k, int target, int start, int sum){
        if (sum > target || temp.size() > k){
            return;
        }
        if (temp.size() == k && sum == target){
            result.add(new ArrayList(temp));
            return;
        }
        for (int i = start; i < 10; i ++){
            temp.add(i);
            DFS(result, temp, k, target, i + 1, i + sum);
            temp.remove(temp.size() - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Container_With_Most_Water.java
public class Solution {
    public int maxArea(int[] height) {
        if (height == null || height.length < 2){
            return 0;
        }
        int back = height.length - 1;
        int front = 0;
        int max = 0;
        while (front < back){
            max = Math.max(max, Math.min(height[front], height[back]) * (back - front));
            if (height[front] < height[back]){
                front ++;
            }
            else {
                back --;
            }
            
        }
        return max;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Contains_Duplicate.java
public class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i: nums){
            if (!set.add(i)){
                return true;
            }
            
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Contains_Duplicate_II.java
public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++){
            if(i >= k + 1){
            set.remove(nums[i - k - 1]);}
            if (!set.add(nums[i])){
                return true;
            }
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Convert_Sorted_Array_to_Binary_Search_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0){
            return null;
        }
        int len = nums.length;
        TreeNode node = new TreeNode(nums[len/2]);
        node.left = sortedArrayToBST(Arrays.copyOfRange(nums, 0, len/2));
        node.right = sortedArrayToBST(Arrays.copyOfRange(nums, len/2+1, len));
        return node;
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Convert_Sorted_List_to_Binary_Search_Tree.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private ListNode node;
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null){
            return null;
        }
        ListNode end = head;
        node = head;
        int size = 0;
        while(end != null){
            size++;
            end = end.next;
        }
        return toBstHelper(0,size);
        
    }
    public TreeNode toBstHelper(int first,int last){
        if(last <= first){
            return null;
        }
        int mid = first + (last - first)/2;
        TreeNode left = toBstHelper(first,mid);
        TreeNode result = new TreeNode(node.val);
        result.left = left;
        node = node.next;
        
        TreeNode right = toBstHelper(mid+1,last);
        result.right = right;
        return result;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Counting_Bits.java
public class Solution {
    public int[] countBits(int num) {
        int [] dp = new int[num + 1];
        if (num == 0){
            return dp;
        }
        dp[1] = 1;
        for (int i = 2; i < num + 1; i++){
            /*
            int j = i;
            dp[i] = dp[i - 1] + 1;
            while ((j & 1) != 1){
                j = j >> 1;
                dp[i] -= 1;
            }
            */
            dp[i] = dp[i & (i - 1)] + 1;
        }
        return dp;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Count_and_Say.java
public class Solution {
    public String countAndSay(int n) {
        int cnt = 1;
        String result = "1";
        while (cnt < n){
            StringBuilder sb = new StringBuilder();
            int m = 1;
            for(int i = 1; i < result.length(); i++){
                if (result.charAt(i) != result.charAt(i - 1)){
                    sb.append("" + m + result.charAt(i - 1));
                    m = 0;
                }
                m ++;
            }
            sb.append("" + m + result.charAt(result.length() - 1)); 
            result = sb.toString();
            cnt ++;
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Count_Complete_Tree_Nodes.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 /*
public class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int res = 0;
        int cnt = 0;
        int max = -1;
        Stack<TreeNode> stack = new Stack<>();
        Stack<TreeNode> path = new Stack<>();
        stack.push(root);
        while (stack.size() > 0){

            TreeNode node = stack.pop();
            while (path.size() != 0 && path.peek().left != node && path.peek().right != node){
                path.pop();
            }
            if (node.right != null){
                stack.push(node.right);
            }
            if (node.left != null){
                stack.push(node.left);
            }
            path.push(node);
            if (node.left == null && node.right == null){ 
                if (max == -1){
                    max = path.size();
                }
                if (max == path.size()){
                    cnt++;
                }
                else if(max > path.size()){
                    break;
                }
            }
        }
        res = (1 << (max-1)) - 1 + cnt;
        return res;
    }
}*/
public class Solution {
    public int countNodes(TreeNode root) { 
        if(root == null){
            return 0;
        }
        int left = 0;
        int right = 0;
        TreeNode ln = root;
        while (ln != null){
            ln = ln.left;
            left ++;
        }
        TreeNode rn = root;
        while (rn != null){
            rn = rn.right;
            right ++;
        }
        return 1 + countHelperL(root.left,left) +countHelperR(root.right,right);
    }
    public int countHelperL(TreeNode node,int height){
        if (node == null){
            return 0;
        }
        int right = 0;
        TreeNode rn = node;
        while (rn != null){
            rn = rn.right;
            right ++;
        }
        if (height - 1 == right){
            return (1 << (right)) - 1;
        }
        else {
            return 1 + countHelperL(node.left,height - 1) + countHelperR(node.right,right);
        }
    }
    public int countHelperR(TreeNode node,int height){
        if (node == null){
            return 0;
        }
        int left = 0;
        TreeNode ln = node;
        while (ln != null){
            ln = ln.left;
            left ++;
        }

        if (left == height - 1){
            return (1 << (left)) - 1;
        }
        else {
            return 1 + countHelperL(node.left,left) + countHelperR(node.right,height - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Count_Numbers_with_Unique_Digits.java
public class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if (n == 0) {
            return 1;
        } 
        int ret = 10, count = 9;
        for (int i = 2; i <= n; i++) {
            count *= 9-i+2;
            ret += count;
        }
        return ret;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Count_Primes.java
/*public class Solution {
    public int countPrimes(int n) {
        ArrayList<Integer> primes = new ArrayList<>();
        if(n < 3){
            return 0;
        }
        primes.add(2);
        primes.add(3);
        if (n < 4){
            return 1;
        }
        if (n < 5){
            return 2;
        }
        
        int current = 5;
        int test = 0;
        int flag = 1;
        while (current < n){
            test = 0;
            flag = 1;
            while (primes.get(test) <= Math.sqrt(current)){
                if ( current % primes.get(test) == 0){
                    flag = 0;
                    break;
                }
                test ++;
            }
            if (flag == 1){
                primes.add(current);
            }
            current += 2;
        }
        return primes.size();
    }
}
*/
public class Solution {
    public int countPrimes(int n) {
        boolean[] notPrime = new boolean[n];
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (notPrime[i] == false) {
                count++;
                for (int j = 2; i*j < n; j++) {
                    notPrime[i*j] = true;
                }
            }
        }
        
        return count;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Course_Schedule.java
/*class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();
        for (int i = 0; i < prerequisites.length; i ++) {
            if (!map.containsKey(prerequisites[i][0])) {
                map.put(prerequisites[i][0], new ArrayList());
            }
            map.get(prerequisites[i][0]).add(prerequisites[i][1]);
            
        }
        boolean[] visited = new boolean[numCourses];
        boolean flag = false;
        for (int i: map.keySet()){
            flag = DFS(i,map,visited);
            if (flag == true){
                return false;
            }
        }
        return true;
    }
    public boolean DFS(int start, HashMap<Integer, ArrayList<Integer>> map, boolean[] visited){

        if (visited[start] == true){
            return true;
        }
        if (!map.containsKey(start)){
            return false;
        }
        boolean isCircle = false;
        visited[start] = true;
        for (int i: map.get(start)){
            isCircle = DFS(i,map,visited);
            if (isCircle == true){
                return isCircle;
            }
        }
        visited[start] = false;
        return isCircle;
    }
}*/
public class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            ArrayList[] graph = new ArrayList[numCourses];
            for(int i=0;i<numCourses;i++)
                graph[i] = new ArrayList();
                
            boolean[] visited = new boolean[numCourses];
            for(int i=0; i<prerequisites.length;i++){
                graph[prerequisites[i][1]].add(prerequisites[i][0]);
            }

            for(int i=0; i<numCourses; i++){
                if(!dfs(graph,visited,i))
                    return false;
            }
            return true;
        }

        private boolean dfs(ArrayList[] graph, boolean[] visited, int course){
            if(visited[course])
                return false;
            else
                visited[course] = true;;

            for(int i=0; i<graph[course].size();i++){
                if(!dfs(graph,visited,(int)graph[course].get(i)))
                    return false;
            }
            visited[course] = false;
            return true;
        }
    }
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Decode_Ways.java
public class Solution {
    public int numDecodings(String s) {
        if (s == null || s.equals("0")){
            return 0;
        }
        if (s.length() < 2){
            return s.length();
        }
        int[] dp = new int[s.length()];
        if(s.charAt(0) != '0'){
            dp[0] = 1;
        }
        else{
            dp[0] = 0;
        }
        if (s.charAt(1) == '0' && (s.charAt(0) != '1' && s.charAt(0) != '2')) {
            return 0;
        }
        if(Integer.parseInt(s.substring(0,2)) < 27 && s.charAt(1) != '0' && Integer.parseInt(s.substring(0,2)) > 10){
            dp[1] = dp[0] + 1;
        }
        else{
            dp[1] = dp[0];
        }
        for (int i = 2; i < s.length(); i++){
            if (s.charAt(i) == '0'){
                if (s.charAt(i - 1) != '1' && s.charAt(i - 1) != '2'){
                    return 0;
                }
                dp[i] = dp[i - 2];
                dp[i - 1] = dp[i - 2];
            }
            else if (Integer.parseInt(s.substring(i - 1,i + 1)) < 27 && Integer.parseInt(s.substring(i - 1,i + 1)) > 10){
                dp[i] = dp[i - 1] + 1 * dp[i - 2];
            }
            else{
                dp[i] = dp[i - 1];
            }
        }
        return dp[s.length() - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Delete_Node_in_a_Linked_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
            node.val = node.next.val;
            node.next = node.next.next;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Edit_Distance.java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i <= word1.length(); i ++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= word2.length(); j ++) {
            dp[0][j] = j;
        }
        for (int m = 1; m <= word1.length(); m++) {
            for (int n = 1; n <= word2.length(); n++) {
                int nochan = Math.min(dp[m - 1][n] + 1, dp[m][n - 1] + 1);
                int chan = dp[m - 1][n - 1];
                if (word1.charAt(m - 1) != word2.charAt(n - 1)) {
                    chan++;
                }
                dp[m][n] = Math.min(nochan, chan);
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Encode_and_Decode_Strings.java
public class Codec {
    StringBuilder sb = new StringBuilder();
    // Encodes a list of strings to a single string.
    public String encode(List<String> strs) {
        for (String s : strs) {
            sb.append(s.length() + "/" + s);
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        List<String> res = new ArrayList<>();
        int i = 0;
        while (i < s.length()) {
            int pos = s.indexOf('/', i);
            int len = Integer.parseInt(s.substring(i, pos));
            String cur = s.substring(pos + 1, pos + 1 + len);
            res.add(cur);
            i = pos + 1 + len;
        }
        return res;
    }
}
// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(strs));
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Encode_and_Decode_TinyURL.java
public class Codec {
    int COUNTER;
    String elements;
    HashMap<String, Integer> l2s;
    HashMap<Integer, String> s2l;
    HashMap<Character, Integer>  elementMap;
    public Codec() {
        l2s = new HashMap<>();
        s2l = new HashMap<>();
        elementMap = new HashMap<>();
        elements = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for (int i = 0; i < elements.length(); i ++) {
            elementMap.put(elements.charAt(i), i);
        }
    }


    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        l2s.put(longUrl, COUNTER);
        s2l.put(COUNTER, longUrl);
        StringBuilder sb = new StringBuilder();
        int n = COUNTER;
        while (n != 0) {
            sb.insert(0, elements.charAt(n % 62));
            n /= 62;
        }
        while (sb.length() != 6) {
            sb.insert(0, '0');
        }
        COUNTER ++;
        return "http://tiny.url/" + sb.toString();
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        String url = shortUrl.substring("http://tiny.url/".length());
        int n = 0;
        for (int i = 0; i < url.length(); i++) {
            n = n * 62 + elementMap.get(url.charAt(i));
        }
        return s2l.get(n);
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Find_All_Duplicates_in_an_Array.java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> result = new ArrayList<Integer>();
        for( int i=0;i< nums.length; i++){
            int index = nums[i];
            if(nums[Math.abs(index)-1] < 0) {
                result.add(Math.abs(index));
            }
            if(nums[Math.abs(index)-1] > 0){
                nums[Math.abs(index)-1]= -nums[Math.abs(index)-1];
            }
        }
        
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Find_Peak_Element.java
class Solution {
    public int findPeakElement(int[] nums) {
        
        if (nums.length == 1) {
            return 0;
        }
        if (nums[0] > nums[1]) {
            return 0;
        }
        if (nums[nums.length - 1] > nums[nums.length - 1]) {
            return nums.length - 1;
        }
        int start = 0;
        int end = nums.length - 1;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (mid == 0 || nums[mid] > nums[mid - 1]) {
                start = mid;
            }
            else {
                end = mid;
            }
            
        }
        if (nums[start] > nums[end]) {
            return start;
        }
        else return end;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Find_the_Difference.java
class Solution {
    public char findTheDifference(String s, String t) {
        int[] charSet = new int[26];
        for (char c: s.toCharArray()) {
            charSet[c - 'a'] ++;
        }
        for (char c: t.toCharArray()) {
            charSet[c - 'a'] --;
            if (charSet[c - 'a'] < 0) {
                return c;
            }
        }
        for (int i = 0; i < 26; i++) {
            if (charSet[i] > 0) {
                return (char)i;
            }
        }
        return ' ';
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\First_Bad_Version.java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int start = 1;
        int end = n;
        int mid = 0;
        while (start + 1 < end) {
            mid = (end - start) / 2 + start;
            if (isBadVersion(mid) == true){
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (isBadVersion(start) == true){
            return start;
        }
        else {
            return end;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Flatten_Binary_Tree_to_Linked_List.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void flatten(TreeNode root) {
        if (root != null){
            List<Integer> lst = new ArrayList<>();
            preorderHelper(root,lst);
            root.left = null;
            TreeNode tmp = root;
            lst.remove(0);
            for (Integer n:lst){
                TreeNode node = new TreeNode(n);
                tmp.right = node;
                tmp = tmp.right;
            }
        }
    }
    
    private void preorderHelper(TreeNode node,List<Integer> lst){
        if (node == null){
            return;
        }
        lst.add(node.val);
        if (node.left != null){
            preorderHelper(node.left,lst);
        }
        
        if (node.right != null){
            preorderHelper(node.right,lst);
        }
        return;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Flatten_Nested_List_Iterator.java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
public class NestedIterator implements Iterator<Integer> {
    Stack<NestedInteger> stack = new Stack<>();
    public NestedIterator(List<NestedInteger> nestedList) {
        for(int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while(!stack.isEmpty()) {
            NestedInteger curr = stack.peek();
            if(curr.isInteger()) {
                return true;
            }
            stack.pop();
            for(int i = curr.getList().size() - 1; i >= 0; i--) {
                stack.push(curr.getList().get(i));
            }
        }
        return false;
    }
}

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i = new NestedIterator(nestedList);
 * while (i.hasNext()) v[f()] = i.next();
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Flip_Game.java
public class Solution {
    public List<String> generatePossibleNextMoves(String s) {
        List<String> ls = new ArrayList<>();
        for (int i = 0; i < s.length() - 1; i++){
            if (s.charAt(i) == '+' && s.charAt(i + 1) == '+'){
                String result = s.substring(0, i) + "--" + s.substring(i + 2);
                ls.add(result);
            }
        }
        return ls;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Game_of_Life.java
class Solution {
    public void gameOfLife(int[][] board) {
        int[][] result = new int[board.length][board[0].length];
        for (int i = 0; i < board.length; i++){
            for (int j = 0; j < board[0].length; j++){
                int lives = 0;
                if (i > 0){
                    if (j > 0){
                        lives += (board[i - 1][j - 1]);
                    }
                    if (j < board[0].length - 1){
                        lives += (board[i - 1][j + 1]);
                    }
                    lives += (board[i - 1][j]);
                }
                if (i < board.length - 1){
                    if (j > 0){
                        lives += (board[i + 1][j - 1]);
                    }
                    if (j < board[0].length - 1){
                        lives += (board[i + 1][j + 1]);
                    }
                    lives += (board[i + 1][j]);
                }
                if (j > 0){
                    lives += (board[i][j - 1]);
                }
                if (j < board[0].length - 1){
                    lives += (board[i][j + 1]);
                }
                if ((lives < 2 || lives > 3) && board[i][j] == 1){
                    result[i][j] = 0;
                }
                if ((lives >= 2 && lives <= 3) && board[i][j] == 1){
                    result[i][j] = 1;
                }
                if (lives == 3 && board[i][j] == 0){
                    result[i][j] = 1;
                }
            }
        }
        for (int i = 0; i < board.length; i++){
            for (int j = 0; j < board[0].length; j++){
                board[i][j] = result[i][j];
            }
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Generate_Parentheses.java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> rs = new ArrayList<>();
        generator(rs, "", n, n);
        return rs;
    }
    public void generator(List<String> ls, String curr, int left, int right) {
        if (left > right) {
            return;
        }
        if (left > 0) {
            generator(ls, curr+"(", left - 1, right);
        }
        if (right > 0) {
            generator(ls, curr+")", left, right - 1);
        }
        if (left == 0 && right == 0) {
            ls.add(curr);
            return;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Group_Anagrams.java
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ans = new ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();
        for (String s : strs){
            char[] sum = new char[s.length()];
            for (int i = 0; i < s.length(); i++){
                char cha = s.charAt(i);
                //sum += (cha - 'a' + 1)*(cha - 'a' + 1)*(cha - 'a' + 1);
                sum[i] = (char)(cha - 'a' + 1);
            }
            Arrays.sort(sum);
            String re = new String(sum);

            map.putIfAbsent(re, new ArrayList<>());
            map.get(re).add(s);
        }
        for (List<String> ls : map.values()){
            ans.add(ls);
        }
        return ans;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Group_Shifted_Strings.java
public class Solution {
    public List<List<String>> groupStrings(String[] strings) {
        List<List<String>> result = new ArrayList<List<String>>();
        if (strings == null || strings.length == 0){
            return result;
        }
        HashMap<String,List<String>> patternMap = new HashMap<>();
        for (String string: strings){
            StringBuilder sequence = new StringBuilder();
            char[] chArray = string.toCharArray();
            sequence.append("0");
            for (char ch : chArray){
                int loc = (int)ch - (int)chArray[0];
                int seq = 0;
                if (loc < 0){
                    seq = loc + 26;
                }
                else{
                    seq = loc;
                }
                sequence.append("-");
                sequence.append(String.valueOf(seq));
            }
            String pattern = sequence.toString();
            patternMap.putIfAbsent(pattern,new ArrayList<String>());
            patternMap.get(pattern).add(string);
            
        }
        for (List<String> list : patternMap.values()){
            result.add(list);
        }
        return result;
    }
}

/*
public class Solution {
    public List<List<String>> groupStrings(String[] strings) {
        List<List<String>> result = new ArrayList<List<String>>();
        if (strings == null || strings.length == 0){
            return result;
        }
        HashMap<String,List<String>> patternMap = new HashMap<>();
        for (String string: strings){
            StringBuilder sequence = new StringBuilder();
            sequence.append(String.valueOf(0));
            int init = (int)string.charAt(0);
            for (int i = 1; i < string.length(); i++){
                int loc = (int)string.charAt(i) - init;
                int seq = 0;
                if (loc < 0){
                    seq = loc + 26;
                }
                else{
                    seq = loc;
                }
                sequence.append("-");
                sequence.append(String.valueOf(seq));
            }
            String pattern = sequence.toString();
            patternMap.putIfAbsent(pattern,new ArrayList<String>());
            patternMap.get(pattern).add(string);
            
        }
        for (List<String> list : patternMap.values()){
            result.add(list);
        }
        return result;
    }
}
*/
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\H-Index.java
public class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        for (int i = 0; i < citations.length; i++){
            if(citations[i] >= citations.length - i){
                return citations.length - i;
            }
        }
        return 0;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Happy_Number.java
public class Solution {
    public boolean isHappy(int n) {
        HashSet<Integer> visited = new HashSet<>();
        while (true){
            int sum = 0;
            while (n >= 10){
                int digit = n % 10;
                sum += digit * digit;
                n = n / 10;
            }
            sum += n * n;
            if (sum == 1){
                return true;
            }
            if (visited.contains(sum)){
                return false;
            }
            visited.add(sum);
            n = sum;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\House_Robber.java
public class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length];
        if (nums.length == 0 || nums == null){
            return 0;
        }
        dp[0] = nums[0];
        if (nums.length == 1){
            return nums[0];
        }
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.length - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\House_Robber_II.java
public class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length];
        int[] de = new int[nums.length];
        if (nums.length == 0 || nums == null){
            return 0;
        }
        dp[0] = nums[0];
        de[0] = 0;
        if (nums.length == 1){
            return nums[0];
        }
        dp[1] = nums[0];
        de[1] = nums[1];
        for (int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
            de[i] = Math.max(de[i - 2] + nums[i], de[i - 1]);
        }
        return Math.max(dp[nums.length - 2],de[nums.length - 1]);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Implement_Queue_using_Stacks.java
class MyQueue {
    private Stack<Integer> stack = null;
    /** Initialize your data structure here. */
    public MyQueue() {
        stack = new Stack<>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        Stack<Integer> temp = new Stack<Integer>();
        while(!stack.empty()){
            temp.push(stack.pop());
        }
        stack.push(x);
        while(!temp.empty()){
            stack.push(temp.pop());
        }
        
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        return stack.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        return stack.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stack.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Implement_Stack_using_Queues.java
class MyStack {
    Queue<Integer> queue = null;
    
    /** Initialize your data structure here. */
    public MyStack() {
        queue = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue.offer(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        Queue<Integer> temp = new LinkedList<>();
        int len = queue.size();
        for (int i = 0; i < len - 1; i ++){
            temp.offer(queue.poll());
        }
        int res = queue.poll();
        queue = temp;
        //System.out.println(res);
        return res;
    }
    
    /** Get the top element. */
    public int top() {
        Queue<Integer> temp = new LinkedList<>();
        int len = queue.size();
        for (int i = 0; i < len - 1; i ++){
            temp.offer(queue.poll());
        }
        int res = queue.poll();
        
        queue = temp;
        queue.offer(res);
        return res;
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Implement_strStr().java
public class Solution {
    public int strStr(String haystack, String needle) {
        int len = needle.length();
        if(len == 0 || needle.equals(haystack)){
            return 0;
        }
        for (int i = 0; i <= haystack.length() - len; i++){
            if (haystack.substring(i, i + len).equals(needle)){
                return i;
            }
        }
        return -1;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Insertion_Sort_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode previous = dummy;
        ListNode curr = head;
        int flag = 0;
        while (curr != null){
            ListNode compare = dummy;
            flag = 0;
            while (compare.next != curr){
                
                if (compare.next.val > curr.val){
                    previous.next = curr.next;
                    curr.next = compare.next;
                    compare.next = curr;
                    curr = previous.next;
                    flag = 1;
                    break;
                }
                compare = compare.next;
            }
            if (flag == 1){
                continue;
            }
            previous = previous.next;
            curr = curr.next;
        }
        return dummy.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Integer_Break.java
public class Solution {
    public int integerBreak(int n) {
        if (n < 4){
            return n - 1;
        }
        int[] dp = new int[n];
        dp[1] = 2;
        dp[2] = 3;
        dp[3] = 4;
        for (int i = 4; i < n; i++){
            dp[i] = Math.max(dp[i - 2] * 2, dp[i - 3] * 3);
        }
        return dp[n - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Integer_to_Roman.java
class Solution {
    public String intToRoman(int num) {
        String M[] = {"", "M", "MM", "MMM"};
        String C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
        String X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
        String I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
        return M[num/1000] + C[(num%1000)/100]+ X[(num%100)/10] + I[num%10];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Intersection_of_Two_Arrays.java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> set = new HashSet<>();
        HashSet<Integer> list = new HashSet<>();
        for (int i: nums1){
            set.add(i);
        }
        for (int j: nums2){
            if (set.contains(j)){
                list.add(j);
            }
        }
        int[] result = new int[list.size()];
        int k = 0;
        for (int i:list){
            result[k] = i;
            k++;
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Intersection_of_Two_Arrays_II.java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> results = new ArrayList<>();
        
        for (int i : nums1){
            if(!map.containsKey(i)){
                map.put(i, 0);
            }
            map.put(i, map.get(i) + 1);
        }
        for (int i: nums2){
            if(map.containsKey(i) && map.get(i) > 0){
                map.put(i, map.get(i) - 1);
                results.add(i);
            }
        }
        int[] re = new int[results.size()];
        int cnt = 0;
        for (int i: results){
            re[cnt] = i;
            cnt ++;
        }
        return re;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Intersection_of_Two_Linked_Lists.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null){
            return null;
        }
        int len1 = getNumber(headA);
        int len2 = getNumber(headB);
        int offset = 0;
        int steps = 0;
        ListNode currLong = headA;
        ListNode currShort = headB;
        if (len1 > len2){
            offset = len1 - len2;
        }
        else {
            currShort = headA;
            currLong = headB;
            offset = len2 - len1;
        }
        while (offset > 0){
            currLong = currLong.next;
            offset --;
        }
        while (currShort != null && currLong != null){
            if (currLong == currShort){
                return currLong;
            }
            currLong = currLong.next;
            currShort = currShort.next;
        }
        return null;
    }
    public int getNumber(ListNode l){
        if (l.next == null) {
            return 1;
        }
        return getNumber(l.next) + 1;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Invert_Binary_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null){
            return root;
        }
        else{
            TreeNode interNode = root.left;
            root.left = root.right;
            root.right = interNode;
            invertTree(root.left);
            invertTree(root.right);
        }
        return root;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Island_Perimeter.java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int islands = 0, neighbours = 0;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    islands++; // count islands
                    if (i < grid.length - 1 && grid[i + 1][j] == 1) neighbours++; // count down neighbours
                    if (j < grid[i].length - 1 && grid[i][j + 1] == 1) neighbours++; // count right neighbours
                }
            }
        }

        return islands * 4 - neighbours * 2;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Judge_Route_Circle.java
class Solution {
    public boolean judgeCircle(String moves) {
        int[] check = new int[2];
        for (char c: moves.toCharArray()) {
            if (c == 'U') {
                check[0] ++;
            }
            else if (c == 'D') {
                check[0] --;
            }
            else if (c == 'L') {
                check[1] ++;
            }
            else {
                check[1] --;
            }
        }
        if (check[0] == 0 && check[1] == 0) {
            return true;
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Jump_Game.java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums.length == 1){
            return true;
        }
        int canJump = 0;
        for (int i = 0; i < nums.length; i++){
            if (i > canJump){
                continue;
            }
            if ((i + nums[i]) >= nums.length - 1){
                return true;
            }
            canJump = Math.max(canJump, nums[i] + i);
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Kth_Largest_Element_in_an_Array.java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> queue = new PriorityQueue<>(k);
        for (int i : nums) {
            if (queue.size() < k){
                queue.add(i);
            }
            else {
                if (i > queue.peek()){
                    queue.poll();
                    queue.add(i);
                }
            }
        }
        return queue.peek();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Kth_Smallest_Element_in_a_BST.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        ArrayList<Integer> count = new ArrayList<>();
        int res = helper(root,k,count);
        return res;
        
    }
    public int helper(TreeNode node,int k,ArrayList<Integer> count){
        if(count.size() == k){
            return count.get(k-1);
        }
        if (node == null){
            return 0;
        }
        if (node.left != null){
            int left = helper(node.left,k,count);
        }
        if(count.size() < k){
            count.add(node.val);
        }
        if(count.size() == k){
            return count.get(k-1);
        }
        if (node.right != null){
            int right = helper(node.right,k,count);
        }
        if(count.size() == k){
            return count.get(k-1);
        }
        return 0;
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Largest_Divisible_Subset.java
public class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        if (nums == null || nums.length == 0){
            return new ArrayList<Integer>();
        }
        Arrays.sort(nums);
        List[] dp = new ArrayList[nums.length];
        int max;
        dp[0] = new ArrayList<Integer>();
        
        for (int i = 0; i < nums.length; i++){
            dp[i] = new ArrayList<Integer>();
            max = 0;
            for (int j = 0; j < i ; j ++){
                if ((nums[i] % nums[j] == 0)  && dp[j].size() > max){
                    dp[i] = new ArrayList<Integer>(dp[j]);
                    max = dp[j].size();
                }
            }
            dp[i].add(nums[i]);
        }
        max = 0;
        int index = 0;
        for (int k = 0; k < nums.length; k++){
            if (dp[k].size() > max){
                max = dp[k].size();
                index = k;
            }
        }
        return dp[index];
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Largest_Number.java
class Solution {
    public String largestNumber(int[] nums) {
        if (nums == null || nums.length == 0){
            return "";
        }
        String[] strs = new String[nums.length];
        int max = 0;
        for (int i = 0; i < nums.length; i ++) {
            max = Math.max(nums[i], max);
            strs[i] = (String.valueOf(nums[i]));
        }
        if (max == 0){
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        Arrays.sort(strs, new java.util.Comparator<String>() {
            public int compare(String i1, String i2){
                return (i1 + i2).compareTo(i2 + i1);
            }
        });
        for (String j: strs){
            sb.insert(0, j);
        }
        String result = sb.toString();
        return result;
    }
} 
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Length_of_Last_Word.java
public class Solution {
    public int lengthOfLastWord(String s) {
        if (s == null||s.length() == 0){
            return 0;
        }
        s = s.trim();
        int cnt = 0;
        for (int i = s.length() - 1; i >= 0; i--){   
            if(s.charAt(i) == ' '){
                return cnt;
            }
            cnt++;
        }
        return s.length();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Letter_Combinations_of_a_Phone_Number.java
public class Solution {
    public List<String> letterCombinations(String digits) {
        LinkedList<String> ans = new LinkedList<String>();
        if (digits == null || digits.equals("")){
            return ans;
        }

        String[] mapping = new String[] {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        ans.add("");
        for(int i =0; i<digits.length();i++){
            int x = Character.getNumericValue(digits.charAt(i));
            while(ans.peek().length()==i){
                String t = ans.remove();
                for(char s : mapping[x].toCharArray())
                    ans.add(t+s);
            }
        }
        return ans;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Linked_List_Cycle.java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Linked_List_Cycle_II.java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow){
                while (head != slow){
                    head = head.next;
                    slow = slow.next;
                }
                return slow;
            }
        }
        return null;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Logger_Rate_Limiter.java
class Logger {
    HashMap<String, Integer> bucket;
    /** Initialize your data structure here. */
    public Logger() {
        bucket = new HashMap<>();
    }
    
    /** Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity. */
    public boolean shouldPrintMessage(int timestamp, String message) {
        if (!bucket.containsKey(message)) {
            bucket.put(message, timestamp);
            return true;
        }
        int old = bucket.get(message);
        if (old <= timestamp - 10) {
            bucket.put(message, timestamp);
            return true;
        }
        else {
            return false;
        }
    }
}

/**
 * Your Logger object will be instantiated and called as such:
 * Logger obj = new Logger();
 * boolean param_1 = obj.shouldPrintMessage(timestamp,message);
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Absolute_File_Path.java
class Solution {
    public int lengthLongestPath(String input) {
        int max = 0;
        int[] prev = new int[100];
        prev[0] = 0;
        for (String str: input.split("\n")) {
            //System.out.println(str);
            int pointer = 0;
            String[] temp = str.split("\t");
            int curdepth = temp.length;
            int len = temp[temp.length - 1].length();        
            prev[curdepth] = len + prev[curdepth - 1]; 
            //System.out.println(prev[curdepth]);
            if (temp[temp.length - 1].contains(".")) {
                max = Math.max(max, prev[curdepth] + curdepth - 1);
            }  
        }
        return max;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Consecutive_Sequence.java
class Solution {
   public int longestConsecutive(int[] nums) {
            Set<Integer> set = new HashSet<>();
            for(int n : nums) {
                set.add(n);
            }
            int best = 0;
            for(int n : set) {
                if(!set.contains(n - 1)) {  // only check for one direction
                    int m = n + 1;
                    while(set.contains(m)) {
                        m++;
                    }
                    best = Math.max(best, m - n);
                }
            }
            return best;
        }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Increasing_Subsequence.java
public class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        for (int i = 1; i < nums.length; i++){
            dp[i] = 1;
            for (int j = 0; j < i; j++){
                if (nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        int result = 0;
        for (int k = 0; k < nums.length; k++){
            if (dp[k] > result){
                result = dp[k];
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Palindrome.java
class Solution {
    public int longestPalindrome(String s) {
        int len = 0;
        int[] charSet = new int[256];
        for (char c: s.toCharArray()){
            charSet[c] ++;
        }
        
        for (int i: charSet){
            len += (i - i % 2);
        }
        if (len < s.length() || s.length() % 2 == 1){
            len ++;
        }
        return len;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Palindromic_Substring.java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        
        int maxLen = 0;
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            int len1 = extend(s, i, i);
            int len2 = extend(s, i, i + 1);
            int len = Math.max(len1, len2);
            
            if (len > maxLen) {
                maxLen = len;
                res = s.substring(i - (len - 1) / 2, i + len / 2 + 1);    
            }
        }
        
        return res;
    }
    
    public int extend(String s, int i, int j) {
        while (j < s.length() && i >= 0 && s.charAt(i) == s.charAt(j)) {
            i--;
            j++;
        }
        return j - i - 1;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Substring_Without_Repeating_Characters.java
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int start = 0;
        int result = 0;
        HashSet<Character> set = new HashSet<>();
        int len = s.length();
        for (int i = 0; i < len; i ++){
            char cha = s.charAt(i);
            while(!set.add(cha)){
                result = Math.max(result, set.size());
                set.remove(s.charAt(start));
                start++;
            }
        }
        result = Math.max(result, set.size());
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Substring_with_At_Most_K_Distinct_Characters.java
class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if (s == null || s.length() == 0 ) {
            return 0;
        }
        int slow = 0;
        int fast = 0;
        HashMap<Character, Integer> uniqueMap = new HashMap<>();
        int max = 0;
        while (fast < s.length()) {
         
            if (uniqueMap.size() <= k) {
                //System.out.println(uniqueMap.size());
                uniqueMap.put(s.charAt(fast), uniqueMap.getOrDefault(s.charAt(fast), 0) + 1); 
                max = Math.max(fast - slow, max);
                fast ++;
                                
            }
            if (uniqueMap.size() > k) {
                uniqueMap.put(s.charAt(slow), uniqueMap.get(s.charAt(slow)) - 1); 
                if (uniqueMap.get(s.charAt(slow)) == 0) {
                    uniqueMap.remove(s.charAt(slow));
                }
                slow ++;
            }
        }
        max = Math.max(fast - slow, max);
        return max;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Longest_Uncommon_Subsequence_I.java
class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b)) {
            return -1;
        }
        return Math.max(a.length(), b.length());
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Lowest_Common_Ancestor_of_a_Binary_Search_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode middle = null;
        if(p.val>q.val){
            middle = p;
            p = q;
            q = middle;
        }
        if (root == null || (root.val >= p.val && root.val <= q.val)){
            return root;
        }
        if (p.val > root.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        else {
            return lowestCommonAncestor(root.left,p,q);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Lowest_Common_Ancestor_of_a_Binary_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }else if (root.equals(p)||root.equals(q)){
            return root;
        }
        else {
            TreeNode left = lowestCommonAncestor(root.left, p, q);

            TreeNode right = lowestCommonAncestor(root.right, p, q);

            if (left != null && right != null && ((right.equals(p) && left.equals(q)) || left.equals(p) && right.equals(q))) {
                return root;
            }
            else if((left != null && left.equals(p))||(right != null && right.equals(p))){
                return p;
            }
            else if((left != null && left.equals(q))||(right != null && right.equals(q))){
                return q;
            }
            else if(left != null){
                return left;
            }
            else if(right != null){
                return right;
            }
            else{return null;}
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Maximal_Square.java
public class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return 0;
            
        }
        
        int[][] dp = new int[matrix.length][matrix[0].length];
        dp[0][0] = matrix[0][0];
        int max = matrix[0][0] - '0';
        for (int i = 1; i < matrix.length; i++){
            dp[i][0] = (matrix[i][0] - '0');
            max = Math.max(dp[i][0], max);

        }
        for (int j = 1; j < matrix[0].length; j++){
            dp[0][j] = (matrix[0][j] - '0');
            max = Math.max(dp[0][j], max);
            
        }
        for (int m = 1; m < matrix.length; m++){
            for (int n = 1; n < matrix[0].length; n++){
                if (matrix[m][n] != '0' && dp[m - 1][n] > 0 && dp[m][n - 1] > 0 && dp[m - 1][n - 1] > 0){
                    dp[m][n] = (matrix[m][n] - '0') * (Math.min(Math.min(dp[m - 1][n], dp[m][n - 1]), dp[m - 1][n - 1]) + 1);
                    max = Math.max(dp[m][n], max);
                }
                else {
                    dp[m][n] = (matrix[m][n] - '0');
                }
            }
        }
        return max * max;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Maximum_Depth_of_Binary_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        if (leftDepth>rightDepth){
            return leftDepth + 1;
        }
        else {
            return rightDepth + 1;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Maximum_Product_Subarray.java
public class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }

        int[] dpp = new int[nums.length];
        int[] dpn = new int[nums.length];
        int[] max = new int[nums.length];
        dpp[0] = nums[0];
        dpn[0] = nums[0];
        max[0] = nums[0];
        for (int i = 1; i < nums.length; i++){
            dpp[i] = Math.max(Math.max(dpp[i - 1] * nums[i], dpn[i - 1] * nums[i]), nums[i]);
            dpn[i] = Math.min(Math.min(dpn[i - 1] * nums[i], dpp[i - 1] * nums[i]), nums[i]);
            max[i] = Math.max(dpp[i], max[i - 1]);
        }
        return max[nums.length - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Maximum_Size_Subarray_Sum_Equals_k.java
public class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        HashMap<Integer,Integer> map = new HashMap<>();
        int sum = 0;
        int ans = 0;
        map.put(0,-1);
        for (int i = 0; i < nums.length; i++){
            sum += nums[i];
            if (map.containsKey(sum - k)){
                ans = Math.max(i - map.get(sum - k),ans);
            }
            if (!map.containsKey(sum)){
                
                map.put(sum,i);
            }
        }
        return ans;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Maximum_Subarray.java
public class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        int len = nums.length;
        int[] dp = new int[len];
        int max = nums[0];
        
        dp[0] = nums[0];
        
        for (int i = 1; i < len; i++){
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            max = Math.max(dp[i], max);
            
        }
        return max;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Maximum_XOR_of_Two_Numbers_in_an_Array.java
class Solution {
    public int findMaximumXOR(int[] nums) {
        int max = 0, mask = 0;

        for(int i = 31; i >= 0; i --) {

            mask = mask | (1 << i);
            Set<Integer> set = new HashSet<>();
            for(int num : nums) {
                // add the number which has the mask as its prefix;
                set.add(num & mask);
            }

            int tmp = max | (1 << i);
            for(Integer prefix : set) {
                if(set.contains(prefix ^ tmp)) {
 
                    max = tmp;
                    break;
                }
            }
        }
        return max;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Max_Area_of_Island.java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int[][] visited = new int[grid.length][grid[0].length];
        int max = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (visited[i][j] == 1 || grid[i][j] == 0) {
                    continue;
                }
                int cnt = 0;
                int[] init = new int[2];
                
                init[0] = i;
                init[1] = j;
                Queue<int[]> queue = new LinkedList<int[]>();
                queue.offer(init);
                visited[i][j] = 1;
                while (queue.size() > 0) {
                    int[] temp = queue.poll();
                    //System.out.println(temp[0] +"" + temp[1]);
                    cnt ++;
                    if (temp[0] < grid.length - 1 && visited[temp[0] + 1][temp[1]] == 0 && grid[temp[0] + 1][temp[1]] == 1) {
                        int[] d = new int[2];
                        d[0] = temp[0] + 1;
                        d[1] = temp[1];  
                        queue.offer(d);
                        visited[temp[0] + 1][temp[1]] = 1;
                    }
                    if (temp[1] < grid[0].length - 1 && visited[temp[0]][temp[1] + 1] == 0 && grid[temp[0]][temp[1] + 1] == 1) {
                        int[] r = new int[2];
                        r[0] = temp[0];
                        r[1] = temp[1] + 1; 
                        queue.offer(r);
                        visited[temp[0]][temp[1] + 1] = 1;
                    }
                    if (temp[0] > 0 && visited[temp[0] - 1][temp[1]] == 0 && grid[temp[0] - 1][temp[1]] == 1) {
                        int[] u = new int[2];
                        u[0] = temp[0] - 1;
                        u[1] = temp[1]; 
                        queue.offer(u);
                        visited[temp[0] - 1][temp[1]] = 1;
                    }
                    if (temp[1] > 0 && visited[temp[0]][temp[1] - 1] == 0 && grid[temp[0]][temp[1] - 1] == 1) {
                        int[] l = new int[2];
                        l[0] = temp[0];
                        l[1] = temp[1] - 1; 
                        queue.offer(l);
                        visited[temp[0]][temp[1] - 1] = 1;
                    }
                }
                max = Math.max(max, cnt);
            }
        }
        return max;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Median_of_Two_Sorted_Arrays.java
class Solution {
    public double findMedianSortedArrays(int A[], int B[]) {
        int len = A.length + B.length;
        if (len % 2 == 1) {
            return findKth(A, 0, B, 0, len / 2 + 1);
        }
        return (
            findKth(A, 0, B, 0, len / 2) + findKth(A, 0, B, 0, len / 2 + 1)
        ) / 2.0;
    }

    // find kth number of two sorted array
    public static int findKth(int[] A, int A_start,
                              int[] B, int B_start,
                              int k){		
		if (A_start >= A.length) {
			return B[B_start + k - 1];
		}
		if (B_start >= B.length) {
			return A[A_start + k - 1];
		}

		if (k == 1) {
			return Math.min(A[A_start], B[B_start]);
		}
		
		int A_key = A_start + k / 2 - 1 < A.length
		            ? A[A_start + k / 2 - 1]
		            : Integer.MAX_VALUE;
		int B_key = B_start + k / 2 - 1 < B.length
		            ? B[B_start + k / 2 - 1]
		            : Integer.MAX_VALUE; 
		
		if (A_key < B_key) {
			return findKth(A, A_start + k / 2, B, B_start, k - k / 2);
		} else {
			return findKth(A, A_start, B, B_start + k / 2, k - k / 2);
		}
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Merge_Intervals.java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        if (intervals == null || intervals.size() < 2) {
            return intervals;
        }
        List<Interval> result = new ArrayList<>();
        int [] start = new int[intervals.size()];
        int [] end = new int[intervals.size()];

        for (int i = 0; i < intervals.size(); i++){
            start[i] = intervals.get(i).start;
            end[i] = intervals.get(i).end;
        }
        Arrays.sort(start);
        Arrays.sort(end);
        int pointS = 1;
        int pointE = 0;
        int temp = start[0];
        while (pointS < start.length){
            if (start[pointS] > end[pointE]){
                Interval in = new Interval(temp, end[pointE]);
                result.add(in);
                temp = start[pointS];    
            }
            pointS ++;
            pointE ++;
        }
        result.add(new Interval(temp, end[end.length - 1]));
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Merge_Sorted_Array.java
public class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int cur = m + n - 1;
        while (cur >= 0){
            if (n == 0){
                nums1[cur] = nums1[m - 1];
                m --;
                cur --; 
            }
            else if (m == 0){
                nums1[cur] = nums2[n - 1];
                n --;
                cur --;   
            }
            else if( nums1[m - 1] >= nums2[n - 1]){
                nums1[cur] = nums1[m - 1];
                m --;
                cur --;
            }
            else {
                nums1[cur] = nums2[n - 1];
                n --;
                cur --;                
            }
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Merge_Two_Sorted_Lists.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while (l1 != null && l2 != null){
            if (l1.val < l2.val){
                curr.next = l1;
                l1 = l1.next;
            }
            else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        if (l1 != null) {
            curr.next = l1;
        }
        else if (l2 != null) {
            curr.next = l2;
        }
        return dummy.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Minimum_Depth_of_Binary_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if (root == null){
            return 0;
        }
        Queue<TreeNode> queue =  new LinkedList<>();
        queue.offer(root);
        int depth = 1;
        while(true){
            int len = queue.size();
            while(len > 0){
                TreeNode node = queue.poll();
                if(node.left == null && node.right == null){
                    return depth;
                }
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                len--;
            }
            depth++;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Minimum_Genetic_Mutation.java
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        if (bank == null|| bank.length == 0){
            return -1;
        }
        if (start.equals(end)){
            return 0;
        }
        HashSet<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        int times = 0;
        queue.offer(start);
        while (queue.size() > 0){
            int len = queue.size();
            while (len > 0){
                String curr = queue.poll();
                if (curr.equals(end)){
                    return times;
                }
                for (String str: bank){
                    if (visited.contains(str)){
                        continue;
                    }
                    int same = 0;
                    for (int i = 0; i < 8; i++){
                        if (str.charAt(i) == curr.charAt(i)){
                            same ++;
                        }
                    }
                    if (same == 7){
                        queue.offer(str);
                        visited.add(str);
                    }
                }
                len --;
            }
            times ++;
        }
        return -1;
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Minimum_Path_Sum.java
public class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0){
            return 0;
        }
        int[][] dp = new int[grid.length][grid[0].length];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < grid.length; i++){
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < grid[0].length; j++){
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int m = 1; m < grid.length; m++){
            for (int n = 1; n < grid[0].length; n++){
                dp[m][n] = Math.min(dp[m - 1][n], dp[m][n - 1]) + grid[m][n];
            }
        }
        
        return dp[grid.length - 1][ grid[0].length - 1];
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Minimum_Size_Subarray_Sum.java
public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        int min = Integer.MAX_VALUE;
        int sum = 0;
        while (fast < nums.length + 1){
            if (sum < s){
                if (fast == nums.length){
                    break;
                }
                sum = sum + nums[fast];
                fast += 1;
            }
            if (sum >= s){
                min = Math.min(min, fast - slow);
                sum = sum - nums[slow];
                slow += 1;
            }
        }
        if (min == Integer.MAX_VALUE){
            return 0;
        }
        return min;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Minimum_Window_Substring.java
public class Solution {
    public String minWindow(String s, String t) {
        int ahead = 0;
        int back = 0;
        int flag = 0;
        int len = t.length();
        String result = "";
        HashMap<Character,Integer> tmap = new HashMap<>();
        //HashMap<Character,Integer> cmap = new HashMap<>();
        int[] cmap = new int[64];
        for (int i = 0; i < len; i++){
            char c = t.charAt(i);
            tmap.put(c, 0);
            /*if (cmap.containsKey(c)){
                cmap.put(c,cmap.get(c) + 1);
            }
            else {
                cmap.put(c, 1);
            }*/
            if (cmap[c - 'A'] != 0){
                cmap[c - 'A'] ++;
            }
            else {
                cmap[c - 'A'] = 1;
            }
        }
        while (ahead < s.length()){
            
            if (flag < len){
                if (back >= s.length()){
                    break;
                }
                char c = s.charAt(back);
                if (tmap.containsKey(c)){
                    int no = tmap.get(c);
                    /*
                    if (no < cmap.get(c)){
                        flag ++;
                    }*/
                    if (no < cmap[c - 'A']){
                        flag ++;
                    }                    
                    tmap.put(c, no + 1);
                }
                back ++;
            }
            else {
                char c = s.charAt(ahead);
                if (tmap.containsKey(c)){
                    int no = tmap.get(c);
                    //if (no == cmap.get(c)){
                    if (no == cmap[c - 'A']){
                        if ((back - ahead) < result.length() || result.length() == 0){
                            result = s.substring(ahead,back);
                        }
                        flag --;
                    }
                    tmap.put(c, no - 1);
                }
                ahead ++;
            }
        }
        return result;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Min_Stack.java
class MinStack {
    private Stack<Integer> stack = null;
    private Stack<Integer> min = null;
    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack();
        min = new Stack();
    }
    
    public void push(int x) {
        stack.push(x);
        if (min.size() == 0 || x <= min.peek()){
            min.push(x);
        }
    }
    
    public void pop() {
        if (stack.size() == 0){
            return;
        }
        int temp = stack.pop();
        if (temp == min.peek()){
            min.pop();
        }
    }
    
    public int top() {
        if (stack.size() == 0){
            return 0;
        }
        return stack.peek();
    }
    
    public int getMin() {
        if (stack.size() == 0){
            return 0;
        }
        return min.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Missing_Ranges.java
class Solution {
    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> result = new ArrayList<>();
        if (nums == null || nums.length == 0){
            if (lower == upper){
                result.add(String.valueOf(lower));
            }
            else {
                result.add(lower + "->" + upper);
            }
            return result;
        }

        if (nums[0] == lower + 1) {
            result.add(String.valueOf(lower));
        }
        if (lower != Integer.MAX_VALUE && nums[0] > lower + 1) {
            result.add(lower + "->" + (nums[0] - 1));
        }
        for (int i = 1; i < nums.length; i ++){
            if (nums[i - 1] == nums[i] - 1){
                continue;
            }
            else if (nums[i - 1] == nums[i] - 2){
                result.add(String.valueOf(nums[i] - 1));
            }
            else if (nums[i - 1] < nums[i]){
                result.add((nums[i - 1] + 1) + "->" + (nums[i] - 1));
            }
        }
        if (nums[nums.length - 1] == upper - 1) {
            result.add(String.valueOf(upper));
        }
        if (upper != Integer.MIN_VALUE && nums[nums.length - 1] < upper - 1) {
            result.add((nums[nums.length - 1] + 1) + "->" + upper);
        }
        return result;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Move_Zeroes.java
public class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length < 2){
            return;
        }
        int slow = 0;
        int fast = 1;
        while(fast < nums.length){
            if (nums[slow] == 0 && nums[fast] != 0){
                nums[slow] = nums[fast];
                nums[fast] = 0;
                fast ++;
                slow ++;
            }
            else if(nums[slow] == 0){
                fast ++;
            }
            else{
                slow ++;
            }
            if (slow == fast){
                fast ++;
            }
            
        }
        return;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Moving_Average_from_Data_Stream.java
class MovingAverage {
    Queue<Integer> queue;
    int size;
    int sum;
    int cnt;
    /** Initialize your data structure here. */
    public MovingAverage(int size) {
        queue = new LinkedList<>();
        this.size = size;
        sum = 0;
        cnt = 0;
    }
    
    public double next(int val) {
        if (cnt < size){
            queue.add(val);
            cnt ++;
            sum += val;
        }
        else {
            sum = sum - queue.poll() + val;
            queue.add(val);
        }
        
        return 1.0 * sum / cnt;
    }
}

/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage obj = new MovingAverage(size);
 * double param_1 = obj.next(val);
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Next_Permutation.java
public class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Nim_Game.java
class Solution {
    public boolean canWinNim(int n) {
        if (n % 4 == 0) {
            return false;
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Number_of_1_Bits.java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
	    int ones = 0;
    	while(n!=0) {
    		ones = ones + (n & 1);
    		n = n>>>1;
    	}
    	return ones;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Number_of_Islands.java
class Solution {
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0){
            return 0;
        }
        int[][] visited = new int[grid.length][grid[0].length];
        int count = 0;
        for (int i = 0; i < grid.length; i++){
            for (int j = 0; j < grid[0].length; j++){
                if (grid[i][j] == '1' && visited[i][j] == 0){
                    count ++;
                    BFS(i, j, grid, visited);
                }
            }
        }
        return count;
    }
    public void BFS(int i, int j, char[][] grid, int[][] visited){
        int[] point = new int[2];
        point[0] = i;
        point[1] = j;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(point);
        while(queue.size() > 0){
            //System.out.println(queue.size());
            int[] temp = queue.poll();
            if (temp[0] > 0 && visited[temp[0] - 1][temp[1]] == 0  && grid[temp[0] - 1][temp[1]] == '1'){
                int[] up = new int[2];
                up[0] = temp[0] - 1;
                up[1] = temp[1];
                visited[temp[0] - 1][temp[1]] = 1;
                queue.offer(up);
            }
            if (temp[1] > 0 && visited[temp[0]][temp[1] - 1] == 0 && grid[temp[0]][temp[1] - 1] == '1'){
                int[] left = new int[2];
                left[0] = temp[0];
                left[1] = temp[1] - 1;
                visited[temp[0]][temp[1] - 1] = 1;
                queue.offer(left);
            }
            if (temp[0] < grid.length - 1 && visited[temp[0] + 1][temp[1]] == 0 && grid[temp[0] + 1][temp[1]] == '1'){
                int[] down = new int[2];
                down[0] = temp[0] + 1;
                down[1] = temp[1];
                visited[temp[0] + 1][temp[1]] = 1;
                queue.offer(down);
            }
            if (temp[1] < grid[0].length - 1 && visited[temp[0]][temp[1] + 1] == 0 && grid[temp[0]][temp[1] + 1] == '1'){
                int[] right = new int[2];
                right[0] = temp[0];
                right[1] = temp[1] + 1;
                visited[temp[0]][temp[1] + 1] = 1;
                queue.offer(right);
            } 
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\One_Edit_Distance.java
class Solution {
    public boolean isOneEditDistance(String s, String t) {
        if (Math.abs(s.length() - t.length()) > 1 || s.equals(t)){
            return false;
        }
        int flag = 0;
        int longI = 0;
        int shortI = 0;
        if (s.length() == t.length()){
            for (int i = 0; i < s.length(); i ++){
                
                if (s.charAt(i) != t.charAt(i)){
                    if (flag == 1){
                        return false;
                    }
                    flag = 1;
                }
            }
        }
        else {
            String shortS = s.length() > t.length() ? t : s;
            String longS = s.length() > t.length() ? s : t;
            while (longI < longS.length()){
                if(shortI == shortS.length() || longS.charAt(longI) != shortS.charAt(shortI)){
                    if (flag == 1){
                        return false;
                    }
                    flag = 1;
                    longI ++;
                    continue;
                    
                }
                longI ++;
                shortI ++;
            }
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Paint_Fence.java
public class Solution {
    public int numWays(int n, int k) {
        if (n == 0){
            return 0;
        }
        if (n == 1){
            return k;
        }
        if (n == 2){
            return k * k;
        }
        int[] dp = new int[n];
        dp [0] = k;
        dp [1] = k * k;
        for (int i = 2; i < n;i++){
            dp[i] = (k - 1) * dp[i - 2] + dp[i - 1] * (k - 1);
        }
        return dp[n - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Paint_House.java
public class Solution {
    public int minCost(int[][] costs) {
        if (costs == null || costs.length == 0){
            return 0;
        }
        int[][] dp = new int[costs.length][3];
        dp[0][0] = costs[0][0];
        dp[0][1] = costs[0][1];
        dp[0][2] = costs[0][2];
        
        
        for (int i = 1; i < costs.length; i++){
            dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0];
            dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1];
            dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][0]) + costs[i][2];
        }
        return Math.min(Math.min(dp[costs.length - 1][0], dp[costs.length - 1][1]), dp[costs.length - 1][2]);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Paint_House_II.java
public class Solution {
    public int minCostII(int[][] costs) {
        if (costs == null || costs.length == 0){
            return 0;
        }
        int k = costs[0].length;
        int[][] dp = new int[costs.length][k];
        for (int m = 0; m < k; m++){
            dp[0][m] = costs[0][m];
        }
        int min = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        int minIndex = 0;
        int min2Index = 0;
        for (int i = 1; i < costs.length; i++){
            min = Integer.MAX_VALUE;
            
            min2 = Integer.MAX_VALUE;
            for (int n = 0; n < k; n++){
                if(dp[i - 1][n] < min){
                    min2 = min;
                    min2Index = minIndex;
                    min = dp[i - 1][n];
                    minIndex = n;
                    
                }
                else if (dp[i - 1][n] < min2){
                    min2 = dp[i - 1][n];
                    min2Index = n;
                }
            } 
            for (int j = 0; j < k; j ++){
                if (j == minIndex){
                    dp[i][j] = min2 + costs[i][j];
                }
                else{
                    dp[i][j] = min + costs[i][j];
                }
                 
            }
        }
        min = Integer.MAX_VALUE;

        for (int n = 0; n < k; n++){
            if (dp[costs.length - 1][n] < min){
                min = dp[costs.length - 1][n];
            }
        }
        return min;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Palindrome_Linked_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null){
            return true;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null){
            if(fast.next.next == null){
                fast = fast.next;
                break;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode node = reverse(slow.next);
        while (node != null){
            if(head.val != node.val){
                return false;
            }
            node = node.next;
            head = head.next;
        }
        return true;
    }
    public ListNode reverse(ListNode head){
        ListNode node;
        if (head.next != null){
            node = reverse(head.next);
            head.next.next = head;
            head.next = null;
        }
        else{
            node = head;
        }
        
        
        return node;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Palindrome_Number.java
class Solution {
    public boolean isPalindrome(int x) {
        if (x == 0){
            return true;
        }
        if (x < 0 || x % 10 == 0){
            return false;
        }
        int revert = 0;
        while (revert * 10 <= x){
            revert = x % 10 + 10 * revert;
            x = x / 10;
        }
        return (x == revert || x == revert / 10);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Palindrome_Permutation.java
class Solution {
    public boolean canPermutePalindrome(String s) {
        int[] charSet = new int[128];
        for (int i = 0; i < s.length(); i ++){

            charSet[s.charAt(i)] ++;
        }
        int flag = 0;
        for (int j : charSet){
            if (j % 2 == 1){
                flag ++;
            }
            if (flag > 1){
                return false;
            }
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Partition_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        if (head == null){
            return null;
        }
        ListNode dummy = new ListNode(0);
        ListNode slow = dummy;
        ListNode fast = head;
        dummy.next = head;
        while (fast.val < x){
            fast = fast.next;
            if (fast == null){
                return head;
            }
        }
        while (slow.next.val < x){
            slow = slow.next;
        }
        while (fast.next != null){
            if (fast.next.val >= x){
                fast = fast.next;
            }
            else {
                ListNode temp = fast.next;
                fast.next = fast.next.next;
                temp.next = slow.next;
                slow.next = temp;
                slow = slow.next;
            }
        }

        return dummy.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Pascal&#39;s_Triangle.java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();
        if (numRows == 0) {
            return result;
        }
        List<Integer> row0 = new ArrayList<>();
        row0.add(1);
        result.add(row0);
        for (int i = 1; i < numRows; i++) {
            List<Integer> row = new ArrayList<Integer>();
            row.add(1);
            List<Integer> last = result.get(i - 1);                
            for (int j = 1; j < i; j ++) {
                int res = last.get(j - 1) + last.get(j);
                row.add(res);
            }
            row.add(1);
            result.add(row);
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Path_Sum.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        boolean ans = false;
        ans = DFS(root,sum);
        return ans;
        
    }
    public boolean DFS(TreeNode root, int sum){
        if (root == null){
            return false;
        }
        boolean ansl = false;
        boolean ansr = false;
        if (root.left != null){
            ansl = DFS(root.left,sum-root.val);
        }
        if (root.right != null){
            ansr = DFS(root.right,sum-root.val);
        }
        if (root.right == null && root.left == null){
            if(sum - root.val == 0){
                return true;
            }
            return false;
        }
        else{
            return (ansl||ansr);
        }
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Path_Sum_II.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Stack<Integer> path = new Stack<Integer>();
        DFS(root,sum,result,path);
        return result;
    }
    public void DFS(TreeNode node, int sum, List<List<Integer>> result, Stack<Integer> path){
        if(node == null){
            return;
        }
        path.add(node.val);
        if (node.left == null && node.right == null){
            if (sum == node.val){
                result.add(new ArrayList<Integer>(path));
                path.pop();
                return;
            }
            path.pop();
            return;
        }
        else{
            if (node.left != null){
                DFS(node.left,sum-node.val,result,path);
            }
            if (node.right != null){
                DFS(node.right,sum-node.val,result,path);
            }
            path.pop();
            return;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Perfect_Squares.java
public class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++){
            
            dp[i] = i;
            
            int a = (int)Math.sqrt(i);
            if (a * a == i){
                dp[i] = 1;
                continue;
            }
            
            for (int j = 0; j * j < i; j++){
                if(dp[i-j*j]+1<dp[i]) {
                    dp[i] = dp[i-j*j]+1;
                }
            }
                
        }
            
        
        return dp[n];
     }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Permutations.java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result =  new ArrayList<>();
        DFS(result, new ArrayList<>(), nums, new HashSet<>());
        return result;
    }
    
    public void DFS(List<List<Integer>> result, List<Integer> temp, int[] nums, HashSet<Integer> set){
        if (temp.size() == nums.length){
            result.add(new ArrayList<>(temp));
            return;
        }
        for (int i = 0; i < nums.length; i ++){
            if (set.contains(nums[i])){
                continue;
            }
            temp.add(nums[i]);
            set.add(nums[i]);
            DFS(result, temp, nums, set);
            temp.remove(temp.size() - 1);
            set.remove(nums[i]);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Permutations_II.java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        DFS(result, new ArrayList<>(), nums, new HashSet<>());
        return result;
    }
    
    public void DFS(List<List<Integer>> result, List<Integer> temp, int[] nums, HashSet<Integer> set){
        if (nums.length == temp.size()){
            result.add(new ArrayList<>(temp));
            return;
        }
        Integer cur = null;
        for (int i = 0; i < nums.length; i++){
            if (set.contains(i) || (cur != null && nums[i] == cur)){
                continue;
            }
            cur = nums[i];
            set.add(i);
            temp.add(nums[i]);
            DFS(result, temp, nums, set);
            set.remove(i);
            temp.remove(temp.size() - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Plus_One.java
class Solution {
    public int[] plusOne(int[] digits) {
        if (digits[0] == 0) {
            digits[0] = 1;
            return digits;
        }
        int carry = 0;
        for (int i = digits.length - 1; i >= 0 ; i--){
            int temp = 0;
            if (i == digits.length - 1) {
                temp = digits[i] + 1;
            }
            else{
                temp = digits[i] + carry;
            }
            if (temp == 10) {
                digits[i] = 0;
                carry = 1;
            }
            else {
                digits[i] = temp;
                return digits;
            }
        }
        if (carry == 1) {
            int[] res = new int[digits.length + 1];
            res[0] = 1;
            for (int i = 0; i < digits.length; i ++) {
                res[i + 1] = digits[i];
            }
            return res;
        }
        else {
            return digits;
        }

    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Power_of_Four.java
class Solution {
    public boolean isPowerOfFour(int num) {
        return (num > 0) && ((num & (num - 1)) == 0) && ((num & 0x55555555) == num);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Power_of_Three.java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n == 0) {
            return false;
        }
        if (n == 1) {
            return true;
        }
        if (n % 3 != 0){
            return false;
        }
        return isPowerOfThree(n / 3);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Power_of_Two.java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n == 0 || n == Integer.MIN_VALUE) {
            return false;
        }
        if ((n & (n - 1)) == 0 ) {
            return true;
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Product_of_Array_Except_Self.java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] left = new int[nums.length];
        int[] right = new int[nums.length];
        int[] result = new int[nums.length];
        left[0] = nums[0];
        right[nums.length - 1] = nums[nums.length - 1];
        for (int i = 1; i < nums.length - 1; i ++){
            left[i] = left[i - 1] * nums[i];
            right[nums.length - 1 - i] = right[nums.length - i] * nums[nums.length - 1 - i];
        }
        result[0] = right[1];
        result[nums.length - 1] = left[nums.length - 2];
        for (int j = 1; j < nums.length - 1; j++){
            result[j] = left[j - 1] * right [j + 1];
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Remove_Duplicates_from_Sorted_Array_II.java
public class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        if (nums.length < 3){
            return nums.length;
        }
        int slow = 2;
        int fast = 2;

        
        while (fast < nums.length){
            if (nums[slow - 2] == nums[fast]){
                fast ++;
            }
            else{
                nums[slow] = nums[fast];
                slow += 1;
                fast ++;
            }
        }
        return slow;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Remove_Duplicates_from_Sorted_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null){
            return null;
        }
        if (head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(Integer.MAX_VALUE);
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = head;
        while (fast.next != null){
            if (fast.next.val != fast.val){
                slow.next = fast;
                slow = slow.next;
                fast = fast.next;
            }
            else {
                fast = fast.next;
            }
        }
        slow.next = fast;
        return dummy.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Remove_Duplicates_from_Sorted_List_II.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null){
            return head;
        }
        ListNode dummy = new ListNode(0);
        ListNode previous = dummy;
        dummy.next = head;
        ListNode curr = head;
        int flag = 0;
        while (curr.next != null ){
            if (curr.next.val != curr.val && flag == 0){
                previous = curr;
                curr = curr.next;
            }
            else if (curr.next.val != curr.val && flag == 1){
                previous.next = curr.next;
                curr = curr.next;
                flag = 0;
            }
            else {
                flag = 1;
                curr = curr.next;
            }
        }
        if (flag == 1){
            previous.next = null;
        }
        return dummy.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Remove_Linked_List_Elements.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode curr = head;
        ListNode dummy = new ListNode(1);
        dummy.next = head;
        ListNode last = dummy;
        while (curr != null){
            if (curr.val == val){
                last.next = curr.next;
                curr = curr.next;
                continue;
            }
            last = curr;
            curr = curr.next; 
        }
        return dummy.next;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Remove_Nth_Node_From_End_of_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head.next == null && n == 1){
            return null;
        }
        ListNode start = head;
        ListNode end = head;
        while (n > 0){
            end = end.next;
            n --;
        }
        if(end == null){
            return head.next;
        }

        while (end.next != null){
            start = start.next;
            end = end.next;
        }
        start.next = start.next.next;
        return head;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Repeated_DNA_Sequences.java
public class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        HashSet<String> set = new HashSet<>();
        HashSet<String> resultSet = new HashSet<>();
        List<String> result = new ArrayList<>();
        String temp = "";
        for (int i = 0; i < s.length() - 9; i++){
            temp = s.substring(i,i + 10);
            if (!set.add(temp)){
                if (resultSet.add(temp)){
                    result.add(temp);
                }
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Restore_IP_Addresses.java
public class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> list = new ArrayList<>();
        list = listAll(s, 4);
        return list;
    }
    public List<String> listAll(String s, int tokens){
        List<String> list = new ArrayList<String>();
        if (s.length() == 0 && tokens == 0){
            list.add("");
            return list;
        }
        if (s.length() > 3 * tokens || s.length() < tokens){
            return list;
        }

        
        List<String> list1 = listAll(s.substring(1), tokens - 1);
        
        List<String> list2 = new ArrayList<>();
        if (s.charAt(0) != '0' && s.length() > 1){
            list2 = listAll(s.substring(2), tokens - 1);
        }
        List<String> list3 = new ArrayList<>();
        if (s.charAt(0) != '0' && s.length() > 2 && Integer.parseInt(s.substring(0, 3)) < 256){
            list3 = listAll(s.substring(3), tokens - 1);
        }
        for (String s1: list1){
            if (s1.equals("")){
                list.add(s.substring(0, 1));
            }
            else{
                list.add(s.substring(0, 1) + "." + s1);
            }      
        }
        for (String s2: list2){
            if (s2.equals("")){
                list.add(s.substring(0, 2));
            }
            else{
                list.add(s.substring(0, 2) + "." + s2);
            }
        }
        for (String s3: list3){
            if (s3.equals("")){
                list.add(s.substring(0, 3));
            }
            else{
                list.add(s.substring(0, 3) + "." + s3);
            }
        }
        return list;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Reverse_Integer.java
public class Solution {
    public int reverse(int x) {
        if(x == 0 || x == -2147483648){
            return 0;
        }
        
        String number = String.valueOf(Math.abs(x));
        long result = 0;
        for (int i = 0; i < number.length(); i++){
            result += Integer.parseInt(number.substring(i,i+1)) * Math.pow(10,i);
        }
        if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE){
            return 0;
        }
        else {
            return (int)result * (x / Math.abs(x));
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Reverse_Linked_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null){
            return null;
        }
        if (head.next == null){
            return head;
        }
        ListNode tail = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return tail;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Reverse_String.java
public class Solution {
    public String reverseString(String s) {
        if (s == null || s.length() == 0){
            return s;
        }  
        StringBuilder sb = new StringBuilder();
        for (int i = s.length() - 1; i >= 0; i --){
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Reverse_Words_in_a_String.java
public class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        s = s.trim();
        if (s.length() == 0) {
            return "";
        }
        int slow = 0;
        int fast = 0;
        while (fast < s.length()) {
            if (s.charAt(fast) == ' ') {
                String ss = s.substring(slow, fast);
                if (!ss.equals("")) {
                    sb.insert(0, " " + s.substring(slow, fast));
                }
                fast++;
                slow = fast;
            } else {
                fast++;
            }
        }
        sb.insert(0, s.substring(slow, s.length()));
        return sb.toString().trim();
    }
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Roman_to_Integer.java
class Solution {
    public int romanToInt(String s) {
        if (s.length() == 0){
            return 0;
        }
        int cur = 0;
        if (s.length() > 1){
            if (s.substring(0, 2).equals("IV")){
                return 4 + romanToInt(s.substring(2));
            }
            else if (s.substring(0, 2).equals("IX")){
                return 9 + romanToInt(s.substring(2));
            }
            else if (s.substring(0, 2).equals("XL")){
                return 40 + romanToInt(s.substring(2));
            }
            else if (s.substring(0, 2).equals("XC")){
                return 90 + romanToInt(s.substring(2));
            }
            else if (s.substring(0, 2).equals("CD")){
                return 400 + romanToInt(s.substring(2));
            }
            else if (s.substring(0, 2).equals("CM")){
                return 900 + romanToInt(s.substring(2));
            }
        }

            switch (s.charAt(0)){
                case 'I' : cur = 1;
                    break;
                case 'V' : cur = 5;
                    break;
                case 'X' : cur = 10;
                    break;
                case 'L' : cur = 50;
                    break;
                case 'C' : cur = 100;
                    break;
                case 'D' : cur = 500;
                    break; 
                case 'M' : cur = 1000;
                    break;
            }
        
        return cur + romanToInt(s.substring(1));
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Rotate_Image.java
class Solution {
    public void rotate(int[][] matrix) {
        swap(0, matrix);
    }
    
    public void swap(int level, int[][] matrix){
        if (level > matrix.length / 2){
            return;
        }
        for (int i = level; i < matrix.length - 1 - level; i ++){
            int temp = matrix[level][i];
            matrix[level][i] = matrix[matrix.length - 1 - i][level];
            matrix[matrix.length - 1 - i][level] = matrix[matrix.length - 1 - level][matrix.length - 1 - i];
            matrix[matrix.length - 1 - level][matrix.length - 1 - i] = matrix[i][matrix.length - 1 - level];
            matrix[i][matrix.length - 1 - level] = temp;
        }
        swap(level + 1, matrix);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Rotate_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null){
            return null;
        }
        if (k == 0){
            return head;
        }
        ListNode slow = head;
        ListNode fast = head;
        int cnt = 0;
        while (k > 0){
            fast = fast.next;
            cnt ++;
            k--;
            if (fast == null){
                fast = head;
                k = k % cnt;
            }
        }
        if (fast == head){
            return head;
        }
        while (fast.next != null){
            fast = fast.next;
            slow = slow.next;       
        }
        ListNode result = slow.next;
        fast.next = head;
        slow.next = null;
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Same_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        Queue<TreeNode> queuep = new LinkedList<TreeNode>();
        Queue<TreeNode> queueq = new LinkedList<TreeNode>();
        if(p == null && q == null){
            return true;
        }
        else if (p == null || q == null){
            return false;
        }
        queuep.offer(p);
        queueq.offer(q);
        int lenp;
        int lenq;
        while( queuep.size()!=0 && queueq.size()!=0){
            lenp = queuep.size();
            lenq = queueq.size();
            if (lenq != lenp){
                return false;
            }
            else{
                while (lenq > 0){
                    lenq --;
                    TreeNode nodep = queuep.poll();
                    TreeNode nodeq = queueq.poll();
                    if (nodeq.val != nodep.val){return false;}

                    if (nodep.left != null){
                        queuep.offer(nodep.left);
                    }
                    if (nodeq.left != null){
                        queueq.offer(nodeq.left);
                    }
                    if (queuep.size() != queueq.size()){
                        return false;
                    }
                    if (nodep.right != null){
                        queuep.offer(nodep.right);
                    }
                    if (nodeq.right != null){
                        queueq.offer(nodeq.right);
                    }
                }
            }
        }
        if (queuep.size() == queueq.size()){
            return true;
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Search_a_2D_Matrix_II.java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0|| matrix[0].length == 0) {
            return false;
        }
        int row = 0;
        int column = matrix[0].length - 1;
        while (row < matrix.length && column >= 0 ) {
            if (matrix[row][column] == target) {
                return true;
            }
            if (matrix[row][column] < target) {
                row ++;
            }
            else {
                column --;
            }
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Search_for_a_Range.java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[2];        
        result[0] = -1;
        result[1] = -1;
        if (nums == null || nums.length == 0){
            return result;
        }

        int start = 0;
        int end = nums.length - 1;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (nums[mid] >= target) {
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (target == nums[start]){
            result[0] = start;
        }
        else if ( target == nums[end]){
            result[0] = end;
        }
        else {

            return result;
        }
        start = 0;
        end = nums.length - 1;        
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (nums[mid] > target) {
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (target == nums[end]){
            result[1] =  end;
        }
        else if ( target == nums[start]){
            result[1] =  start;
        }
        else {
            return result;
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Search_Insert_Position.java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (start + 1 < end ){
            int mid = (end - start) / 2 + start;
            if (nums[mid] > target){
                end = mid;
            }
            else if (target == nums[mid]){
                return mid;
            }
            else {
                start = mid ;
            }
        }
        if (target <= nums[start]){
            return start;
        }
        else if(target <= nums[end]){
            return end;
        }
        else {
            return end + 1;
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Search_in_Rotated_Sorted_Array_II.java

class Solution {
    public boolean search(int[] nums, int target) {
        if (nums == null || nums.length == 0){
            return false;
        }
        int start = 0;
        int end = nums.length - 1;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (nums[mid] == target){
                return true;
            }
            else if (nums[end] > nums[mid]){
                if (target < nums[mid]){
                    end = mid;
                }
                else {
                    if (target <= nums[end]){
                        start = mid;
                    }
                    else{
                        end = mid;
                    }
                }
            }
            else if (nums[end] == nums[mid]){
                end --;
            }
            else {
                if (target > nums[mid]){
                    start = mid;
                }
                else {
                    if (target <= nums[end]){
                        start = mid;
                    }
                    else {
                        end = mid;
                    }
                }
            }
        }
        if (nums[start] == target){
            return true;
        }
        else if(nums[end] == target){
            return true;
        }
        else {return false;}
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Set_Matrix_Zeroes.java
class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0){
            return;
        }
        int[] xaxis = new int[matrix[0].length];
        int[] yaxis = new int[matrix.length];
        for (int y = 0; y < matrix.length; y ++){
            for (int x = 0; x < matrix[0].length; x ++){
                if (matrix[y][x] == 0){
                    xaxis[x] = 1;
                    yaxis[y] = 1;
                }
            }
        }
        for (int y = 0; y < matrix.length; y ++){
            for (int x = 0; x < matrix[0].length; x ++){
                if (xaxis[x] == 1 || yaxis[y] == 1){
                    matrix[y][x] = 0;
                }
            }
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Shortest_Word_Distance.java
public class Solution {
    public int shortestDistance(String[] words, String word1, String word2) {
        ArrayList<Integer> w1 = new ArrayList<>();
        ArrayList<Integer> w2 = new ArrayList<>();
        int res = Integer.MAX_VALUE;
        w1.add(-10000);
        w2.add(-10000);
        for(int i = 0; i < words.length; i++){
            if (words[i].equals(word1)){
                w1.add(i);
                res = Math.min((i - w2.get(w2.size() - 1)),res);
            }
            else if (words[i].equals(word2) ) {
                w2.add(i);
                res = Math.min((i - w1.get(w1.size() - 1)),res);
            }
        }
        return res;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Shortest_Word_Distance_II.java
public class WordDistance {
    HashMap<String,ArrayList<Integer>> map = new HashMap<>();
    public WordDistance(String[] words) {
        for (int i = 0; i < words.length; i++){
            if (!map.containsKey(words[i])){
                map.put(words[i], new ArrayList<>());
            }
            map.get(words[i]).add(i);
        }
    }
    
    public int shortest(String word1, String word2) {
        ArrayList<Integer> w1 = map.get(word1);
        ArrayList<Integer> w2 = map.get(word2);
        int distance = Integer.MAX_VALUE;
        int i1 = 0;
        int i2 = 0;
        while (i1 < w1.size() || i2 < w2.size()){
            
            if (w1.get(i1) > w2.get(i2)){
                distance = Math.min(distance, w1.get(i1) - w2.get(i2));
                if (i2 == w2.size() - 1){
                    return distance;
                }
                i2 ++;
            }
            else {
                distance = Math.min(distance, w2.get(i2) - w1.get(i1));
                if (i1 == w1.size() - 1 ){
                    return distance;
                }
                i1 ++;
            }
        }
        return distance;
    }
}

/**
 * Your WordDistance object will be instantiated and called as such:
 * WordDistance obj = new WordDistance(words);
 * int param_1 = obj.shortest(word1,word2);
 */
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Simplify_Path.java
public class Solution {
    public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<>();
        Set<String> skip = new HashSet<>(Arrays.asList("..",".",""));
        for (String dir : path.split("/")) {
            if (dir.equals("..") && !stack.isEmpty()) stack.pop();
            else if (!skip.contains(dir)) stack.push(dir);
        }
        String res = "";
        for (String dir : stack) res = "/" + dir + res;
        return res.isEmpty() ? "/" : res;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Single_Number.java
public class Solution {
public int singleNumber(int[] nums) {
    int ans =0;
    
    int len = nums.length;
    for(int i=0;i!=len;i++)
        ans ^= nums[i];
    
    return ans;
    
}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Sort_Colors.java
class Solution {
    public void sortColors(int[] nums) {
        int[] map = new int[3];
        for (int i: nums){
            map[i] ++;
        }
        for (int j = 0; j < nums.length; j ++){
            if (j < map[0]) {
                nums[j] = 0;
            }
            else if (j < map[0] + map[1]){
                nums[j] = 1;
            }
            else {
                nums[j] = 2;
            }
        }
    }
    
    public void swap(int[] nums, int index1, int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Sort_List.java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode prev = null, slow = head, fast = head;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        prev.next = null;
        return merge(sortList(head), sortList(slow));
    }
    
    private ListNode merge(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        ListNode head = null;
        if (l1.val<l2.val) {
            head = l1;
            head.next = merge(l1.next, l2);
        } else {
            head = l2;
            head.next = merge(l1, l2.next);
        }
        return head;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Sparse_Matrix_Multiplication.java
public class Solution {
    public int[][] multiply(int[][] A, int[][] B) {
        int m = A.length, n = B.length, l = B[0].length;
        int [][] result = new int[m][l];
        for (int i = 0; i < m; i ++){
            for(int k = 0; k < n; k++){
                if (A[i][k] != 0){
                    for(int j = 0; j < l; j++){
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Spiral_Matrix.java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return result;
        }

        int cnt = 0;
        int x = 0;
        int y = 0;
        while (cnt < matrix.length * matrix[0].length){
            result.add(matrix[y][x]);
            //System.out.println(matrix[y][x]);
            if (cnt == matrix.length * matrix[0].length - 1){
                break;
            }
            matrix[y][x] = 99999;
            if ((x == 0 || matrix[y][x - 1] ==  99999) && (y == 0 || matrix[y - 1][x] == 99999) && (x != matrix[0].length - 1 && matrix[y][x + 1] != 99999)){
                x ++;
            }
            else if ((y == 0 || matrix[y - 1][x] == 99999) && (x == matrix[0].length - 1 || matrix[y][x + 1] == 99999) && (y != matrix.length - 1 && matrix[y + 1][x] != 99999)){
                y ++;
            }
            else if ((y == matrix.length - 1 || matrix[y + 1][x] == 99999) && (x == matrix[0].length - 1 || matrix[y][x + 1] == 99999) && (x != 0 && matrix[y][x - 1] != 99999)){
                x --;
            }
            else if ((y == matrix.length - 1 || matrix[y + 1][x] == 99999) && (x == 0 || matrix[y][x - 1] == 99999) && ( y != 0 && matrix[y - 1][x] != 99999)){
                y --;
            } 
            cnt ++;
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Strobogrammatic_Number.java
public class Solution {
    public boolean isStrobogrammatic(String num) {
        int start = 0;
        int end = num.length() - 1;
        while (end >= start){
            char s = num.charAt(start);
            char e = num.charAt(end);
            if (start == end && (s == '0' || s == '8' || s == '1')){
                return true;
            }
            else if(s == e && (s == '0' || s == '8' || s == '1')){
                start ++;
                end --;
            }
            else if ((s == '6' && e == '9') || (s == '9' && e == '6')){
                start ++;
                end --;
            }
            else {
                return false;
            }
            
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Subarray_Sum_Equals_K.java
class Solution {
    public int subarraySum(int[] nums, int k) {
        //HashMap<Integer, Integer> map = new HashMap<>();
        int cnt = 0;
        HashMap<Integer, Integer> prefixSum = new HashMap<>();
        int sum = 0;
        prefixSum.put(0, 1);
        for (int i = 0; i < nums.length; i ++) {
            sum += nums[i];
            
            if (prefixSum.containsKey(sum - k)) {
                cnt += prefixSum.get(sum - k);
                
            }
            prefixSum.put(sum, prefixSum.getOrDefault(sum, 0) + 1);
        }
        return cnt;  
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Subsets.java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        DFS(result, new ArrayList<>(), nums, 0);
        return result;
    }
    
    public void DFS(List<List<Integer>> result, ArrayList<Integer> temp, int[] nums, int start){
        result.add(new ArrayList(temp));
        for (int i = start; i < nums.length; i++){
            temp.add(nums[i]);
            DFS(result, temp, nums, i + 1);
            temp.remove(temp.size() - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Subsets_II.java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        DFS(result, new ArrayList<>(), nums, 0);
        return result;
    }
    
    public void DFS(List<List<Integer>> result, List<Integer> temp, int[] nums, int start){
        result.add(new ArrayList<>(temp));
        if (start >= nums.length){
            return;
        }
        int cur = nums[start];
        for (int i = start; i < nums.length; i++){
            if (i > start && nums[i] == cur){
                continue;
            }
            cur = nums[i];
            temp.add(nums[i]);
            DFS(result, temp, nums, i + 1);
            temp.remove(temp.size() - 1);
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Summary_Ranges.java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> ls = new ArrayList<>();
        if (nums == null || nums.length == 0){
            return ls;
        }

        int slow = 0;
        for (int i = 1; i < nums.length; i++){
            if (nums[i] - nums[i - 1] == 1){
                continue;
            }
            else{
                String st = "";
                if (slow == i - 1){
                    st = "" + nums[slow];
                }
                else{
                    st = "" + nums[slow] + "->" + (nums[i - 1]);
                }
                slow = i;
                ls.add(st);
            }
        }
        if (slow == nums.length - 1){
            ls.add(new String("" + nums[slow]));
        }
        else {
            ls.add(new String("" + nums[slow] + "->" + (nums[nums.length - 1])));
        }
        return ls;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Sum_Root_to_Leaf_Numbers.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {


    public int sumNumbers(TreeNode root) {
        Integer[] result = new Integer[1];
        result[0] = 0;
        int sum = 0;
        DFS(root, sum, result);
        return result[0];
    }

    public void DFS(TreeNode node, int sum, Integer[] path) {
        if (node == null) {
            return;
        }
        //sum.add(node.val);
    
        sum = sum*10+node.val;
        if (node.left == null && node.right == null) {
            /*
            StringBuilder sb = new StringBuilder();
            for (int i : sum) {
                sb.append(String.valueOf(i));
            }
            */
            path[0] += sum;
            sum = sum / 10;
            //sum.pop();
            return;
        } else {
            if (node.left != null) {
                DFS(node.left, sum, path);
            }
            if (node.right != null) {
                DFS(node.right, sum, path);
            }
            sum = sum / 10;
            //sum.pop();
            return;
        }

    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Symmetric_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        TreeNode left = root.left;
        TreeNode right = root.right;
        return symmetricHelper(left,right);
        
    }
    public boolean symmetricHelper(TreeNode p, TreeNode q){
        if (p == null && q == null){
            return true;
        }
        else if (p == null || q == null){
            return false;
        }
        else if (p.val != q.val){return false;}
        boolean le = symmetricHelper(p.left,q.right);
        boolean re = symmetricHelper(p.right,q.left);
        return (le && re);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\test.java
public class Solution {
    public int numDecodings(String s) {
        if (s == null || s.equals("0")){
            return 0;
        }
        if (s.length() < 2){
            return s.length();
        }
        int[] dp = new int[s.length()];
        if(s.charAt(0) != '0'){
            dp[0] = 1;
        }
        else{
            dp[0] = 0;
        }
        if (s.charAt(1) == '0' && (s.charAt(0) != '1' && s.charAt(0) != '2')) {
            return 0;
        }
        if(Integer.parseInt(s.substring(0,2)) < 27 && s.charAt(1) != '0' && Integer.parseInt(s.substring(0,2)) > 10){
            dp[1] = dp[0] + 1;
        }
        else{
            dp[1] = dp[0];
        }
        for (int i = 2; i < s.length(); i++){
            if (s.charAt(i) == '0'){
                if (s.charAt(i - 1) != '1' && s.charAt(i - 1) != '2'){
                    return 0;
                }
                dp[i] = dp[i - 2];
                dp[i - 1] = dp[i - 2];
            }
            else if (Integer.parseInt(s.substring(i - 1,i + 1)) < 27 && Integer.parseInt(s.substring(i - 1,i + 1)) > 10){
                dp[i] = dp[i - 1] + 1 * dp[i - 2];
            }
            else{
                dp[i] = dp[i - 1];
            }
        }
        return dp[s.length() - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Top_K_Frequent_Words.java
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        List<String> res = new ArrayList<>();
        HashMap<String, Integer> freq = new HashMap<>();
        for(String s: words) {
            freq.putIfAbsent(s, 0);
            freq.put(s, freq.get(s) + 1);
        }
        PriorityQueue<Map.Entry<String, Integer>> heap = new PriorityQueue<>(k, ((Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2) -> {
            int comp = (e1.getValue().compareTo(e2.getValue()));
            if (comp == 0) {
                comp = e2.getKey().compareTo(e1.getKey());
            }
            return comp;
        }));
        for (Map.Entry<String, Integer> entry : freq.entrySet()) {
            if (heap.size() < k) {
                heap.offer(entry);
            }
            else if (heap.peek().getValue() < entry.getValue() || (heap.peek().getValue().equals(entry.getValue()) && entry.getKey().compareTo(heap.peek().getKey()) < 0)) {
                heap.poll();
                heap.offer(entry);
            }
        }
        while(k > 0) {
            res.add(0, heap.poll().getKey());
            k --;
        }
        
        return res;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Trapping_Rain_Water.java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int leftHigh = 0;
        int rightHigh = 0;
        int ans = 0;
        while (left <= right) {
            if (leftHigh <= rightHigh) {
                if (height[left] < leftHigh) {
                    ans += (leftHigh - height[left]);
                }
                else {
                    leftHigh = height[left];
                }
                left ++;
            }
            else {
                if (height[right] < rightHigh) {
                    ans += (rightHigh - height[right]);
                }
                else {
                    rightHigh = height[right];
                }
                right --;
            }
        }
        return ans;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Triangle.java
/*public class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0 || triangle.get(0) == null || triangle.get(0).size() == 0){
            return 0;
        }
        int[][] dp = new int[triangle.size()][triangle.size()];
        dp[0][0] = triangle.get(0).get(0);
        for (int j = 1; j < triangle.size(); j++){
            dp[j][0] = triangle.get(j).get(0) + dp[j-1][0];
            dp[j][j] = triangle.get(j).get(j) + dp[j - 1][j - 1];
            for (int i = 1; i < triangle.get(j).size() - 1; i++){
                dp[j][i] = Math.min(dp[j - 1][i], dp[j - 1][i - 1]) + triangle.get(j).get(i);
            }
        }
        int min = Integer.MAX_VALUE;
        for (int in : dp[triangle.size() - 1]){
            min = Math.min(in, min);
        }
        return min;
    }
}*/
public class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] A = new int[triangle.size()+1];
        for(int i=triangle.size()-1;i>=0;i--){
            for(int j=0;j<triangle.get(i).size();j++){
                A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j);
            }
        }
        return A[0];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Two_Sum_II_-_Input_array_is_sorted.java
public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int start = 0;
        int end = numbers.length - 1;
        int sum = numbers[start] + numbers[end];
        while (sum != target){
            if (sum < target){
                start ++;
            }
            else {
                end --;
            }
            sum = numbers[start] + numbers[end];
        }
        int[] ans = {start + 1,end + 1};
        return ans;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Ugly_Number.java
public class Solution {
    public boolean isUgly(int num) {
        if (num == 1 ) {
            return true;
        }
        if (num == 0){
            return false;
        }
        
        while (num % 2 == 0){
            num = num / 2;
        }
        while (num % 3 == 0){
            num = num / 3;
        }
        while (num % 5 == 0){
            num = num / 5;
        }
        if (num == 1){
            return true;
        }
        return false;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Ugly_Number_II.java
public class Solution {
    /*
    public int nthUglyNumber(int n) {
        Queue<Integer> queue = new PriorityQueue<Integer>();
        queue.offer(1);
        int cnt = 0;
        int number = 0;
        HashSet<Integer> set  = new HashSet<>();
        int limit2 = Integer.MAX_VALUE/2;
        int limit3 = Integer.MAX_VALUE/3;
        int limit5 = Integer.MAX_VALUE/5;
        while(cnt < n){
            
            number = queue.poll();
            if (number < limit2 && set.add(number * 2)){
                queue.offer(number * 2);
            }
            if (number < limit3 && set.add(number * 3)){
                queue.offer(number * 3);
            }
            if (number < limit5 && set.add(number * 5)){
                queue.offer(number * 5);
            }
            cnt ++;
        }
        return number;
    }
    */

    public int nthUglyNumber(int n) {
       int[] list = new int[n];
        int a = 0, b = 0, c = 0;
        list[0] = 1;
        for(int i = 1; i<n; i++){
            int num = Math.min(list[a]*2, Math.min(list[b]*3, list[c]*5));
            list[i] = num;
            if(list[a]*2 == num) a++;
            if(list[b]*3 == num) b++;
            if(list[c]*5 == num) c++;
        }
        return list[n-1];    
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Unique_Paths.java
/*public class Solution {
    public int uniquePaths(int m, int n) {
        int[][] d = new int[m][n];
        int up = 0, left = 0;
        d[0][0] = 1;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                up = 0; 
                left = 0;
                if (i == 0 && j == 0){
                    continue;
                }
                if (i != 0){
                    up = d[i - 1][j];
                }
                if (j != 0){
                    left = d[i][j - 1];
                }
                d[i][j] = up + left;
            }
        }
        return d[m - 1][n - 1];
    }
}*/
public class Solution {
    public int uniquePaths(int m, int n) {
        if(m == 1 || n == 1)
            return 1;
        m--;
        n--;
        if(m < n) {              // Swap, so that m is the bigger number
            m = m + n;
            n = m - n;
            m = m - n;
        }
        long res = 1;
        int j = 1;
        for(int i = m+1; i <= m+n; i++, j++){       // Instead of taking factorial, keep on multiply & divide
            res *= i;
            res /= j;
        }
            
        return (int)res;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Unique_Paths_II.java
public class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int width = obstacleGrid[0].length;
        int height = obstacleGrid.length;
        int [][] d = new int [height][width];
        if(obstacleGrid[0][0] == 0 && obstacleGrid[height - 1][width - 1] != 1){
            d[0][0] = 1;
        }
        else {
            d[0][0] = 0;
        }
        
        for (int i = 0; i < height; i++){
            for (int j = 0; j < width; j++){
                int up = 0; 
                int left = 0;
                if (i == 0 && j == 0){
                    continue;
                }
                if (i != 0 && obstacleGrid[i - 1][j] != 1){
                    up = d[i - 1][j];
                }
                if (j != 0 && obstacleGrid[i][j - 1] != 1){
                    left = d[i][j - 1];
                }
                d[i][j] = up + left;
            }
        }
        return d[height - 1][width - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Validate_Binary_Search_Tree.java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {

        
        return isValidBSTHelp(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    public boolean isValidBSTHelp(TreeNode node, int lower, int upper) {
        if (node == null){
            return true;
        }
        if (node.val < lower || node.val > upper || (node.val == Integer.MIN_VALUE && node.left != null) || (node.val == Integer.MAX_VALUE && node.right != null)) {
            return false;
        }
        boolean left = isValidBSTHelp(node.left, lower, node.val - 1);
        boolean right = isValidBSTHelp(node.right, node.val + 1, upper);
        return left && right;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Valid_Anagram.java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] charSet = new int[26];
        for (int i = 0; i < s.length(); i++){
            charSet[s.charAt(i) - 'a'] ++;
        }
        for (char c: t.toCharArray()){
            charSet[c - 'a'] --;

        }
        for (int i: charSet){
            if (i != 0){
                return false;
            }
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Valid_Palindrome.java
public class Solution {
    public boolean isPalindrome(String s) {
        if (s == null || s.length() == 0){
            return true;
        }
        int ahead = 0;
        int reverse = s.length() - 1;
        char ca;
        char cr;
        while (ahead <= reverse){
            ca = s.charAt(ahead);
            cr = s.charAt(reverse);
            if (!Character.isLetterOrDigit(ca)){
                ahead ++;
                continue;
            }
            if (!Character.isLetterOrDigit(cr)){
                reverse --;
                continue;
            }
            if (Character.toLowerCase(ca) != Character.toLowerCase(cr)){
                return false;
            }
            ahead ++;
            reverse --;
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Valid_Parentheses.java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        HashMap<Character, Character> parenMap = new HashMap<>();
        parenMap.put('(',')');
        parenMap.put('[',']');
        parenMap.put('{','}');
        for (char c: s.toCharArray()){
            if (parenMap.containsKey(c)) {
                stack.push(c);
            }
            else {
                if (stack.size() == 0){
                    return false;
                }
                Character pairc = stack.pop();
                if (parenMap.get(pairc) != c){
                    return false;
                }
            }
        }
        if (stack.size() != 0){
            return false;
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Valid_Parenthesis_String.java
class Solution {
    public boolean checkValidString(String s) {
        int down = 0;
        int up = 0;
        for(char c: s.toCharArray()){
            if (c == '(') {
                down ++;
                up ++;
            }
            else if (c == ')') {
                if (down > 0) {
                    down --;
                }
                up --;
            }
            else {
                if (down > 0) {
                    down --;
                }
                up ++;
            }
            if (up < 0) {
                return false;
            }
        }
        return down == 0;
        
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Valid_Sudoku.java
public class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashSet[] horizontal = new HashSet[9];
        HashSet[] vertical = new HashSet[9];
        HashSet[][] cross = new HashSet[3][3];
        for (int i = 0; i < 9; i++) {
            horizontal[i] = new HashSet();
            for (int j = 0; j < 9; j++) {
                if (i == 0) {
                    vertical[j] = new HashSet();
                }
                if (cross[i / 3][j / 3] == null) {
                    cross[i / 3][j / 3] = new HashSet();
                }
                if (board[i][j] == '.') {
                    continue;
                }
                if (!horizontal[i].add(board[i][j]) || !vertical[j].add(board[i][j]) || !cross[i / 3][j / 3].add(board[i][j])) {
                    return false;
                }
            }
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Valid_Word_Square.java
class Solution {
    public boolean validWordSquare(List<String> words) {
        if (words.size() == 1) {
            return words.get(0).length() == 1;
        }
        for (int i = 1; i < words.size(); i++) {
            for (int j = 0; j < i; j++ ) {
                if (words.get(j).length() > words.size() || words.get(i).length() > words.size()) {
                    return false;
                }
                if (words.get(i).length() <= j) {
                    if (words.get(j).length() > i) {
                        
                        return false;
                    }
                }
                else{
                    if (words.get(j).length() <= i || words.get(i).charAt(j) != words.get(j).charAt(i)) {
                        return false;
                    }
                }

            }
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Walls_and_Gates.java
class Solution {
    public void wallsAndGates(int[][] rooms) {
        Queue<String> queue = new LinkedList<>();
        
        HashSet<String> visited = new HashSet<>();
        
        int level = 0;
        for (int i = 0; i < rooms.length; i++) {
            for (int j = 0; j < rooms[0].length; j++) {
                if (rooms[i][j] == 0) {
                    visited.add(i + " " + j);
                    queue.offer(i + " " + j);
                }
            }
        }
        while (queue.size() > 0) {
            int len = queue.size();
            while (len > 0) {
                String[] loc = queue.poll().split(" ");
                int x = Integer.parseInt(loc[0]);
                int y = Integer.parseInt(loc[1]);
                rooms[x][y] = Math.min(level, rooms[x][y]);
                if (x > 0 && rooms[x - 1][y] != 0 && rooms[x - 1][y] != -1 && !visited.contains(x - 1 + " " + y)) {
                    queue.offer(x - 1 + " " + y);
                    visited.add(x - 1 + " " + y);
                }
                if (y > 0 && rooms[x][y - 1] != 0 && rooms[x][y - 1] != -1 && !visited.contains(x + " " + (y - 1))) {
                    queue.offer(x + " " + (y - 1));
                    visited.add(x + " " + (y - 1));
                }
                if (x < rooms.length - 1 && rooms[x + 1][y] != 0 && rooms[x + 1][y] != -1 && !visited.contains(x + 1 + " " + y)) {
                    queue.offer(x + 1 + " " + y);
                    visited.add(x + 1 + " " + y);
                }
                if (y < rooms[0].length - 1 && rooms[x][y + 1] != 0 && rooms[x][y + 1] != -1 && !visited.contains(x + " " + (y + 1))) {
                    queue.offer(x + " " + (y + 1));
                    visited.add(x + " " + (y + 1));
                }
                len --;
            }
            level ++;           
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Wiggle_Sort.java
class Solution {
    public void wiggleSort(int[] nums) {
        boolean large = true;
        int temp = 0;
        for (int i = 0; i < nums.length - 1; i++){
            if (large){
                if (nums[i + 1] < nums[i]){
                    temp = nums[i];
                    nums[i] = nums[i + 1];
                    nums[i + 1] = temp;
                }
            }
            else{
                if (nums[i + 1] > nums[i]){
                    temp = nums[i];
                    nums[i] = nums[i + 1];
                    nums[i + 1] = temp;
                }
            }
            large = !large;
        }

    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Word_Break.java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> wordSet = new HashSet();
        for (String word: wordDict){
            wordSet.add(word);
        }
        boolean[] dp = new boolean[s.length()];
        for (int i = 0; i < s.length(); i++){
            if (wordSet.contains(s.substring(0,i+1))){
                dp[i] = true;
            }
            else{
                for (int j = 1; j < i + 1; j++){
                    dp[i] = dp[i - j] && wordSet.contains(s.substring(i-j+1,i+1));
                    if(dp[i] == true){
                        break;
                    }
                }
            }
        }
        return dp[s.length() - 1];
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Word_Break_II.java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());
    }       

    // DFS function returns an array including all substrings derived from s.
    List<String> DFS(String s, List<String> wordDict, HashMap<String, LinkedList<String>> map) {
        if (map.containsKey(s)) 
            return map.get(s);

        LinkedList<String>res = new LinkedList<String>();     
        if (s.length() == 0) {
            res.add("");
            return res;
        }               
        for (String word : wordDict) {
            if (s.startsWith(word)) {
                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);
                for (String sub : sublist) 
                    res.add(word + (sub.isEmpty() ? "" : " ") + sub);               
            }
        }       
        map.put(s, res);
        return res;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Word_Ladder.java
class Solution {
    
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        /*
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        int step = 1;
        HashSet<String> dict = new HashSet<>();
        Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();
        for (String s: wordList) {
            dict.add(s);
        }
        beginSet.add(beginWord);
	    endSet.add(endWord);
        while (!queue.isEmpty()) {
            int len = queue.size();
            while (len > 0) {
                String temp = queue.poll();
                if (temp.equals(endWord)) {
                    return step;
                }
                for (int i = 0; i < temp.length(); i++) {
                    for (char c = 'a'; c <= 'z'; c++){
                        String word = temp.substring(0,i) + c + temp.substring(i + 1);
                        if (dict.contains(word)) {
                            queue.offer(word);
                            dict.remove(word);
                        }
                    }
                }
                
                for (String s: wordList) {
                    if (visited.contains(s)) {
                        continue;
                    }
                    int cnt = 0;
                    for (int i = 0; i < s.length(); i++) {
                        if (s.charAt(i) == temp.charAt(i)){
                            cnt ++;
                        }
                    }
                    if (cnt == s.length() - 1) {
                        queue.offer(s);
                        visited.add(s);
                    }
                    
                }
                len --;
            }
            step ++;
        }
        return 0;
    */
        Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();
        if (!wordList.contains(endWord)) {
            return 0;
        }
        HashSet<String> dict = new HashSet<>();
        for (String s: wordList) {
            dict.add(s);
        }
        int len = 1;
        int strLen = beginWord.length();
        HashSet<String> visited = new HashSet<String>();

        beginSet.add(beginWord);
        endSet.add(endWord);
        while (!beginSet.isEmpty() && !endSet.isEmpty()) {
            if (beginSet.size() > endSet.size()) {
                Set<String> set = beginSet;
                beginSet = endSet;
                endSet = set;
            }

            Set<String> temp = new HashSet<String>();
            for (String word : beginSet) {
                char[] chs = word.toCharArray();

                for (int i = 0; i < chs.length; i++) {
                    for (char c = 'a'; c <= 'z'; c++) {
                        char old = chs[i];
                        chs[i] = c;
                        String target = String.valueOf(chs);

                        if (endSet.contains(target)) {
                            return len + 1;
                        }

                        if (!visited.contains(target) && dict.contains(target)) {
                            temp.add(target);
                            visited.add(target);
                        }
                        chs[i] = old;
                    }
                }
            }

            beginSet = temp;
            len++;
        }

        return 0;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Word_Pattern.java

public class Solution {
    public boolean wordPattern(String pattern, String str) {
        char[] patternArray = pattern.toCharArray();
        HashMap<Character,String> map = new HashMap<>();
        HashSet<String> set =  new HashSet<>();
        String[] strArray = str.split(" ");
        int index = 1;
        if(strArray.length != patternArray.length){
            return false;
        }
        map.put(patternArray[0],strArray[0]);
        set.add(strArray[0]);
        while (index < patternArray.length){
            String word = strArray[index];
            if (map.containsKey(patternArray[index])){
                if(!map.get(patternArray[index]).equals(word)){
                    return false;
                }
            }
            else{
                if (set.contains(word)){
                    return false;
                }
                map.put(patternArray[index],word);
                set.add(word);
            }
            index++;
        }
        return true;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\Word_Search.java
class Solution {
    public boolean exist(char[][] board, String word) {
        boolean result = false;
        char first = word.charAt(0);
        for (int i = 0; i < board.length; i++){
            for (int j = 0; j < board[0].length; j++){
                if (board[i][j] == first){
                    char[][] visited = new char[board.length][board[0].length];
                    visited[i][j] = 1;
                    String newWord = word.substring(1);
                    result = existHelper(board, i, j, visited, newWord);
                    if (result == true){
                        return result;
                    }
                }
            }
        }
        return result;
    }
    public boolean existHelper(char[][] board, int i, int j, char[][] visited, String word){
        //System.out.println(visited.toString());
        //System.out.println(word);
        boolean result = false;
        if (word.length() == 0){
            return true;
        }
        if (i > 0 && visited[i - 1][j] == 0 && word.charAt(0) == board[i - 1][j]){
            visited[i - 1][j] = 1;
            char temp = word.charAt(0);
            word = word.substring(1);
            result = existHelper(board, i - 1, j, visited, word);
            visited[i - 1][j] = 0;
            word = temp + word;
            if (result == true){
                return result;
            }
        }
        if (i < board.length - 1 && visited[i + 1][j] == 0 && word.charAt(0) == board[i + 1][j]){
            visited[i + 1][j] = 1;
            char temp = word.charAt(0);
            word = word.substring(1);
            result = existHelper(board, i + 1, j, visited, word);
            visited[i + 1][j] = 0;
            word = temp + word;
            if (result == true){
                return result;
            }
        }
        if (j > 0 && visited[i][j - 1] == 0 && word.charAt(0) == board[i][j - 1]){
            //System.out.println("b");
            visited[i][j - 1] = 1;
            //System.out.println(visited.toString());
            char temp = word.charAt(0);
            word = word.substring(1);
            result = existHelper(board, i, j - 1, visited, word);
            visited[i][j - 1] = 0;
            word = temp + word;
            if (result == true){
                return result;
            }
        }
        if (j < board[0].length - 1 && visited[i][j + 1] == 0 && word.charAt(0) == board[i][j + 1]){
            //System.out.println("a");
            visited[i][j + 1] = 1;
            char temp = word.charAt(0);
            word = word.substring(1);
            result = existHelper(board, i, j + 1, visited, word);
            visited[i][j + 1] = 0;
            word = temp + word;
            if (result == true){
                return result;
            }
        }
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\leetcode-solution\code\ZigZag_Conversion.java
class Solution {
    public String convert(String s, int nRows) {
        char[] c = s.toCharArray();
        int len = c.length;
        StringBuffer[] sb = new StringBuffer[nRows];
        for (int i = 0; i < sb.length; i++) sb[i] = new StringBuffer();

        int i = 0;
        while (i < len) {
            for (int idx = 0; idx < nRows && i < len; idx++) // vertically down
                sb[idx].append(c[i++]);
            for (int idx = nRows-2; idx >= 1 && i < len; idx--) // obliquely up
                sb[idx].append(c[i++]);
        }
        for (int idx = 1; idx < sb.length; idx++)
            sb[0].append(sb[idx]);
        return sb[0].toString();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\leetcode-github\requirements.txt
requests
grequests
gevent
