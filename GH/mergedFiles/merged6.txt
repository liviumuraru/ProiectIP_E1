C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\Dao.java
package com.ccsu.crawler.dao;

import java.util.Map;

public interface Dao<T> {

    int insert(T entity);

    T select(Map map);

    int update(Map map);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\BranchDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Branch;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;

public class BranchDao implements Dao<Branch> {

    private Connection connection;

    public int insert(Branch branch){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_branch(repositoryId,branchName) values (?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1,branch.getRepositoryid());
            ps.setString(2,branch.getBranchname());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Branch select(Map map) {
        return null;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\ContributorDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Contributor;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;

public class ContributorDao implements Dao<Contributor> {

    private Connection connection;

    public int insert(Contributor contributor){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_contributor(repositoryId,contributor,contributions) values (?,?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1,contributor.getRepositoryid());
            ps.setString(2,contributor.getContributor());
            ps.setInt(3,contributor.getContributions());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Contributor select(Map map) {
        return null;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\DeveloperDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Developer;

import java.sql.*;
import java.util.Map;

import com.ccsu.crawler.utils.MysqlConnect;

public class DeveloperDao implements Dao<Developer> {

    private Connection connection;

    @Override
    public int insert(Developer developer){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_developer " +
                    "(id,login,avatar_url,name,company,location,blog,email,bio,type,public_repos," +
                    "followers, following,created_at,updated_at) " +
                    "values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1,developer.getId());
            ps.setString(2,developer.getLogin());
            ps.setString(3,developer.getAvatarUrl());
            ps.setString(4,developer.getName());
            ps.setString(5,developer.getCompany());
            ps.setString(6,developer.getLocation());
            ps.setString(7,developer.getBlog());
            ps.setString(8,developer.getEmail());
            ps.setString(9,developer.getBio());
            ps.setString(10,developer.getType());
            ps.setInt(11,developer.getPublicRepos() == null?0:developer.getPublicRepos());
            ps.setInt(12,developer.getFollowers() == null?0:developer.getFollowers());
            ps.setInt(13,developer.getFollowing() == null?0:developer.getFollowing());
            ps.setTimestamp(14,new Timestamp(developer.getCreatedAt() ==  null?0:developer.getCreatedAt().getTime()));
            ps.setTimestamp(15,new Timestamp(developer.getUpdatedAt() ==  null?0:developer.getUpdatedAt().getTime()));
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Developer select(Map map) {
        Long id = (Long) map.get("id");
        ResultSet rs;
        Developer developer = null;
        try {
            connection = MysqlConnect.getConnect();
            String SELECT_SQL = "select * from tb_developer where id = ?";
            PreparedStatement ps = connection.prepareStatement(SELECT_SQL);
            ps.setLong(1,id);
            rs = ps.executeQuery();
            while (rs.next()){
                developer = new Developer();
                developer.setId(rs.getLong(1));
                developer.setLogin(rs.getString(2));
                developer.setAvatarUrl(rs.getString(3));
                developer.setName(rs.getString(4));
                developer.setCompany(rs.getString(5));
                developer.setLocation(rs.getString(6));
                developer.setBlog(rs.getString(7));
                developer.setEmail(rs.getString(8));
                developer.setBio(rs.getString(9));
                developer.setType(rs.getString(10));
                developer.setPublicRepos(rs.getInt(11));
                developer.setFollowers(rs.getInt(12));
                developer.setFollowing(rs.getInt(13));
                developer.setCreatedAt(rs.getDate(14));
                developer.setUpdatedAt(rs.getDate(15));
                developer.setUpdated(rs.getDate(16));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return developer;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\FollowDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Follow;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;

public class FollowDao implements Dao<Follow> {

    private Connection connection;

    @Override
    public int insert(Follow follow){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_follow(followers,following) values (?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setString(1,follow.getFollowers());
            ps.setString(2,follow.getFollowing());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Follow select(Map map){
        String followers = (String)map.get("followers");
        String following = (String)map.get("following");
        Follow follow = null;
        ResultSet rs;
        try {
            connection = MysqlConnect.getConnect();
            String SELECTDUPLICATE_SQL = "select * from tb_follow where followers = ? and following = ?";
            PreparedStatement ps = connection.prepareStatement(SELECTDUPLICATE_SQL);
            ps.setString(1,followers);
            ps.setString(2,following);
            rs = ps.executeQuery();
            while (rs.next()){
                follow = new Follow();
                follow.setId(rs.getInt(1));
                follow.setFollowers(rs.getString(2));
                follow.setFollowing(rs.getString(3));
                follow.setUpdated(rs.getDate(4));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return follow;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\ForkDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Fork;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;

public class ForkDao implements Dao<Fork> {

    private Connection connection;

    @Override
    public int insert(Fork fork){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_fork(repositoryId,forkLogin) values (?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1,fork.getRepositoryid());
            ps.setString(2,fork.getForklogin());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Fork select(Map map) {
        return null;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\LanguageDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Language;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;

public class LanguageDao implements Dao<Language> {

    private Connection connection;

    public int insert(Language language){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_language(repositoryId,language,size) values (?,?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1,language.getRepositoryid());
            ps.setString(2,language.getLanguage());
            ps.setInt(3,language.getSize());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Language select(Map map) {
        return null;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\RepositoryDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Repository;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.*;
import java.util.Map;

public class RepositoryDao implements Dao<Repository> {

    private Connection connection;

    public int insert(Repository repository) {
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_repository" +
                    "(id,name,full_name,description,default_branch,created_at,updated_at,pushed_at,size," +
                    "star_count,watchers_count,forks_count,language,developerLogin)" +
                    "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?);";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1, repository.getId());
            ps.setString(2, repository.getName());
            ps.setString(3, repository.getFullName());
            ps.setString(4, repository.getDescription());
            ps.setString(5, repository.getDefaultBranch());
            ps.setTimestamp(6, new Timestamp(repository.getCreatedAt() == null ? 0 : repository.getCreatedAt().getTime()));
            ps.setTimestamp(7, new Timestamp(repository.getUpdatedAt() == null ? 0 : repository.getUpdatedAt().getTime()));
            ps.setTimestamp(8, new Timestamp(repository.getPushedAt() == null ? 0 : repository.getPushedAt().getTime()));
            ps.setInt(9, repository.getSize());
            ps.setInt(10, repository.getStarCount());
            ps.setInt(11, repository.getWatchersCount());
            ps.setInt(12, repository.getForksCount());
            ps.setString(13, repository.getLanguage());
            ps.setString(14, repository.getDeveloperLogin());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Repository select(Map map) {
        ResultSet rs;
        Repository repository = null;
        Long id = (Long)map.get("id");
        try {
            connection = MysqlConnect.getConnect();
            //noinspection SqlDialectInspection
            String SELECT_SQL = "select * from tb_repository where id = ?";
            PreparedStatement ps = connection.prepareStatement(SELECT_SQL);
            ps.setLong(1, id);
            rs = ps.executeQuery();
            while (rs.next()) {
                repository = new Repository();
                repository.setId(rs.getLong(1));
                repository.setName(rs.getString(2));
                repository.setFullName(rs.getString(3));
                repository.setDescription(rs.getString(4));
                repository.setDefaultBranch(rs.getString(5));
                repository.setCreatedAt(rs.getDate(6));
                repository.setUpdatedAt(rs.getDate(7));
                repository.setPushedAt(rs.getDate(8));
                repository.setSize(rs.getInt(9));
                repository.setStarCount(rs.getInt(10));
                repository.setWatchersCount(rs.getInt(11));
                repository.setForksCount(rs.getInt(12));
                repository.setLanguage(rs.getString(13));
                repository.setDeveloperLogin(rs.getString(14));
                repository.setUpdated(rs.getDate(15));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return repository;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\SeedDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Seed;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;

public class SeedDao implements Dao<Seed>{

    private Connection connection;

    @Override
    public int insert(Seed seed){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_seed(seedLogin,state) values (?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setString(1,seed.getSeedlogin());
            ps.setInt(2,seed.getState());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Seed select(Map map) {
        String login = (String)map.get("login");
        ResultSet rs;
        Seed seed = null;
        try {
            connection = MysqlConnect.getConnect();
            String SELECTBYLOGIN_SQL = "select * from tb_seed where seedLogin = ? and state = 1";
            PreparedStatement ps = connection.prepareStatement(SELECTBYLOGIN_SQL);
            ps.setString(1,login);
            rs = ps.executeQuery();
            while (rs.next()){
                seed = new Seed();
                seed.setId(rs.getInt(1));
                seed.setSeedlogin(rs.getString(2));
                seed.setState(rs.getInt(3));
                seed.setUpdated(rs.getDate(4));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return seed;
    }

    @Override
    public int update(Map map) {
        int count = 0;
        int id = (int)map.get("id");
        try {
            connection = MysqlConnect.getConnect();
            String UPDATE_SQL = "UPDATE tb_seed set state = 0 where id = ?";
            PreparedStatement ps = connection.prepareStatement(UPDATE_SQL);
            ps.setInt(1,id);
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    public static Seed select(){
        ResultSet rs;
        Seed seed = null;
        Connection connection = null;
        try {
            connection = MysqlConnect.getConnect();
            String SELECT_SQL = "select * from tb_seed where state = 1 limit 0,1";
            PreparedStatement ps = connection.prepareStatement(SELECT_SQL);
            rs = ps.executeQuery();
            while (rs.next()){
                seed = new Seed();
                seed.setId(rs.getInt(1));
                seed.setSeedlogin(rs.getString(2));
                seed.setState(rs.getInt(3));
                seed.setUpdated(rs.getDate(4));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return seed;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\dao\daoImpl\StarDao.java
package com.ccsu.crawler.dao.daoImpl;

import com.ccsu.crawler.dao.Dao;
import com.ccsu.crawler.model.Star;
import com.ccsu.crawler.utils.MysqlConnect;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;

public class StarDao implements Dao<Star> {

    private Connection connection;

    public int insert(Star star){
        int count = 0;
        try {
            connection = MysqlConnect.getConnect();
            String INSERT_SQL = "insert into tb_star(repositoryId,starLogin) values (?,?)";
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL);
            ps.setLong(1,star.getRepositoryid());
            ps.setString(2,star.getStarlogin());
            count = ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    @Override
    public Star select(Map map) {
        return null;
    }

    @Override
    public int update(Map map) {
        return 0;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\MainApplication.java
package com.ccsu.crawler;

import com.ccsu.crawler.model.*;
import com.ccsu.crawler.utils.DBUtil;
import com.ccsu.crawler.utils.GetData;
import org.apache.log4j.Logger;

import java.lang.reflect.Field;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MainApplication {

    private static Logger logger = Logger.getLogger(MainApplication.class);

    public static void main(String args[]) throws Exception {
        while (true) {
            start();
            logger.info("====================Line====================");
        }
    }

    private static void start() throws Exception {
        String login = getSeed();
        if (login.isEmpty()) {
            try {
                logger.info("种子为空,请添加种子后重试,5分钟后继续执行代码");
                Thread.sleep(1000 * 60 * 5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            //开始爬取数据
            crawling(login);
        }
    }

    /**
     *  爬取数据逻辑
     * @param login
     */
    private static void crawling(String login) throws Exception {

        List<Developer> developerList = GetData.getDeveloperData(login);
        //判断该用户名是否存在，不存在就返回
        if(developerList == null || developerList.isEmpty()){
            return;
        }
        List<Repository> repositoryList = GetData.getAllRepositoryData(login);
        //判断该开发者是否存在开源项目仓库
        if(repositoryList == null || repositoryList.isEmpty()){
            return;
        }
        int count = 0;
        for(Repository repository : repositoryList){
            List<Repository> repositoryData = GetData.getRepositoryData(repository.getFullName());
            if(repositoryData == null || repositoryData.isEmpty()){
                continue;
            }
            if(validate(repositoryData.get(0))){
                Map<String,Object> map = repositoryConvertToMap(repositoryData.get(0));
                count += DBUtil.insert("tb_repository", map);
                List<Branch> branchList = GetData.getBranchData(repositoryData.get(0));
                for(Branch branch : branchList){
                    Map<String,Object> branchMap = new HashMap<>();
                    branchMap.put("repositoryId",repositoryData.get(0).getId());
                    branchMap.put("branchName",branch.getBranchname());
                    DBUtil.insert("tb_branch", branchMap);
                }
                List<Contributor> contributorList = GetData.getContributorData(repositoryData.get(0));
                for(Contributor contributor : contributorList){
                    Map<String,Object> contributorMap = new HashMap<>();
                    contributorMap.put("repositoryId",repositoryData.get(0).getId());
                    contributorMap.put("contributor",contributor.getContributor());
                    contributorMap.put("contributions",contributor.getContributions());
                    DBUtil.insert("tb_contributor", contributorMap);
                }
                List<Fork> forkList = GetData.getForkData(repositoryData.get(0));
                for(Fork fork : forkList){
                    addSeed(fork.getForklogin());
                    Map<String,Object> forkMap = new HashMap<>();
                    forkMap.put("repositoryId",repositoryData.get(0).getId());
                    forkMap.put("forkLogin",fork.getForklogin());
                    DBUtil.insert("tb_fork", forkMap);
                }
                List<Language> languageList = GetData.getLanguageData(repositoryData.get(0));
                for(Language language : languageList){
                    Map<String,Object> languageMap = new HashMap<>();
                    languageMap.put("repositoryId",repositoryData.get(0).getId());
                    languageMap.put("language",language.getLanguage());
                    languageMap.put("size",language.getSize());
                    DBUtil.insert("tb_language", languageMap);
                }
                List<Star> starList = GetData.getStarData(repositoryData.get(0));
                for(Star star : starList){
                    addSeed(star.getStarlogin());
                    Map<String,Object> starMap = new HashMap<>();
                    starMap.put("repositoryId",repositoryData.get(0).getId());
                    starMap.put("starLogin",star.getStarlogin());
                    DBUtil.insert("tb_star", starMap);
                }
            }
        }
        if(count > 0){
            Map<String,Object> map = developerConvertToMap(developerList.get(0));
            DBUtil.insert("tb_developer",map);
            List<Developer> followersList = GetData.getfollowData(login, "followers");
            for(Developer developer : followersList){
                addSeed(developer.getLogin());
                Map<String,Object> mapFollowers = new HashMap<>();
                mapFollowers.put("followers",developer.getLogin());
                mapFollowers.put("following",login);
                DBUtil.insert("tb_follow",mapFollowers);
            }
            List<Developer> followingList = GetData.getfollowData(login, "following");
            for(Developer developer : followingList){
                addSeed(developer.getLogin());
                Map<String,Object> mapFollowing = new HashMap<>();
                mapFollowing.put("followers",login);
                mapFollowing.put("following",developer.getLogin());
                DBUtil.insert("tb_follow",mapFollowing);
            }
        }
    }

    /**
     * 把当前获取的username存到seed表
     * @param login
     */
    public static void addSeed(String login) throws SQLException {
        Map<String,Object> mapSeed = new HashMap<>();
        mapSeed.put("seedLogin",login);
        mapSeed.put("state",1);
        DBUtil.insert("tb_seed",mapSeed);
    }

    /**
     * 从数据库seed表获取种子username
     * @return String
     */
    private static String getSeed() throws SQLException {
        String sql = "select * from tb_seed where state = 1 limit 0,1";
        List<Map<String, Object>> mapList = DBUtil.query(sql);
        Map<String, Object> valueMap = new HashMap<>();
        valueMap.put("state",0);
        Map<String, Object> whereMap = new HashMap<>();
        whereMap.put("id",mapList.get(0).get("id"));
        DBUtil.update("tb_seed",valueMap,whereMap);
        return (String)mapList.get(0).get("seedLogin");
    }

    /**
     *  项目的筛选条件
     * @param repository
     */
    private static boolean validate(Repository repository){
        if(repository.getPushedAt().getTime() > (System.currentTimeMillis() - 1000 * 60 * 60 * 24 * 7)){
            if(repository.getStarCount() > 2000){
                return true;
            }
        }
        return false;
    }

    private static Map<String, Object> convertToMap(Object obj)
            throws Exception {

        Map<String, Object> map = new HashMap<String, Object>();
        Field[] fields = obj.getClass().getDeclaredFields();
        for (int i = 0, len = fields.length; i < len; i++) {
            String varName = fields[i].getName();
            boolean accessFlag = fields[i].isAccessible();
            fields[i].setAccessible(true);

            Object o = fields[i].get(obj);
            if (o != null)
                map.put(varName, o.toString());

            fields[i].setAccessible(accessFlag);
        }

        return map;
    }

    private static Map<String, Object> repositoryConvertToMap(Repository repository){
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("developerLogin",repository.getDeveloperLogin());
        map.put("default_branch",repository.getDefaultBranch());
        map.put("full_name",repository.getFullName());
        map.put("description",repository.getDescription());
        map.put("language",repository.getLanguage());
        map.put("pushed_at",repository.getPushedAt());
        map.put("forks_count",repository.getForksCount());
        map.put("created_at",repository.getCreatedAt());
        map.put("star_count",repository.getStarCount());
        map.put("watchers_count",repository.getWatchersCount());
        map.put("size",repository.getSize());
        map.put("name",repository.getName());
        map.put("id",repository.getId());
        map.put("updated",repository.getUpdated());
        map.put("updated_at",repository.getUpdatedAt());
        return map;
    }

    private static Map<String, Object> developerConvertToMap(Developer developer){
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("avatar_url",developer.getAvatarUrl());
        map.put("login",developer.getLogin());
        map.put("company",developer.getCompany());
        map.put("location",developer.getLocation());
        map.put("blog",developer.getBlog());
        map.put("email",developer.getEmail());
        map.put("bio",developer.getBio());
        map.put("created_at",developer.getCreatedAt());
        map.put("type",developer.getType());
        map.put("followers",developer.getFollowers());
        map.put("following",developer.getFollowing());
        map.put("name",developer.getName());
        map.put("id",developer.getId());
        map.put("updated",developer.getUpdated());
        map.put("updated_at",developer.getUpdatedAt());
        map.put("public_repos",developer.getPublicRepos());
        return map;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Branch.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Branch {
    private Integer id;

    private Long repositoryid;

    private String branchname;

    private Date updated;

    public Branch(Integer id, Long repositoryid, String branchname, Date updated) {
        this.id = id;
        this.repositoryid = repositoryid;
        this.branchname = branchname;
        this.updated = updated;
    }

    public Branch() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Long getRepositoryid() {
        return repositoryid;
    }

    public void setRepositoryid(Long repositoryid) {
        this.repositoryid = repositoryid;
    }

    public String getBranchname() {
        return branchname;
    }

    public void setBranchname(String branchname) {
        this.branchname = branchname == null ? null : branchname.trim();
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Contributor.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Contributor {
    private Integer id;

    private Long repositoryid;

    private String contributor;

    private Integer contributions;

    private Date updated;

    public Contributor(Integer id, Long repositoryid, String contributor, Integer contributions, Date updated) {
        this.id = id;
        this.repositoryid = repositoryid;
        this.contributor = contributor;
        this.contributions = contributions;
        this.updated = updated;
    }

    public Contributor() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Long getRepositoryid() {
        return repositoryid;
    }

    public void setRepositoryid(Long repositoryid) {
        this.repositoryid = repositoryid;
    }

    public String getContributor() {
        return contributor;
    }

    public void setContributor(String contributor) {
        this.contributor = contributor == null ? null : contributor.trim();
    }

    public Integer getContributions() {
        return contributions;
    }

    public void setContributions(Integer contributions) {
        this.contributions = contributions;
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Developer.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Developer {
    private Long id;

    private String login;

    private String avatarUrl;

    private String name;

    private String company;

    private String location;

    private String blog;

    private String email;

    private String bio;

    private String type;

    private Integer publicRepos;

    private Integer followers;

    private Integer following;

    private Date createdAt;

    private Date updatedAt;

    private Date updated;

    public Developer() {
        super();
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login == null ? null : login.trim();
    }

    public String getAvatarUrl() {
        return avatarUrl;
    }

    public void setAvatarUrl(String avatarUrl) {
        this.avatarUrl = avatarUrl == null ? null : avatarUrl.trim();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name == null ? null : name.trim();
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company == null ? null : company.trim();
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location == null ? null : location.trim();
    }

    public String getBlog() {
        return blog;
    }

    public void setBlog(String blog) {
        this.blog = blog == null ? null : blog.trim();
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email == null ? null : email.trim();
    }

    public String getBio() {
        return bio;
    }

    public void setBio(String bio) {
        this.bio = bio == null ? null : bio.trim();
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type == null ? null : type.trim();
    }

    public Integer getPublicRepos() {
        return publicRepos;
    }

    public void setPublicRepos(Integer publicRepos) {
        this.publicRepos = publicRepos;
    }

    public Integer getFollowers() {
        return followers;
    }

    public void setFollowers(Integer followers) {
        this.followers = followers;
    }

    public Integer getFollowing() {
        return following;
    }

    public void setFollowing(Integer following) {
        this.following = following;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Follow.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Follow {
    private Integer id;

    private String followers;

    private String following;

    private Date updated;

    public Follow(Integer id, String followers, String following, Date updated) {
        this.id = id;
        this.followers = followers;
        this.following = following;
        this.updated = updated;
    }

    public Follow() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getFollowers() {
        return followers;
    }

    public void setFollowers(String followers) {
        this.followers = followers == null ? null : followers.trim();
    }

    public String getFollowing() {
        return following;
    }

    public void setFollowing(String following) {
        this.following = following == null ? null : following.trim();
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Fork.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Fork {
    private Integer id;

    private Long repositoryid;

    private String forklogin;

    private Date updated;

    public Fork(Integer id, Long repositoryid, String forklogin, Date updated) {
        this.id = id;
        this.repositoryid = repositoryid;
        this.forklogin = forklogin;
        this.updated = updated;
    }

    public Fork() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Long getRepositoryid() {
        return repositoryid;
    }

    public void setRepositoryid(Long repositoryid) {
        this.repositoryid = repositoryid;
    }

    public String getForklogin() {
        return forklogin;
    }

    public void setForklogin(String forklogin) {
        this.forklogin = forklogin == null ? null : forklogin.trim();
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Language.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Language {
    private Integer id;

    private Long repositoryid;

    private String language;

    private Integer size;

    private Date updated;

    public Language(Integer id, Long repositoryid, String language, Integer size, Date updated) {
        this.id = id;
        this.repositoryid = repositoryid;
        this.language = language;
        this.size = size;
        this.updated = updated;
    }

    public Language() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Long getRepositoryid() {
        return repositoryid;
    }

    public void setRepositoryid(Long repositoryid) {
        this.repositoryid = repositoryid;
    }

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language == null ? null : language.trim();
    }

    public Integer getSize() {
        return size;
    }

    public void setSize(Integer size) {
        this.size = size;
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Repository.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Repository {
    private Long id;

    private String name;

    private String fullName;

    private String description;

    private String defaultBranch;

    private Date createdAt;

    private Date updatedAt;

    private Date pushedAt;

    private Integer size;

    private Integer starCount;

    private Integer watchersCount;

    private Integer forksCount;

    private String language;

    private String developerLogin;

    private Date updated;

    public Repository() {
        super();
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name == null ? null : name.trim();
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName == null ? null : fullName.trim();
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description == null ? null : description.trim();
    }

    public String getDefaultBranch() {
        return defaultBranch;
    }

    public void setDefaultBranch(String defaultBranch) {
        this.defaultBranch = defaultBranch == null ? null : defaultBranch.trim();
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Date getPushedAt() {
        return pushedAt;
    }

    public void setPushedAt(Date pushedAt) {
        this.pushedAt = pushedAt;
    }

    public Integer getSize() {
        return size;
    }

    public void setSize(Integer size) {
        this.size = size;
    }

    public Integer getStarCount() {
        return starCount;
    }

    public void setStarCount(Integer starCount) {
        this.starCount = starCount;
    }

    public Integer getWatchersCount() {
        return watchersCount;
    }

    public void setWatchersCount(Integer watchersCount) {
        this.watchersCount = watchersCount;
    }

    public Integer getForksCount() {
        return forksCount;
    }

    public void setForksCount(Integer forksCount) {
        this.forksCount = forksCount;
    }

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language == null ? null : language.trim();
    }

    public String getDeveloperLogin() {
        return developerLogin;
    }

    public void setDeveloperLogin(String developerLogin) {
        this.developerLogin = developerLogin;
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Seed.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Seed {
    private Integer id;

    private String seedlogin;

    private Integer state;

    private Date updated;

    public Seed(Integer id, String seedlogin, Integer state, Date updated) {
        this.id = id;
        this.seedlogin = seedlogin;
        this.state = state;
        this.updated = updated;
    }

    public Seed() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getSeedlogin() {
        return seedlogin;
    }

    public void setSeedlogin(String seedlogin) {
        this.seedlogin = seedlogin == null ? null : seedlogin.trim();
    }

    public Integer getState() {
        return state;
    }

    public void setState(Integer state) {
        this.state = state;
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\model\Star.java
package com.ccsu.crawler.model;

import java.util.Date;

public class Star {
    private Integer id;

    private Long repositoryid;

    private String starlogin;

    private Date updated;

    public Star(Integer id, Long repositoryid, String starlogin, Date updated) {
        this.id = id;
        this.repositoryid = repositoryid;
        this.starlogin = starlogin;
        this.updated = updated;
    }

    public Star() {
        super();
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Long getRepositoryid() {
        return repositoryid;
    }

    public void setRepositoryid(Long repositoryid) {
        this.repositoryid = repositoryid;
    }

    public String getStarlogin() {
        return starlogin;
    }

    public void setStarlogin(String starlogin) {
        this.starlogin = starlogin == null ? null : starlogin.trim();
    }

    public Date getUpdated() {
        return updated;
    }

    public void setUpdated(Date updated) {
        this.updated = updated;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\DBConnectionPool.java
package com.ccsu.crawler.utils;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import com.mchange.v2.c3p0.DataSources;

import java.beans.PropertyVetoException;
import java.sql.Connection;
import java.sql.SQLException;

/**
 * 数据库连接池对象，单例
 */
public class DBConnectionPool {

    private static volatile DBConnectionPool dbConnection;
    private ComboPooledDataSource cpds;

    /**
     * 在构造函数初始化的时候获取数据库连接
     */
    private DBConnectionPool() {
        try {
            /**数据库连接池对象**/
            cpds = new ComboPooledDataSource();

            /**设置数据库连接驱动**/
            String driverClassName = "com.mysql.jdbc.Driver";
            cpds.setDriverClass(driverClassName);
            /**设置数据库连接地址**/
            String url = "jdbc:mysql://localhost:3306/github?useUnicode=true&characterEncoding=utf-8";
            cpds.setJdbcUrl(url);
            /**设置数据库连接用户名**/
            String username = "root";
            cpds.setUser(username);
            /**设置数据库连接密码**/
            String password = "root123456";
            cpds.setPassword(password);

            /**初始化时创建的连接数,应在minPoolSize与maxPoolSize之间取值.默认为3**/
            cpds.setInitialPoolSize(3);
            /**连接池中保留的最大连接数据.默认为15**/
            cpds.setMaxPoolSize(10);
            /**当连接池中的连接用完时，C3PO一次性创建新的连接数目;**/
            cpds.setAcquireIncrement(1);
            /**隔多少秒检查所有连接池中的空闲连接,默认为0表示不检查;**/
            cpds.setIdleConnectionTestPeriod(60);
            /**最大空闲时间,超过空闲时间的连接将被丢弃.为0或负数据则永不丢弃.默认为0;**/
            cpds.setMaxIdleTime(3000);

            /**因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的
             时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable
             等方法来提升连接测试的性能。Default: false**/
            cpds.setTestConnectionOnCheckout(true);

            /**如果设为true那么在取得连接的同时将校验连接的有效性。Default: false **/
            cpds.setTestConnectionOnCheckin(true);
            /**定义在从数据库获取新的连接失败后重复尝试获取的次数，默认为30;**/
            cpds.setAcquireRetryAttempts(30);
            /**两次连接中间隔时间默认为1000毫秒**/
            cpds.setAcquireRetryDelay(1000);
            /** 获取连接失败将会引起所有等待获取连接的线程异常,
             但是数据源仍有效的保留,并在下次调用getConnection()的时候继续尝试获取连接.如果设为true,
             那么尝试获取连接失败后该数据源将申明已经断开并永久关闭.默认为false**/
            cpds.setBreakAfterAcquireFailure(true);
        } catch (PropertyVetoException e) {
            e.printStackTrace();
        }

    }

    /**
     * 获取数据库连接对象，单例
     *
     * @return
     */
    public static DBConnectionPool getInstance() {
        if (dbConnection == null) {
            synchronized (DBConnectionPool.class) {
                if (dbConnection == null) {
                    dbConnection = new DBConnectionPool();
                }
            }
        }
        return dbConnection;
    }

    /**
     * 获取数据库连接
     *
     * @return 数据库连接
     */
    public final synchronized Connection getConnection() throws SQLException {
        return cpds.getConnection();
    }

    /**
     * finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。
     *
     * @throws Throwable
     */
    protected void finalize() throws Throwable {
        DataSources.destroy(cpds);
        super.finalize();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\DBUtil.java
package com.ccsu.crawler.utils;

import com.sun.istack.internal.Nullable;

import java.sql.*;
import java.util.*;
import java.util.regex.Pattern;

/**
 * 数据库JDBC连接工具类
 */
public class DBUtil {

    /**
     * 执行数据库插入操作
     *
     * @param valueMap  插入数据表中key为列名和value为列对应的值的Map对象
     * @param tableName 要插入的数据库的表名
     * @return 影响的行数
     * @throws SQLException SQL异常
     */
    public static int insert(String tableName, Map<String, Object> valueMap) throws SQLException {

        /**获取数据库插入的Map的键值对的值**/
        Set<String> keySet = valueMap.keySet();
        Iterator<String> iterator = keySet.iterator();
        /**要插入的字段sql，其实就是用key拼起来的**/
        StringBuilder columnSql = new StringBuilder();
        /**要插入的字段值，其实就是？**/
        StringBuilder unknownMarkSql = new StringBuilder();
        Object[] bindArgs = new Object[valueMap.size()];
        int i = 0;
        while (iterator.hasNext()) {
            String key = iterator.next();
            columnSql.append(i == 0 ? "" : ",");
            columnSql.append(key);

            unknownMarkSql.append(i == 0 ? "" : ",");
            unknownMarkSql.append("?");
            bindArgs[i] = valueMap.get(key);
            i++;
        }
        /**开始拼插入的sql语句**/
        StringBuilder sql = new StringBuilder();
        sql.append("INSERT INTO ");
        sql.append(tableName);
        sql.append(" (");
        sql.append(columnSql);
        sql.append(" )  VALUES (");
        sql.append(unknownMarkSql);
        sql.append(" )");
        return executeUpdate(sql.toString(), bindArgs);
    }

    /**
     * 执行数据库插入操作
     *
     * @param datas     插入数据表中key为列名和value为列对应的值的Map对象的List集合
     * @param tableName 要插入的数据库的表名
     * @return 影响的行数
     * @throws SQLException SQL异常
     */
    public static int insertAll(String tableName, List<Map<String, Object>> datas) throws SQLException {
        /**影响的行数**/
        int affectRowCount = -1;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        try {
            /**从数据库连接池中获取数据库连接**/
            connection = DBConnectionPool.getInstance().getConnection();


            Map<String, Object> valueMap = datas.get(0);
            /**获取数据库插入的Map的键值对的值**/
            Set<String> keySet = valueMap.keySet();
            Iterator<String> iterator = keySet.iterator();
            /**要插入的字段sql，其实就是用key拼起来的**/
            StringBuilder columnSql = new StringBuilder();
            /**要插入的字段值，其实就是？**/
            StringBuilder unknownMarkSql = new StringBuilder();
            Object[] keys = new Object[valueMap.size()];
            int i = 0;
            while (iterator.hasNext()) {
                String key = iterator.next();
                keys[i] = key;
                columnSql.append(i == 0 ? "" : ",");
                columnSql.append(key);

                unknownMarkSql.append(i == 0 ? "" : ",");
                unknownMarkSql.append("?");
                i++;
            }
            /**开始拼插入的sql语句**/
            StringBuilder sql = new StringBuilder();
            sql.append("INSERT INTO ");
            sql.append(tableName);
            sql.append(" (");
            sql.append(columnSql);
            sql.append(" )  VALUES (");
            sql.append(unknownMarkSql);
            sql.append(" )");

            /**执行SQL预编译**/
            preparedStatement = connection.prepareStatement(sql.toString());
            /**设置不自动提交，以便于在出现异常的时候数据库回滚**/
            connection.setAutoCommit(false);
            System.out.println(sql.toString());
            for (int j = 0; j < datas.size(); j++) {
                for (int k = 0; k < keys.length; k++) {
                    preparedStatement.setObject(k + 1, datas.get(j).get(keys[k]));
                }
                preparedStatement.addBatch();
            }
            int[] arr = preparedStatement.executeBatch();
            connection.commit();
            affectRowCount = arr.length;
            System.out.println("成功了插入了" + affectRowCount + "行");
            System.out.println();
        } catch (Exception e) {
            if (connection != null) {
                connection.rollback();
            }
            e.printStackTrace();
            throw e;
        } finally {
            if (preparedStatement != null) {
                preparedStatement.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        return affectRowCount;
    }

    /**
     * 执行更新操作
     *
     * @param tableName 表名
     * @param valueMap  要更改的值
     * @param whereMap  条件
     * @return 影响的行数
     * @throws SQLException SQL异常
     */
    public static int update(String tableName, Map<String, Object> valueMap, Map<String, Object> whereMap) throws SQLException {
        /**获取数据库插入的Map的键值对的值**/
        Set<String> keySet = valueMap.keySet();
        Iterator<String> iterator = keySet.iterator();
        /**开始拼插入的sql语句**/
        StringBuilder sql = new StringBuilder();
        sql.append("UPDATE ");
        sql.append(tableName);
        sql.append(" SET ");

        /**要更改的的字段sql，其实就是用key拼起来的**/
        StringBuilder columnSql = new StringBuilder();
        int i = 0;
        List<Object> objects = new ArrayList<>();
        while (iterator.hasNext()) {
            String key = iterator.next();
            columnSql.append(i == 0 ? "" : ",");
            columnSql.append(key + " = ? ");
            objects.add(valueMap.get(key));
            i++;
        }
        sql.append(columnSql);

        /**更新的条件:要更改的的字段sql，其实就是用key拼起来的**/
        StringBuilder whereSql = new StringBuilder();
        int j = 0;
        if (whereMap != null && whereMap.size() > 0) {
            whereSql.append(" WHERE ");
            iterator = whereMap.keySet().iterator();
            while (iterator.hasNext()) {
                String key = iterator.next();
                whereSql.append(j == 0 ? "" : " AND ");
                whereSql.append(key + " = ? ");
                objects.add(whereMap.get(key));
                j++;
            }
            sql.append(whereSql);
        }
        return executeUpdate(sql.toString(), objects.toArray());
    }

    /**
     * 执行删除操作
     *
     * @param tableName 要删除的表名
     * @param whereMap  删除的条件
     * @return 影响的行数
     * @throws SQLException SQL执行异常
     */
    public static int delete(String tableName, Map<String, Object> whereMap) throws SQLException {
        /**准备删除的sql语句**/
        StringBuilder sql = new StringBuilder();
        sql.append("DELETE FROM ");
        sql.append(tableName);

        /**更新的条件:要更改的的字段sql，其实就是用key拼起来的**/
        StringBuilder whereSql = new StringBuilder();
        Object[] bindArgs = null;
        if (whereMap != null && whereMap.size() > 0) {
            bindArgs = new Object[whereMap.size()];
            whereSql.append(" WHERE ");
            /**获取数据库插入的Map的键值对的值**/
            Set<String> keySet = whereMap.keySet();
            Iterator<String> iterator = keySet.iterator();
            int i = 0;
            while (iterator.hasNext()) {
                String key = iterator.next();
                whereSql.append(i == 0 ? "" : " AND ");
                whereSql.append(key + " = ? ");
                bindArgs[i] = whereMap.get(key);
                i++;
            }
            sql.append(whereSql);
        }
        return executeUpdate(sql.toString(), bindArgs);
    }

    /**
     * 可以执行新增，修改，删除
     *
     * @param sql      sql语句
     * @param bindArgs 绑定参数
     * @return 影响的行数
     * @throws SQLException SQL异常
     */
    public static int executeUpdate(String sql, Object[] bindArgs) throws SQLException {
        /**影响的行数**/
        int affectRowCount = -1;
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        try {
            /**从数据库连接池中获取数据库连接**/
            connection = DBConnectionPool.getInstance().getConnection();
            /**执行SQL预编译**/
            preparedStatement = connection.prepareStatement(sql.toString());
            /**设置不自动提交，以便于在出现异常的时候数据库回滚**/
            connection.setAutoCommit(false);
            System.out.println(getExecSQL(sql, bindArgs));
            if (bindArgs != null) {
                /**绑定参数设置sql占位符中的值**/
                for (int i = 0; i < bindArgs.length; i++) {
                    preparedStatement.setObject(i + 1, bindArgs[i]);
                }
            }
            /**执行sql**/
            affectRowCount = preparedStatement.executeUpdate();
            connection.commit();
            String operate;
            if (sql.toUpperCase().indexOf("DELETE FROM") != -1) {
                operate = "删除";
            } else if (sql.toUpperCase().indexOf("INSERT INTO") != -1) {
                operate = "新增";
            } else {
                operate = "修改";
            }
            System.out.println("成功" + operate + "了" + affectRowCount + "行");
            System.out.println();
        } catch (Exception e) {
            if (connection != null) {
                connection.rollback();
            }
            e.printStackTrace();
            throw e;
        } finally {
            if (preparedStatement != null) {
                preparedStatement.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        return affectRowCount;
    }

    /**
     * 通过sql查询数据,
     * 慎用，会有sql注入问题
     *
     * @param sql
     * @return 查询的数据集合
     * @throws SQLException
     */
    public static List<Map<String, Object>> query(String sql) throws SQLException {
        return executeQuery(sql, null);
    }

    /**
     * 执行sql通过 Map<String, Object>限定查询条件查询
     *
     * @param tableName 表名
     * @param whereMap  where条件
     * @return List<Map<String, Object>>
     * @throws SQLException
     */
    public static List<Map<String, Object>> query(String tableName,
                                                  Map<String, Object> whereMap) throws Exception {
        String whereClause = "";
        Object[] whereArgs = null;
        if (whereMap != null && whereMap.size() > 0) {
            Iterator<String> iterator = whereMap.keySet().iterator();
            whereArgs = new Object[whereMap.size()];
            int i = 0;
            while (iterator.hasNext()) {
                String key = iterator.next();
                whereClause += (i == 0 ? "" : " AND ");
                whereClause += (key + " = ? ");
                whereArgs[i] = whereMap.get(key);
                i++;
            }
        }
        return query(tableName, false, null, whereClause, whereArgs, null, null, null, null);
    }

    /**
     * 执行sql条件参数绑定形式的查询
     *
     * @param tableName   表名
     * @param whereClause where条件的sql
     * @param whereArgs   where条件中占位符中的值
     * @return List<Map<String, Object>>
     * @throws SQLException
     */
    public static List<Map<String, Object>> query(String tableName,
                                                  String whereClause,
                                                  String[] whereArgs) throws SQLException {
        return query(tableName, false, null, whereClause, whereArgs, null, null, null, null);
    }

    /**
     * 执行全部结构的sql查询
     *
     * @param tableName     表名
     * @param distinct      去重
     * @param columns       要查询的列名
     * @param selection     where条件
     * @param selectionArgs where条件中占位符中的值
     * @param groupBy       分组
     * @param having        筛选
     * @param orderBy       排序
     * @param limit         分页
     * @return List<Map<String, Object>>
     * @throws SQLException
     */
    public static List<Map<String, Object>> query(String tableName,
                                                  boolean distinct,
                                                  String[] columns,
                                                  String selection,
                                                  Object[] selectionArgs,
                                                  String groupBy,
                                                  String having,
                                                  String orderBy,
                                                  String limit) throws SQLException {
        String sql = buildQueryString(distinct, tableName, columns, selection, groupBy, having, orderBy, limit);
        return executeQuery(sql, selectionArgs);

    }

    /**
     * 执行查询
     *
     * @param sql      要执行的sql语句
     * @param bindArgs 绑定的参数
     * @return List<Map<String, Object>>结果集对象
     * @throws SQLException SQL执行异常
     */
    public static List<Map<String, Object>> executeQuery(String sql, Object[] bindArgs) throws SQLException {
        List<Map<String, Object>> datas = new ArrayList<>();
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            /**获取数据库连接池中的连接**/
            connection = DBConnectionPool.getInstance().getConnection();
            preparedStatement = connection.prepareStatement(sql);
            if (bindArgs != null) {
                /**设置sql占位符中的值**/
                for (int i = 0; i < bindArgs.length; i++) {
                    preparedStatement.setObject(i + 1, bindArgs[i]);
                }
            }
            System.out.println(getExecSQL(sql, bindArgs));
            /**执行sql语句，获取结果集**/
            resultSet = preparedStatement.executeQuery();
            datas = getDatas(resultSet);
            System.out.println();
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        } finally {
            if (resultSet != null) {
                resultSet.close();
            }
            if (preparedStatement != null) {
                preparedStatement.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        return datas;
    }


    /**
     * 将结果集对象封装成List<Map<String, Object>> 对象
     *
     * @param resultSet 结果多想
     * @return 结果的封装
     * @throws SQLException
     */
    private static List<Map<String, Object>> getDatas(ResultSet resultSet) throws SQLException {
        List<Map<String, Object>> datas = new ArrayList<>();
        /**获取结果集的数据结构对象**/
        ResultSetMetaData metaData = resultSet.getMetaData();
        while (resultSet.next()) {
            Map<String, Object> rowMap = new HashMap<>();
            for (int i = 1; i <= metaData.getColumnCount(); i++) {
                rowMap.put(metaData.getColumnName(i), resultSet.getObject(i));
            }
            datas.add(rowMap);
        }
        System.out.println("成功查询到了" + datas.size() + "行数据");
        for (int i = 0; i < datas.size(); i++) {
            Map<String, Object> map = datas.get(i);
            System.out.println("第" + (i + 1) + "行：" + map);
        }
        return datas;
    }


    /**
     * Build an SQL query string from the given clauses.
     *
     * @param distinct true if you want each row to be unique, false otherwise.
     * @param tables   The table names to compile the query against.
     * @param columns  A list of which columns to return. Passing null will
     *                 return all columns, which is discouraged to prevent reading
     *                 data from storage that isn't going to be used.
     * @param where    A filter declaring which rows to return, formatted as an SQL
     *                 WHERE clause (excluding the WHERE itself). Passing null will
     *                 return all rows for the given URL.
     * @param groupBy  A filter declaring how to group rows, formatted as an SQL
     *                 GROUP BY clause (excluding the GROUP BY itself). Passing null
     *                 will cause the rows to not be grouped.
     * @param having   A filter declare which row groups to include in the cursor,
     *                 if row grouping is being used, formatted as an SQL HAVING
     *                 clause (excluding the HAVING itself). Passing null will cause
     *                 all row groups to be included, and is required when row
     *                 grouping is not being used.
     * @param orderBy  How to order the rows, formatted as an SQL ORDER BY clause
     *                 (excluding the ORDER BY itself). Passing null will use the
     *                 default sort order, which may be unordered.
     * @param limit    Limits the number of rows returned by the query,
     *                 formatted as LIMIT clause. Passing null denotes no LIMIT clause.
     * @return the SQL query string
     */
    private static String buildQueryString(
            boolean distinct, String tables, String[] columns, String where,
            String groupBy, String having, String orderBy, String limit) {
        if (isEmpty(groupBy) && !isEmpty(having)) {
            throw new IllegalArgumentException(
                    "HAVING clauses are only permitted when using a groupBy clause");
        }
        if (!isEmpty(limit) && !sLimitPattern.matcher(limit).matches()) {
            throw new IllegalArgumentException("invalid LIMIT clauses:" + limit);
        }

        StringBuilder query = new StringBuilder(120);

        query.append("SELECT ");
        if (distinct) {
            query.append("DISTINCT ");
        }
        if (columns != null && columns.length != 0) {
            appendColumns(query, columns);
        } else {
            query.append(" * ");
        }
        query.append("FROM ");
        query.append(tables);
        appendClause(query, " WHERE ", where);
        appendClause(query, " GROUP BY ", groupBy);
        appendClause(query, " HAVING ", having);
        appendClause(query, " ORDER BY ", orderBy);
        appendClause(query, " LIMIT ", limit);
        return query.toString();
    }

    /**
     * Add the names that are non-null in columns to s, separating
     * them with commas.
     */
    private static void appendColumns(StringBuilder s, String[] columns) {
        int n = columns.length;

        for (int i = 0; i < n; i++) {
            String column = columns[i];

            if (column != null) {
                if (i > 0) {
                    s.append(", ");
                }
                s.append(column);
            }
        }
        s.append(' ');
    }

    /**
     * addClause
     *
     * @param s      the add StringBuilder
     * @param name   clauseName
     * @param clause clauseSelection
     */
    private static void appendClause(StringBuilder s, String name, String clause) {
        if (!isEmpty(clause)) {
            s.append(name);
            s.append(clause);
        }
    }

    /**
     * Returns true if the string is null or 0-length.
     *
     * @param str the string to be examined
     * @return true if str is null or zero length
     */
    private static boolean isEmpty(@Nullable CharSequence str) {
        if (str == null || str.length() == 0)
            return true;
        else
            return false;
    }

    /**
     * the pattern of limit
     */
    private static final Pattern sLimitPattern =
            Pattern.compile("\\s*\\d+\\s*(,\\s*\\d+\\s*)?");

    /**
     * After the execution of the complete SQL statement, not necessarily the actual implementation of the SQL statement
     *
     * @param sql      SQL statement
     * @param bindArgs Binding parameters
     * @return Replace? SQL statement executed after the
     */
    private static String getExecSQL(String sql, Object[] bindArgs) {
        StringBuilder sb = new StringBuilder(sql);
        if (bindArgs != null && bindArgs.length > 0) {
            int index = 0;
            for (int i = 0; i < bindArgs.length; i++) {
                index = sb.indexOf("?", index);
                sb.replace(index, index + 1, String.valueOf(bindArgs[i]));
            }
        }
        return sb.toString();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\GetData.java
package com.ccsu.crawler.utils;

import com.alibaba.fastjson.JSONObject;
import com.ccsu.crawler.model.*;
import org.apache.log4j.Logger;

import java.util.List;

public class GetData {

    private static Logger logger = Logger.getLogger(GetData.class);

    /**
     *  获取开发者信息
     * @param login
     */
    public static List<Developer> getDeveloperData(String login){
        String url = URLBuilder.urlDeveBuilder(login);
        String data = URLRequest.sendGet(url);
        List<JSONObject> jsonObjects_Developer = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListDeveloper(jsonObjects_Developer);
    }

    /**
     *  获取用户项目仓库详细信息
     * @param fullName
     */
    public static List<Repository> getRepositoryData(String fullName){
        String url = URLBuilder.urlRepoBuilder(fullName);
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListRepository(firstJsonObjects);
    }

    /**
     *  获取用户所有项目仓库信息
     * @param login
     */
    public static List<Repository> getAllRepositoryData(String login){
        String url = URLBuilder.urlDeveAllReposBuilder(login);
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListRepository(firstJsonObjects);
    }

    /**
     *  获取项目分支信息
     * @param repository
     */
    public static List<Branch> getBranchData(Repository repository) {
        String url = URLBuilder.urlRepoPoBuilder(repository.getFullName(), "branches");
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListBranch(firstJsonObjects);
    }

    /**
     *  获取项目贡献值
     * @param repository
     */
    public static List<Contributor> getContributorData(Repository repository) {
        String url = URLBuilder.urlRepoPoBuilder(repository.getFullName(), "contributors");
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListContributor(firstJsonObjects);
    }

    /**
     *  获取项目使用的多种语言
     * @param repository
     */
    public static List<Language> getLanguageData(Repository repository) {
        String url = URLBuilder.urlRepoPoBuilder(repository.getFullName(), "languages");
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListLanguage(firstJsonObjects);
    }

    /**
     *  获取项目的star信息
     * @param repository
     */
    public static List<Star> getStarData(Repository repository) {
        String url = URLBuilder.urlRepoPoBuilder(repository.getFullName(), "stargazers");
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListStar(firstJsonObjects);
    }

    /**
     *  获取项目的fork信息
     * @param repository
     */
    public static List<Fork> getForkData(Repository repository) {
        String url = URLBuilder.urlRepoPoBuilder(repository.getFullName(), "forks");
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListFork(firstJsonObjects);
    }

    /**
     *  获取用户之间关注的关系
     * @param login
     * @param followType
     */
    public static List<Developer> getfollowData(String login, String followType) {
        String url = URLBuilder.urlFollowBuilder(login, followType);
        String data = URLRequest.sendGet(url);
        List<JSONObject> firstJsonObjects = JSONParse.stringToJson(data);
        return JSONParse.listJSONObjectToListDeveloper(firstJsonObjects);
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\JSONParse.java
package com.ccsu.crawler.utils;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.ccsu.crawler.model.*;
import org.apache.log4j.Logger;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

public class JSONParse {

    private static Logger logger = Logger.getLogger(JSONParse.class);

    /**
     * 字符串转换成JSON数组
     *
     * @param string
     * @return List<JSONObject>
     */
    public static List<JSONObject> stringToJson(String string) {
        if (string == null || string.isEmpty() || string.equals("[]")) {
            return null;
        }
        if (string.substring(0, 1).equals("{")) {
            string = "[" + string + "]";
        }
        JSONArray jsonArray = JSONArray.parseArray(string);
        List<JSONObject> jsonObjectList = new ArrayList<JSONObject>();
        for (int i = 0; i < jsonArray.size(); i++) {
            if (jsonArray.getJSONObject(i).getString("owner") != null) {
                JSONObject object = JSONObject.parseObject(jsonArray.getJSONObject(i).getString("owner"));
                jsonArray.getJSONObject(i).put("ownerId", object.getString("login"));
            }
            jsonObjectList.add(jsonArray.getJSONObject(i));
        }
        return jsonObjectList;
    }

    /**
     * 字符串转换成日期
     *
     * @param UTCStr
     * @return date
     */
    public static Date UTCStringtODate(String UTCStr) {
        if (UTCStr == null || UTCStr.isEmpty()) {
            return null;
        }
        String format;
        Date date = null;
        if (UTCStr.length() == 20) {
            format = "yyyy-MM-dd'T'HH:mm:ss'Z'";
        } else {
            format = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'";
        }
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        try {
            date = sdf.parse(UTCStr);
        } catch (ParseException e) {
            //e.printStackTrace();
            logger.info("抛出异常：" + e);
        }
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR, calendar.get(Calendar.HOUR) + 8);
        //calendar.getTime() 返回的是Date类型，也可以使用calendar.getTimeInMillis()获取时间戳
        return calendar.getTime();
    }

    /**
     * JSON list转换成fork list
     *
     * @param jsonObjectList
     * @return List<Fork>
     */
    public static List<Fork> listJSONObjectToListFork(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Fork> forkList = new ArrayList<Fork>();
        for (int i = 0; i < jsonObjectList.size(); i++) {
            Fork fork = new Fork();
            fork.setForklogin(jsonObjectList.get(i).getString("ownerId"));
            forkList.add(fork);
        }
        return forkList;
    }

    /**
     * JSON list转换成fork list
     *
     * @param jsonObjectList
     * @return List<Star>
     */
    public static List<Star> listJSONObjectToListStar(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Star> starList = new ArrayList<Star>();
        for (int i = 0; i < jsonObjectList.size(); i++) {
            Star star = new Star();
            star.setStarlogin(jsonObjectList.get(i).getString("login"));
            starList.add(star);
        }
        return starList;
    }

    /**
     * JSON list转换成fork list
     *
     * @param jsonObjectList
     * @return List<ContributorDao>
     */
    public static List<Contributor> listJSONObjectToListContributor(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Contributor> contributors = new ArrayList<Contributor>();
        for (int i = 0; i < jsonObjectList.size(); i++) {
            Contributor contributor = new Contributor();
            contributor.setContributor(jsonObjectList.get(i).getString("login"));
            contributor.setContributions(jsonObjectList.get(i).getInteger("contributions"));
            contributors.add(contributor);
        }
        return contributors;
    }

    /**
     * JSON list转换成fork list
     *
     * @param jsonObjectList
     * @return List<Language>
     */
    public static List<Language> listJSONObjectToListLanguage(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Language> languages = new ArrayList<Language>();
        for (Map.Entry<String, Object> entry : jsonObjectList.get(0).entrySet()) {
            //System.out.println(entry.getKey() + ":" + entry.getValue());
            Language language = new Language();
            language.setLanguage(entry.getKey());
            language.setSize((int) entry.getValue());
            languages.add(language);
        }
        return languages;
    }

    /**
     * JSON list转换成branch list
     *
     * @param jsonObjectList
     * @return List<Branch>
     */
    public static List<Branch> listJSONObjectToListBranch(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Branch> branchList = new ArrayList<Branch>();
        for (int i = 0; i < jsonObjectList.size(); i++) {
            Branch branch = new Branch();
            branch.setBranchname(jsonObjectList.get(i).getString("name"));
            branchList.add(branch);
        }
        return branchList;
    }

    /**
     * JSON list转换成develop list
     *
     * @param jsonObjectList
     * @return List<Developer>
     */
    public static List<Developer> listJSONObjectToListDeveloper(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Developer> developerList = new ArrayList<Developer>();
        for (int i = 0; i < jsonObjectList.size(); i++) {
            Developer developer = new Developer();
            developer.setLogin(jsonObjectList.get(i).getString("login"));
            developer.setId(jsonObjectList.get(i).getLong("id"));
            developer.setName(jsonObjectList.get(i).getString("name"));
            developer.setAvatarUrl(jsonObjectList.get(i).getString("avatar_url"));
            developer.setCompany(jsonObjectList.get(i).getString("company"));
            developer.setBlog(jsonObjectList.get(i).getString("blog"));
            developer.setEmail(jsonObjectList.get(i).getString("email"));
            developer.setBio(jsonObjectList.get(i).getString("bio"));
            developer.setPublicRepos(jsonObjectList.get(i).getInteger("public_repos"));
            developer.setFollowers(jsonObjectList.get(i).getInteger("followers"));
            developer.setFollowing(jsonObjectList.get(i).getInteger("following"));
            developer.setType(jsonObjectList.get(i).getString("type"));
            developer.setLocation(jsonObjectList.get(i).getString("location"));
            developer.setCreatedAt(UTCStringtODate(jsonObjectList.get(i).getString("created_at")));
            developer.setUpdatedAt(UTCStringtODate(jsonObjectList.get(i).getString("updated_at")));
            developerList.add(developer);
        }
        return developerList;
    }

    /**
     * JSON list 转换成 Developer list Search
     *
     * @param list
     * @return List<Developer>
     */
    public static List<Developer> listJSONObjectToListDeveloperSearch(List<JSONObject> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        List<Developer> developerList = new ArrayList<Developer>();
        for (int j = 0; j < list.size(); j++) {
            List<JSONObject> jsonObjectList = stringToJson(list.get(j).getString("items"));
            developerList = listJSONObjectToListDeveloper(jsonObjectList);
        }
        return developerList;
    }

    /**
     * JSON list 转换成 Repository list
     *
     * @param jsonObjectList
     * @return List<Developer>
     */
    public static List<Repository> listJSONObjectToListRepository(List<JSONObject> jsonObjectList) {
        if (jsonObjectList == null || jsonObjectList.isEmpty()) {
            return null;
        }
        List<Repository> repositoryList = new ArrayList<Repository>();
        for (int i = 0; i < jsonObjectList.size(); i++) {
            Repository repository = new Repository();
            repository.setId(jsonObjectList.get(i).getLong("id"));
            repository.setName(jsonObjectList.get(i).getString("name"));
            repository.setFullName(jsonObjectList.get(i).getString("full_name"));
            repository.setDescription(jsonObjectList.get(i).getString("description"));
            repository.setDefaultBranch(jsonObjectList.get(i).getString("default_branch"));
            repository.setCreatedAt(UTCStringtODate(jsonObjectList.get(i).getString("created_at")));
            repository.setUpdatedAt(UTCStringtODate(jsonObjectList.get(i).getString("updated_at")));
            repository.setPushedAt(UTCStringtODate(jsonObjectList.get(i).getString("pushed_at")));
            repository.setSize(jsonObjectList.get(i).getInteger("size"));
            repository.setStarCount(jsonObjectList.get(i).getInteger("stargazers_count"));
            repository.setWatchersCount(jsonObjectList.get(i).getInteger("watchers_count"));
            repository.setForksCount(jsonObjectList.get(i).getInteger("forks_count"));
            repository.setLanguage(jsonObjectList.get(i).getString("language"));
            repository.setDeveloperLogin(jsonObjectList.get(i).getString("ownerId"));
            repository.setUpdated(new Date());
            repositoryList.add(repository);
        }
        return repositoryList;
    }

    /**
     * JSON list 转换成 Repository list Search
     *
     * @param list
     * @return List<Repository>
     */
    public static List<Repository> listJSONObjectToListRepositorySearch(List<JSONObject> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        List<Repository> repositoryList = new ArrayList<Repository>();
        for (int j = 0; j < list.size(); j++) {
            List<JSONObject> jsonObjectList = stringToJson(list.get(j).getString("items"));
            repositoryList = listJSONObjectToListRepository(jsonObjectList);
        }
        return repositoryList;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\MysqlConnect.java
package com.ccsu.crawler.utils;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class MysqlConnect {

    static {
        try {
            //加载驱动程序
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static Connection getConnect() throws SQLException {
        String url = "jdbc:mysql://localhost:3306/github?useUnicode=true&characterEncoding=utf-8";
        String user = "root";
        String password = "root123456";
        return DriverManager.getConnection(url, user, password);
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\URLBuilder.java
package com.ccsu.crawler.utils;

public class URLBuilder {

    private final static String USRS_PREFIX = "https://api.github.com/users/";
    private final static String REPO_PREFIX = "https://api.github.com/repos/";
    /**
     * 通过 用户名 构建用户URL
     *
     * @param login nama user.
     * @return String类型的URL地址
     */
    public static String urlDeveBuilder(String login) {
        return USRS_PREFIX + login;
    }

    /**
     * 通过 用户名 和 followType 构建follow URL
     *
     * @param login nama user.
     * @return String类型的URL地址
     */
    public static String urlFollowBuilder(String login , String followType) {
        return USRS_PREFIX + login + "/" + followType + "?per_page=100";
    }

    /**
     * 通过 用户名 构建 用户所有仓库 URL
     *
     * @param login nama user.
     * @return String类型的URL地址
     */
    public static String urlDeveAllReposBuilder(String login) {
        return USRS_PREFIX + login + "/repos?sort=pushed&per_page=100";
    }

    /**
     * 通过 项目全名 构建 详细信息的 URL
     *
     * @param fullName
     * @return String类型的URL地址
     */
    public static String urlRepoPoBuilder(String fullName,String type) {
        return REPO_PREFIX + fullName + "/" + type + "?per_page=100";
    }

    /**
     * 通过 项目全名 构建 仓库 URL
     *
     * @param fullName
     * @return String类型的URL地址
     */
    public static String urlRepoBuilder(String fullName) {
        return REPO_PREFIX + fullName;
    }

    /**
     * 通过 搜索开发者 构建URL
     *
     * @param params
     * @return String类型的URL地址
     */
    public static String urlSearchDeveBuilder(String params) {

        return "https://api.github.com/search/users?q=" + params;
    }

    /**
     * 通过 搜索项目 构建URL
     *
     * @param params
     * @return String类型的URL地址
     */
    public static String urlSearchRepoBuilder(String params) {

        return "https://api.github.com/search/repositories?q=" + params;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\main\java\com\ccsu\crawler\utils\URLRequest.java
package com.ccsu.crawler.utils;

import org.apache.log4j.Logger;

import java.io.*;
import java.net.URL;
import java.net.URLConnection;
import java.util.List;
import java.util.Map;

public class URLRequest {

    private static Logger logger = Logger.getLogger(URLRequest.class);
    /**
     * 向指定URL发送GET方法的请求
     *
     * @param url   发送请求的URL
     * @return URL 所代表远程资源的响应结果
     */
    public static String sendGet(String url) {
        StringBuilder result = new StringBuilder();
        BufferedReader in = null;
        InputStream inputStream = null;
        InputStreamReader inputStreamReader = null;
        try {
            URL realUrl = new URL(url);
            // 打开和URL之间的连接
            URLConnection connection = realUrl.openConnection();
            // 设置通用的请求属性
            connection.setRequestProperty("accept", "application/vnd.github.v3+json");
            //connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("Authorization", "token 31ea7e75e68219dc93c952f0ac15836a1cc4335d");
            connection.setRequestProperty("user-agent","Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            // 建立实际的连接
            connection.connect();
            // 获取所有响应头字段
            Map<String, List<String>> map = connection.getHeaderFields();
            int remaining = Integer.parseInt(map.get("X-RateLimit-Remaining").get(0));
            if(remaining == 0){
                logger.info("==========线程sleep==========");
                Long resetTime = new Long(map.get("X-RateLimit-Reset").get(0)) * 1000;
                Long currentTime = System.currentTimeMillis();
                logger.info("线程将sleep "+ (resetTime - currentTime) +" 毫秒");
                Thread.sleep(resetTime - currentTime + 20);
                logger.info("=========线程sleep结束========");
            }
            //logger.info("Remaining:" + remaining);
            // 遍历所有的响应头字段
//            for (String key : map.keySet()) {
//                System.out.println(key + "--->" + map.get(key));
//            }
            // 定义 BufferedReader输入流来读取URL的响应
            inputStream = connection.getInputStream();
            inputStreamReader = new InputStreamReader(inputStream);
            in = new BufferedReader(inputStreamReader);
            String line;
            while ((line = in.readLine()) != null) {
                result.append(line);
            }
        } catch (Exception e) {
            //e.printStackTrace();
            logger.info("发送GET请求出现异常！" + e);
            return null;
        }
        // 使用finally块来关闭输入流
        finally {
            if (in != null) {
                try {
                    in.close();
                    inputStreamReader.close();
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return result.toString();
    }

    /**
     * 向指定 URL 发送POST方法的请求
     *
     * @param url   发送请求的 URL
     * @return 所代表远程资源的响应结果
     */
    public static String sendPost(String url) {
        PrintWriter out = null;
        BufferedReader in = null;
        StringBuilder result = new StringBuilder();
        try {
            URL realUrl = new URL(url);
            // 打开和URL之间的连接
            URLConnection conn = realUrl.openConnection();
            // 设置通用的请求属性
            conn.setRequestProperty("accept", "application/vnd.github.v3+json");
            conn.setRequestProperty("connection", "Keep-Alive");
            conn.setRequestProperty("user-agent",
                    "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");
            // 发送POST请求必须设置如下两行
            conn.setDoOutput(true);
            conn.setDoInput(true);
            // 获取URLConnection对象对应的输出流
            out = new PrintWriter(conn.getOutputStream());
            // flush输出流的缓冲
            out.flush();
            // 定义BufferedReader输入流来读取URL的响应
            in = new BufferedReader(
                    new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                result.append(line);
            }
        } catch (Exception e) {
            System.out.println("发送 POST 请求出现异常！" + e);
            e.printStackTrace();
        }
        //使用finally块来关闭输出流、输入流
        finally {
            try {
                if (out != null) {
                    out.close();
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
        return result.toString();
    }
}

C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\test\DBTest.java
import cn.bluemobi.dylan.util.DBUtil;

import java.sql.SQLException;
import java.util.*;

/**
 * Created by yuandl on 2016-12-16.
 */
public class DBTest {

    public static void main(String[] args) {
//        System.out.println("数据库的原数据");
//        testQuery3();
//        testInsert();
//        System.out.println("执行插入后的数据");
//        testQuery3();
//        testUpdate();
//        System.out.println("执行修改后的数据");
//        testQuery3();
//        testDelete();
//        System.out.println("执行删除后的数据");
//        testQuery3();
//        System.out.println("带条件的查询1");
//        testQuery2();
//        System.out.println("带条件的查询2");
//        testQuery1();
        testAll1();
        testAll2();
    }


    private static void testAll1() {

        long start = System.currentTimeMillis();
        try {
            for (int i = 0; i < 10000; i++) {
                Map<String, Object> map = new HashMap<>();
                map.put("emp_id", 1013);
                map.put("name", "JDBCUtil测试");
                map.put("job", "developer");
                map.put("salary", 10000);
                map.put("hire_date", new java.sql.Date(System.currentTimeMillis()));
                DBUtil.insert("emp_test3", map);
            }
            System.out.println("共耗时" + (System.currentTimeMillis() - start));
        } catch (SQLException e) {
            e.printStackTrace();
        }
        //共耗时44110
    }

    private static void testAll2() {
        List<Map<String, Object>> datas = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            Map<String, Object> map = new HashMap<>();
            map.put("emp_id", 1013);
            map.put("name", "JDBCUtil测试");
            map.put("job", "developer");
            map.put("salary", 10000);
            map.put("hire_date", new java.sql.Date(System.currentTimeMillis()));
            datas.add(map);
        }
        try {
            long start = System.currentTimeMillis();
            DBUtil.insertAll("emp_test3", datas);
            System.out.println("共耗时" + (System.currentTimeMillis() - start));
        } catch (SQLException e) {
            e.printStackTrace();
        }
        //共耗时649
    }

    /**
     * 测试插入
     */
    private static void testInsert() {
        Map<String, Object> map = new HashMap<>();
        map.put("emp_id", 1013);
        map.put("name", "JDBCUtil测试");
        map.put("job", "developer");
        map.put("salary", 10000);
        map.put("hire_date", new java.sql.Date(System.currentTimeMillis()));
        try {
            int count = DBUtil.insert("emp_test", map);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    /**
     * 测试更新
     */
    private static void testUpdate() {
        Map<String, Object> map = new HashMap<>();
        map.put("name", "测试更新");

        Map<String, Object> whereMap = new HashMap<>();
        whereMap.put("emp_id", "1013");
        try {
            int count = DBUtil.update("emp_test", map, whereMap);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    /**
     * 测试删除
     */
    private static void testDelete() {
        Map<String, Object> whereMap = new HashMap<>();
        whereMap.put("emp_id", 1013);
        whereMap.put("job", "developer");
        try {
            int count = DBUtil.delete("emp_test", whereMap);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 查询方式一
     */
    public static void testQuery1() {
        Map<String, Object> whereMap = new HashMap<>();
        whereMap.put("salary", "10000");
        try {
            DBUtil.query("emp_test", whereMap);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 查询方式二
     */
    public static void testQuery2() {
        String where = "job = ?  AND salary = ? ";
        String[] whereArgs = new String[]{"clerk", "3000"};

        try {
            List<Map<String, Object>> list = DBUtil.query("emp_test", where, whereArgs);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 查询方式三
     */
    public static void testQuery3() {
        try {
            List<Map<String, Object>> list = DBUtil.query("emp_test", false, null, null, null, null, null, null, null);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * SQL注入问题
     */
    public static void query4() {
        String name = "'1' OR '1'='1'";
        String password = "'1' OR '1'='1'";

        String sql = "SELECT * FROM emp_test WHERE name = " + name + " and password = " + password;
        String where = "name = ?  AND password = ? ";
        String[] whereArgs = new String[]{name, password};

        try {
            DBUtil.query(sql);
            DBUtil.query("emp_test", false, null, where, whereArgs, null, null, null, null);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GithubCrawler\src\test\Main.java
import com.mchange.v2.c3p0.ComboPooledDataSource;
import com.mchange.v2.c3p0.DataSources;

import java.beans.PropertyVetoException;
import java.sql.Connection;
import java.sql.SQLException;

public class Main {

    public static void main(String[] args) {
        ComboPooledDataSource cpds = new ComboPooledDataSource();
        try {
            // 数据源进行各种有效的控制：
            // 设置驱动
            cpds.setDriverClass("oracle.jdbc.driver.OracleDriver");
            // 设置数据库URL
//            cpds.setJdbcUrl("jdbc:oracle:thin:@10.58.178.162:1521:ORCL");
            cpds.setJdbcUrl("jdbc:oracle:thin:@//CNXAYUANDLD001.Bluemobi.cn:1521:orcl");
            // 设置用户名
            cpds.setUser("scott");
            // 设置密码
            cpds.setPassword("tiger");
            // 当连接池中的连接用完时，C3PO一次性创建新的连接数目;
            cpds.setAcquireIncrement(3);
            // 定义在从数据库获取新的连接失败后重复尝试获取的次数，默认为30;
            cpds.setAcquireRetryAttempts(30);
            // 两次连接中间隔时间默认为1000毫秒
            cpds.setAcquireRetryDelay(1000);
            // 连接关闭时默认将所有未提交的操作回滚 默认为false;
            cpds.setAutoCommitOnClose(false);
            // 获取连接失败将会引起所有等待获取连接的线程异常,但是数据源仍有效的保留,并在下次调用getConnection()的时候继续尝试获取连接.如果设为true,那么尝试获取连接失败后该数据源将申明已经断开并永久关闭.默认为false
            cpds.setBreakAfterAcquireFailure(false);
            // 当连接池用完时客户端调用getConnection()后等待获取新连接的时间,超时后将抛出SQLException,如设为0则无限期等待.单位毫秒,默认为0
            cpds.setCheckoutTimeout(0);
            // 隔多少秒检查所有连接池中的空闲连接,默认为0表示不检查;
            cpds.setIdleConnectionTestPeriod(0);
            // 初始化时创建的连接数,应在minPoolSize与maxPoolSize之间取值.默认为3
            cpds.setInitialPoolSize(10);
            // 最大空闲时间,超过空闲时间的连接将被丢弃.为0或负数据则永不丢弃.默认为0;
            cpds.setMaxIdleTime(0);
            // 连接池中保留的最大连接数据.默认为15
            cpds.setMaxPoolSize(20);
            // JDBC的标准参数,用以控制数据源内加载的PreparedStatement数据.但由于预缓存的Statement属于单个Connection而不是整个连接池.所以设置这个参数需要考滤到多方面的因素,如果maxStatements
            // 与maxStatementsPerConnection均为0,则缓存被关闭.默认为0;
            cpds.setMaxStatements(0);
            // 连接池内单个连接所拥有的最大缓存被关闭.默认为0;
            cpds.setMaxStatementsPerConnection(0);
            // C3P0是异步操作的,缓慢的JDBC操作通过帮助进程完成.扩展这些操作可以有效的提升性能,通过多数程实现多个操作同时被执行.默为为3
            cpds.setNumHelperThreads(3);
            // 用户修改系统配置参数执行前最多等待的秒数.默认为300;
            cpds.setPropertyCycle(300);
            // 获取数据连接
            Connection conn = cpds.getConnection();
            if ( conn != null) {
                System.out.println("OK");
                // 关闭连接,当前连接被连接池收回
                conn.close();
            }

        } catch (PropertyVetoException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭数据连接池
                DataSources.destroy(cpds);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
