C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\integer.txt
user:admin
password:
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\AnalysisModule.java
package analysis;

import java.util.List;

import metadao.MetaDaoController;

/**
 * this module use meta data and some methods to
 * get useful data 
 * @author guanjun
 *
 */
public abstract class AnalysisModule {	
	private String project_name;
	
	private MetaDaoController metaController;
	
	public AnalysisModule(){
		super();
	}
	
	public AnalysisModule(MetaDaoController metaController){
		this.metaController = metaController;	
		
		this.project_name = metaController.getDataSource().getProjectName();
	}
	
	
	private List<usefuldata.Developer> developers;
	private List<usefuldata.DeveloperEcharts> developer_echarts;
	private List<usefuldata.EvolveEcharts> evolve_echarts;
	private List<usefuldata.ForceEcharts> force_echarts;
	private usefuldata.Project project;
	private List<usefuldata.ProjectContribution> project_contribution;
	private List<usefuldata.ReleaseContribution> release_contributions;
	private List<usefuldata.ReleaseEcharts> release_echarts;
	private List<usefuldata.Release> releases;
	private List<usefuldata.Vitality> vitalities;
	
	
	/**
	 * analysis meta data and get all useful data
	 * after invoke this method you can use Getter method to get data
	 */
	public abstract void analyzeAll();


	public String getProject_name() {
		return project_name;
	}


	public MetaDaoController getMetaController() {
		return metaController;
	}


	public List<usefuldata.Developer> getDevelopers() {
		return developers;
	}


	public List<usefuldata.DeveloperEcharts> getDeveloper_echarts() {
		return developer_echarts;
	}


	public List<usefuldata.EvolveEcharts> getEvolve_echarts() {
		return evolve_echarts;
	}


	public List<usefuldata.ForceEcharts> getForce_echarts() {
		return force_echarts;
	}


	public usefuldata.Project getProject() {
		return project;
	}


	public List<usefuldata.ProjectContribution> getProject_contribution() {
		return project_contribution;
	}


	public List<usefuldata.ReleaseContribution> getRelease_contributions() {
		return release_contributions;
	}


	public List<usefuldata.ReleaseEcharts> getRelease_echarts() {
		return release_echarts;
	}


	public List<usefuldata.Release> getReleases() {
		return releases;
	}


	public List<usefuldata.Vitality> getVitalities() {
		return vitalities;
	}
	
	public abstract void invokeEvolveAnalysis();
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\BasicAnalysis.java
package analysis;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import metadao.MetaDaoController;
import usefuldata.DeveloperEcharts;
import usefuldata.EvolveEcharts;
import usefuldata.ForceEcharts;
import usefuldata.ProjectContribution;
import usefuldata.Release;
import usefuldata.ReleaseContribution;
import usefuldata.ReleaseEcharts;
import usefuldata.Vitality;
import util.Dates;
import util.ZipFiles;
import crawler.DataSource;
import entity.Contributor;
import entity.Crawlindex;
import entity.UnPublishedRelease;
import entity.User;
import factory.MetaDaoFactory;

public class BasicAnalysis extends AnalysisModule{
	private DataSource datasource;
	private MetaDaoController metaController;
	
	private CodeLinesCount codeLinesCount;
	private DevelopDigram developDigram;
	private EvolveAnalysis evolveAnalysis;
	private PackageDependency packageDependency;
	private Relation relation;
	private TestFilesStatistics tests;
	
	private DataHelper dataHelperImpl;
	
	private int project_id;
	private String project_name;
	private String owner;
	
	public BasicAnalysis(MetaDaoController metaController){
		this.metaController = metaController;
		this.datasource = metaController.getDataSource();
		
		this.project_id = datasource.getProject().getId();
		this.project_name = datasource.getProject().getName();
		this.owner = datasource.getOwner();
		
		this.codeLinesCount = new CodeLinesCountImpl();
		this.developDigram = new DevelopDigramImpl();
		this.evolveAnalysis = new EvolveAnalysis(project_name,owner);
		this.packageDependency = new PackageDependencyImpl();
		this.dataHelperImpl = new DataHelperImpl(project_name,owner);
		this.tests = new TestFilesStatisticsImpl();		
	}
	

	
	private List<usefuldata.Developer> developers;
	private List<usefuldata.DeveloperEcharts> developer_echarts;
	private List<usefuldata.EvolveEcharts> evolve_echarts;
	private List<usefuldata.ForceEcharts> force_echarts;
	private usefuldata.Project project;
	private List<usefuldata.ProjectContribution> project_contribution;
	private List<usefuldata.ReleaseContribution> release_contributions;
	private List<usefuldata.ReleaseEcharts> release_echarts;
	private List<usefuldata.Release> releases;
	private List<usefuldata.Vitality> vitalities;
	
	
	/**
	 * analysis meta data and get all useful data
	 */
	public void analyzeAll(){
		DeveloperAnalysis();
		DeveloperEchartAnalysis();
		VitalityAnalysis();	
		ForceEchartsAnalysis();
		ProjectContributionAnalysis();
		
		ProjectAnalysis();
		
		ReleaseEchartsAnalysis();
		
		ReleaseAnalysis();
		
		ReleaseContributionAnalysis();
	}
	
	
	public void invokeEvolveAnalysis(){		
		//dao should be done before this operation
		EvolveEchartsAnalysis();
	}
	
	/**
	 * get developer with meta data
	 */
	private void DeveloperAnalysis(){
		ArrayList<usefuldata.Developer> developers = new ArrayList<usefuldata.Developer>();
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(this.project_id);
		List<User> users = MetaDaoFactory.getUserDao().getAllUsers(contributors);
		
		for(int i = 0;i<users.size();i++){
			developers.add(users.get(i).DeveloperTransform());
		}
		
		this.developers = developers;
	}
	
	/**
	 * get developer_echarts with meta data
	 */
	private void DeveloperEchartAnalysis(){
		this.developer_echarts = new ArrayList<usefuldata.DeveloperEcharts>();
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project_id);	
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(this.project_id);
		
		for(int i = 0;i<contributors.size();i++){
			for(int j = 0;j<uprs.size();j++){
				DeveloperEcharts dle = new DeveloperEcharts();
				dle.setProject_id(this.project_id);
				dle.setRelease_id(uprs.get(j).getId());
				dle.setDeveloper_id(contributors.get(i).getId());
				ArrayList<String> file_names = this.dataHelperImpl.getFiles(this.project_name, uprs.get(j).getName(), contributors.get(i).getLogin(),this.owner);
				String json_string = "";
				if(file_names!=null && file_names.size() != 0)
					json_string = this.developDigram.getDevelopDigramByVersion(file_names);
		
				if(!json_string.equals("")){
					dle.setJson_string(json_string);
					developer_echarts.add(dle);
				}
			}
		}
		
	}
	
	/**
	 * get evolve_echarts with meta data
	 */
	private void EvolveEchartsAnalysis(){
		this.evolve_echarts = new ArrayList<usefuldata.EvolveEcharts>();
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project_id);
		String json = "";
		
		for(int i = 0;i<uprs.size();i++){
			json = evolveAnalysis.getEvolveJson(uprs.get(i).getName());
			if(!json.equals("")){
				EvolveEcharts e = new EvolveEcharts(this.project_id,uprs.get(i).getId(),json);
				if(e!=null)
					this.evolve_echarts.add(e);	
			}
				
		}
	}
	
	/**
	 * get force_echarts with meta data
	 */
	private void ForceEchartsAnalysis(){
		this.force_echarts = new ArrayList<usefuldata.ForceEcharts>();
		
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project_id);
		String relation_json = "";
		String main_relation_json = "";
		
		for(int i = 0;i<uprs.size();i++){
			this.relation = new RelationImpl(this.project_name,uprs.get(i).getName(),this.owner);
			relation_json = this.relation.getRelations();
			main_relation_json = this.relation.getMainRelations();
			if(!relation_json.equals("") && !main_relation_json.equals("")){
				ForceEcharts fe = new ForceEcharts(this.project_id,uprs.get(i).getId(),relation_json,main_relation_json);
				if(fe!=null)
					this.force_echarts.add(fe);
			}
			
		}
		
	}
	
	
	/**
	 * get project with meta data
	 */
	private void ProjectAnalysis(){
		ArrayList<String> languages = new ArrayList<String>();
		languages.add(this.datasource.getProject().getLanguage());	
		
		System.out.println(languages.get(0) + " is the main language!");
		
		String destination = "Downloads/"+this.getProject_name() +".zip";
		ZipFiles zip = new ZipFiles(this.datasource.getLatest_location(),destination);
		zip.ZipZup();
		
		File file = new File(this.datasource.getLatest_location());
		zip.recursiveDelete(file);
		
		System.out.println(destination + " is the destination!");
		
		int main_count = codeLinesCount.getCodeLines(destination);
		System.out.println(main_count + " is the code num!");
		
		File zipFile = new File(destination);
		zip.recursiveDelete(zipFile);
		
		this.project = this.datasource.getProject().ProjectTransform(main_count,this.datasource.getOwner());
				
	}
	
	/**
	 * get project_contribution with meta data
	 */
	private void ProjectContributionAnalysis(){
		this.project_contribution = new ArrayList<ProjectContribution>();
		
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(this.project_id);
		for(int i = 0;i<contributors.size();i++){
			ProjectContribution pjc = new ProjectContribution();
			pjc.setProjectName(this.project_name);
			pjc.setProject_id(this.project_id);
			pjc.setDeveloper_id(contributors.get(i).getId());
			
			int ctb = MetaDaoFactory.getCommitDao().Contributions(this.project_id, contributors.get(i).getId());
			pjc.setContributions(ctb);	
			this.project_contribution.add(pjc);
		}
		
	}
	
	
	/**
	 * get release_contribution with meta data
	 */
	private void ReleaseContributionAnalysis(){		
		this.release_contributions = new ArrayList<usefuldata.ReleaseContribution>();
		
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project_id);
		
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(this.project_id);
		for(int i = 0;i<contributors.size();i++){
		
		for(int j = 0;j<uprs.size();j++){
			ReleaseContribution rlct = new ReleaseContribution();
			rlct.setRelease_id(uprs.get(j).getId());
			rlct.setProject_id(this.project_id);
			rlct.setDeveloper_id(contributors.get(i).getId());
			rlct.setReleaseName(uprs.get(j).getName());
			
			int contributions = this.dataHelperImpl.getReleaseSize(contributors.get(i).getLogin(), this.project_name, uprs.get(j).getName(),this.owner);
			rlct.setContributions(contributions);
			
			this.release_contributions.add(rlct);
		}
		}
	}
	
	
	/**
	 * get release_echarts with meta data
	 */
	private void ReleaseEchartsAnalysis(){
		this.release_echarts = new ArrayList<usefuldata.ReleaseEcharts>();
		ArrayList<String> languages = new ArrayList<String>();
		languages.add(this.datasource.getProject().getLanguage());
				
		ArrayList<String> package_json = this.packageDependency.getPakageDependency(this.datasource.getRelease_location(), languages);		
				
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project_id);		
		for(int i = 0;i<uprs.size();i++){
			if(package_json.size() > i){
			ReleaseEcharts re = new ReleaseEcharts(this.project_id,
				uprs.get(i).getId(),package_json.get(i));		
			release_echarts.add(re);
			}else{
			ReleaseEcharts re = new ReleaseEcharts(this.project_id,
						uprs.get(i).getId(),"");		
			release_echarts.add(re);	
			}
			
	}
		
	}
	
	
	/**
	 * get release with meta data
	 */
	private void ReleaseAnalysis(){		
		ArrayList<String> languages = new ArrayList<String>();
		languages.add(this.datasource.getProject().getLanguage());	
		
		this.releases = new ArrayList<usefuldata.Release>();
		ArrayList<String> uprs_location = this.datasource.getRelease_location();
		List<UnPublishedRelease> unpublish_releases = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project_id);
		
		Crawlindex  outIndex = this.datasource.getOutIndex();
		int i;
				
		if(uprs_location.size() >= unpublish_releases.size()){
				i = 0;	
		}else{
				i = outIndex.getRelease_idx() - 1;
				if(i < 0)
					i = 0;
		}
				
			for(;i<unpublish_releases.size();i++){
				Release release = new Release();
				release.setId(unpublish_releases.get(i).getId());			
				release.setName(unpublish_releases.get(i).getName());	
				release.setProject_id(this.project_id);
				
				int codes = codeLinesCount.getCodeLines(uprs_location.get(i));
				int test_counts = tests.getTestFilesCount(uprs_location.get(i));
				
				//int codes = this.dataHelperImpl.getCodes(this.project_name, unpublish_releases.get(i).getName());
				
				release.setCodes(codes);
				release.setTest(test_counts);
				release.setDate(unpublish_releases.get(i).getDate());
				
				int commits = this.dataHelperImpl.getReleaseCommits(this.project_name, unpublish_releases.get(i).getName(),this.owner);
				release.setRelease_commits(commits);
				
				release.setDocument(this.dataHelperImpl.getDocument());
				release.setTest(this.dataHelperImpl.getTest());
				
				if(i != unpublish_releases.size()-1){
					String date1 = unpublish_releases.get(i).getDate();
					String date2 = unpublish_releases.get(i+1).getDate();
					long diff_day = Dates.dayDiffer(date1, date2);
					double rate = diff_day/1.0;
					release.setCommit_rate(rate);
				}
				else{
					String date1 = unpublish_releases.get(i).getDate();
					String date2 = Dates.dateToString(new Date());
					long diff_day = Dates.dayDiffer(date1, date2);
					double rate = diff_day/7.0;
					release.setCommit_rate(rate);
				}
				
				int issues = this.dataHelperImpl.getIssueNum(this.project_name, unpublish_releases.get(i).getName(),this.owner);
				release.setIssue_number(issues);
				
				release.setComprehensive(this.dataHelperImpl.getComprehensive());
				
				releases.add(release);
				
				try{
					ZipFiles zip = new ZipFiles(uprs_location.get(i),"");			
					File file = new File(uprs_location.get(i));
					zip.recursiveDelete(file);
				}catch(Exception e){
					e.printStackTrace();
				}
			}					
		}
		
	
	/**
	 * get vitality with meta data
	 */
	private void VitalityAnalysis(){
		this.vitalities = new ArrayList<Vitality>();
		List<Contributor> developers = MetaDaoFactory.getContributorDao().getAllContributors(this.project_id);
		for(Contributor c:developers){
			List<Vitality> v1 = this.dataHelperImpl.getVitality(this.project_name, c.getLogin(),this.owner);
			if(v1!=null)
			this.vitalities.addAll(v1);			
		}
		
	}

	
	
	public CodeLinesCount getCodeLinesCount() {
		return codeLinesCount;
	}

	public void setCodeLinesCount(CodeLinesCount codeLinesCount) {
		this.codeLinesCount = codeLinesCount;
	}

	public DevelopDigram getDevelopDigram() {
		return developDigram;
	}

	public void setDevelopDigram(DevelopDigram developDigram) {
		this.developDigram = developDigram;
	}

	public EvolveAnalysis getEvolveAnalysis() {
		return evolveAnalysis;
	}

	public void setEvolveAnalysis(EvolveAnalysis evolveAnalysis) {
		this.evolveAnalysis = evolveAnalysis;
	}

	public PackageDependency getPackageDependency() {
		return packageDependency;
	}

	public void setPackageDependency(PackageDependency packageDependency) {
		this.packageDependency = packageDependency;
	}

	public Relation getRelation() {
		return relation;
	}

	public void setRelation(Relation relation) {
		this.relation = relation;
	}

	public DataHelper getDataHelperImpl() {
		return dataHelperImpl;
	}

	public void setDataHelperImpl(DataHelper dataHelperImpl) {
		this.dataHelperImpl = dataHelperImpl;
	}

	public int getProject_id() {
		return project_id;
	}

	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}

	public String getProject_name() {
		return project_name;
	}

	public void setProject_name(String project_name) {
		this.project_name = project_name;
	}

	public List<usefuldata.Developer> getDevelopers() {
		return developers;
	}

	public void setDevelopers(List<usefuldata.Developer> developers) {
		this.developers = developers;
	}

	public List<usefuldata.DeveloperEcharts> getDeveloper_echarts() {
		return developer_echarts;
	}

	public void setDeveloper_echarts(
			List<usefuldata.DeveloperEcharts> developer_echarts) {
		this.developer_echarts = developer_echarts;
	}

	public List<usefuldata.EvolveEcharts> getEvolve_echarts() {
		return evolve_echarts;
	}

	public void setEvolve_echarts(List<usefuldata.EvolveEcharts> evolve_echarts) {
		this.evolve_echarts = evolve_echarts;
	}

	public List<usefuldata.ForceEcharts> getForce_echarts() {
		return force_echarts;
	}

	public void setForce_echarts(List<usefuldata.ForceEcharts> force_echarts) {
		this.force_echarts = force_echarts;
	}

	public usefuldata.Project getProject() {
		return project;
	}

	public void setProject(usefuldata.Project project) {
		this.project = project;
	}

	public List<usefuldata.ProjectContribution> getProject_contribution() {
		return project_contribution;
	}

	public void setProject_contribution(
			List<usefuldata.ProjectContribution> project_contribution) {
		this.project_contribution = project_contribution;
	}

	public List<usefuldata.ReleaseContribution> getRelease_contributions() {
		return release_contributions;
	}

	public void setRelease_contributions(
			List<usefuldata.ReleaseContribution> release_contributions) {
		this.release_contributions = release_contributions;
	}

	public List<usefuldata.ReleaseEcharts> getRelease_echarts() {
		return release_echarts;
	}

	public void setRelease_echarts(List<usefuldata.ReleaseEcharts> release_echarts) {
		this.release_echarts = release_echarts;
	}

	public List<usefuldata.Release> getReleases() {
		return releases;
	}

	public void setReleases(List<usefuldata.Release> releases) {
		this.releases = releases;
	}

	public List<usefuldata.Vitality> getVitalities() {
		return vitalities;
	}

	public void setVitalities(List<usefuldata.Vitality> vitalities) {
		this.vitalities = vitalities;
	}


	public MetaDaoController getMetaController() {
		return metaController;
	}

	public void setMetaController(MetaDaoController metaController) {
		this.metaController = metaController;
	}


	public DataSource getDatasource() {
		return datasource;
	}


	public void setDatasource(DataSource datasource) {
		this.datasource = datasource;
	}


	public String getOwner() {
		return owner;
	}


	public void setOwner(String owner) {
		this.owner = owner;
	}

	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\CodeLinesCount.java
package analysis;

public interface CodeLinesCount {
	public int getCodeLines(String file);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\CodeLinesCountImpl.java
package analysis;


import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

/**
 * this class tries to analyze source code
 * from a zip file
 * return lines of code
 */

public class CodeLinesCountImpl implements CodeLinesCount {
	static private int codeLines = 0;

	
	private static void readZipFile(String file) throws Exception {
		codeLines=0;
		ZipFile zf = new ZipFile(file);
		InputStream in = new BufferedInputStream(new FileInputStream(file));
		ZipInputStream zin = new ZipInputStream(in);
		ZipEntry ze;

		while ((ze = zin.getNextEntry()) != null) {
			if (!ze.isDirectory()) {
				String fnp = ze.getName();

				String[] fns = fnp.split("/");
				int l = fns.length;
				String fn = fns[l - 1];

				String[] ftypes = fn.split("\\.");
				String ftype = "";
				if (ftypes.length == 2) {
					ftype = ftypes[1];
				}
				boolean findLanguageType = false;

				String[] languagetype = { "java", "1", "js", "sh", "rb", "cmp",
						"eps", "perl", "pl", "pm", "html", "php", "css", "bcp",
						"fmk", "asi", "bcp", "c++", "cc", "cls", "cpp", "crf",
						"cxx", "dbg", "dpr", "dsk", "h", "hpp", "hxx", "py",
						"pyc", "pyw", "pyo", "pyd", "r", "R", "c", "m", "mm",
						"o", "xslt", "xsl", "cjl", "asm", "m" ,"yml"};
				for (int i = 0; i < languagetype.length; i++) {
					if (ftype.equals(languagetype[i])) {
						findLanguageType = true;
				//		System.out.println(fnp);
						break;
					}
				}

				if (findLanguageType) {

					BufferedReader br = new BufferedReader(
							new InputStreamReader(zf.getInputStream(ze)));
					while ((br.readLine()) != null) {
						codeLines++;
					}
					br.close();
				}

				long size = ze.getSize();
				if (size > 0) {

				}
				// s System.out.println();
			}
		}

		zf.close();
		zin.close();
		// zin.closeEntry();
	}

	public int getCodeLines(String file) {
		try {
			readZipFile(file);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return codeLines;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\DataHelper.java
package analysis;

import java.util.ArrayList;
import java.util.List;

import usefuldata.Comment;
import usefuldata.CommitDate;
import usefuldata.VersionDate;

public interface DataHelper {
	
	
	/**
	 * try to get a developer's contribution
	 * @param developerName
	 * @param projectName
	 * @param releaseName
	 * @return
	 */
	public int getReleaseSize(String developerName, String projectName,
			String releaseName,String owner);// use in force chart
	
	/**
	 * try to get a developer's contribution from some release(contained)  to Now
	 * @param developerName
	 * @param projectName
	 * @return int
	 */
	public int getSize(String developerName, String projectName,
			String releaseName,String owner);//use in evolve

	
	
	/**
	 * try to get a developer's contribution to this project
	 * @param developerName
	 * @param projectName
	 * @return
	 */
	public int getSize(String developerName, String projectName,String owner);
	
	
	/**
	 * get all filenames of a project which modified by one in a release
	 * @param developerName
	 * @param projectName
	 * @param releaseName
	 * @return
	 */
	
	public ArrayList<String> getFiles(String projectName,String release,String developer,String owner); //use in force chart
	
	/**
	 * get all developers of a project
	 * @param projectName 
	 * @return ArrayList<String>
	 */

	public ArrayList<String> getAllDeveloperNames(String projectName,String owner);//use in evolve
	
	
	/**
	 * get all files modified by some developer during a period of time(start to end )
	 * @prama projectName
	 * @prama developerName(one)
	 * @param start date (yy-mm-dd)
	 * @param end date (yy-mm-dd)
	 * @return ArrayList<String>
	 */
	
	public ArrayList<String> getFiles(String projectName,String developer,String start,String end,String owner);//use in evolve
	
	
	/**
	 *get VersionDate enties of whole project
	 *@prama projectName
	 * @return ArrayList<VersionDate>
	 *
	 */
	
	public ArrayList<VersionDate> getVersions(String projectName,String owner);//use in evolve
	
	
	/**
	 *get CommitDate enties of whole project
	 *@prama projectName
	 *@prama release
	 *@return ArrayList<CommitDate>
	 *
	 */
	
	public ArrayList<CommitDate> getCommits(String projectName,String owner);//use in evolve
	
	
	/**
	 *get issues of one project
	 *@prama projectName
	 *
	 *@return ArrayList<Issue>
	 *
	 */
	
	public ArrayList<usefuldata.Issue> getIssues(String projectName,String owner);//use in evolve
	

	/**
	 *get comments of one project
	 *@prama projectName
	 *
	 *@return ArrayList<Issue>
	 *
	 */
	public ArrayList<Comment> getComments(String projectName,String owner);//use in evolve
	
	
	/**
	 *get codes of one release
	 *@prama projectName
	 *@prama release
	 *@return int
	 *
	 */
	
	public int getCodes(String projectName,String release,String owner);//use in evolve
	
	/**
	 * get commit nums of a certain release
	 * @param projectName
	 * @param release
	 * @return
	 */
	public int getReleaseCommits(String projectName,String release,String owner);
	
	/**
	 * get issue nums of a certain release
	 * @param projectName
	 * @param release
	 * @return
	 */
	public int getIssueNum(String projectName,String release,String owner);
	
	public int getComprehensive();
	
	public int getTest();
	
	public int getDocument();
	
	public List<usefuldata.Vitality> getVitality(String projectName,String developer,String owner);
	
	/**
	 *check if file downloaded is zip, or pack it a zipfile 
	 *@param path
	 * @return zip path( and delete the prior file)
	 */
	public String packFile(String filepath);
	/**
	 * @param releaseName
	 *            ,projectName,owner
	 * @return issue ids in one release
	 */
	public ArrayList<String> getIssueIds(String releaseName, String project,
			String owner);

	/**
	 * @param releaseName
	 * @return Relevant Persons id in one issue
	 */
	public ArrayList<String> getRelevantPersonsInOneIssue(String issueId);
}

C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\DataHelperImpl.java
package analysis;


import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import entity.Commit;
import entity.CommitFile;
import entity.Project;
import entity.UnPublishedRelease;
import factory.DaoFactory;
import factory.MetaDaoFactory;
import usefuldata.Comment;
import usefuldata.CommitDate;
import usefuldata.Issue;
import usefuldata.VersionDate;
import usefuldata.Vitality;
import util.Dates;



public class DataHelperImpl implements DataHelper {

	private entity.Project project;
	private List<UnPublishedRelease> ups;
	
	public DataHelperImpl(){
		super();
	}
	
	public DataHelperImpl(String projectName,String owner){
		this.project = MetaDaoFactory.getProjectDao().getProject(owner,projectName);
		this.ups = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(this.project.getId());
	}
	
	
	@Override
	public int getSize(String developerName, String projectName,
			String releaseName,String owner) {
		
		int developer_id = MetaDaoFactory.getContributorDao().getContributor(developerName).getId();
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		int release_id = MetaDaoFactory.getUnPublishedReleaseDao().getUnPublishedRelease(releaseName, project_id).getId();
		
		//int contributions = DaoFactory.getReleaseContribution().getReleaseContributions(developer_id, project_id, release_id);
		
		int contributions = getContributions(developer_id, project_id, release_id);
		
		return contributions;
	}

	@Override
	public int getSize(String developerName, String projectName,String owner) {
		
		int developer_id = MetaDaoFactory.getContributorDao().getContributor(developerName).getId();
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		
		//int contributions = DaoFactory.getProjectContribution().getProjectContributions(developer_id, project_id);
		
		int contributions = MetaDaoFactory.getCommitDao().Contributions(project_id, developer_id);
		
		return contributions;
	}


	@Override
	public ArrayList<String> getAllDeveloperNames(String projectName,String owner) {
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		
		List<entity.Contributor> all_contributors = MetaDaoFactory.getContributorDao().getAllContributors(project_id);
		
		//ArrayList<Integer> developer_ids = DaoFactory.getProjectContribution().getAllProjectContributors(project_id);
		
		ArrayList<String> names = new ArrayList<String>();
		for(int i = 0;i<all_contributors.size();i++){
			//String login = DaoFactory.getDeveloperDao().findDeveloperForName(developer_ids.get(i)).getLogin();
			String login = all_contributors.get(i).getLogin();
			if(login!=null)
			names.add(login);
		}
	
		return names;
	}

	

	@Override
	public ArrayList<VersionDate> getVersions(String projectName,String owner) {
		Project p = MetaDaoFactory.getProjectDao().getProject(owner,projectName);
		
		if(p==null)
			return null;
		else
		{
			int project_id = p.getId();
			//List<usefuldata.Release> releases = DaoFactory.getReleaseDao().getAllRelease(project_id);
			List<entity.UnPublishedRelease> uprs =  MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
			
			ArrayList<VersionDate> versionDates = new ArrayList<VersionDate>();
			for(int i =0;i<uprs.size();i++){
				VersionDate vd = new VersionDate();
				vd.setVersion(uprs.get(i).getName());
				vd.setDate(uprs.get(i).getDate());
				vd.setOrder(i + 1);				
				versionDates.add(vd);
			}
			
			return versionDates;
		}
		
	}



	@Override
	public int getCodes(String projectName, String release,String owner) {
		
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();	

		/**
		 * this could cause some bugs 
		 * remember to invoke this method
		 * after data into the dao database
		 */
		int codes = DaoFactory.getReleaseDao().getRelease(project_id, release).getCodes();
		
		return codes;
	}

	@Override
	public ArrayList<CommitDate> getCommits(String projectName,String owner) {
		int projectId = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		List<Commit> commits = MetaDaoFactory.getCommitDao().getCommits(projectId);
		ArrayList<CommitDate> cds = new ArrayList<CommitDate>();
		
		for(Commit cmt:commits){
			CommitDate cd = new CommitDate();
			cd.setName(cmt.getCommiter().getLogin());
			cd.setDate(Dates.dateToString(cmt.getCommitDate()));
			cds.add(cd);
		}
		
		return cds;
	}


	@Override
	public int getReleaseSize(String developerName, String projectName,
			String releaseName,String owner) {	
		int developer_id = MetaDaoFactory.getContributorDao().getContributor(developerName).getId();
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		int release_id = MetaDaoFactory.getUnPublishedReleaseDao().getUnPublishedRelease(releaseName, project_id).getId();
		
		int contributions = getContributions(developer_id, project_id, release_id);
		
		return contributions;
	}

	@Override
	public ArrayList<String> getFiles(String projectName, String release,
			String developer,String owner) {
		int developer_id = MetaDaoFactory.getContributorDao().getContributor(developer).getId();
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		
		UnPublishedRelease upbr = MetaDaoFactory.getUnPublishedReleaseDao().getUnPublishedRelease(release, project_id);
		List<UnPublishedRelease> releases = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
		List<Commit> commits = MetaDaoFactory.getCommitDao().getCommits(project_id, developer_id);
		
		ArrayList<String> shas = new ArrayList<String>();
		
		int upbr_idx = 0;
		
		Map<String,String> release_dates = new HashMap<String,String>();
		for(int i =0;i<releases.size();i++){
			if(upbr.getName().equals(releases.get(i).getName())){
				upbr_idx = i;
			}
			release_dates.put(releases.get(i).getName(), releases.get(i).getDate());
		}
		
		for(Commit c:commits){
			int idx = Dates.getDateIndex(Dates.dateToString(c.getCommitDate()), release_dates);
			if(idx == upbr_idx){
				shas.add(c.getSha());
			}
		}
		
		ArrayList<String> files = new ArrayList<String>();
		
		for(String sha:shas){
			CommitFile commitFile = MetaDaoFactory.getCommitFileDao().getCommitFile(sha);
			if(commitFile!=null)
			files.add(commitFile.getFilename());
		}
		
		return files;
	}
	
	
	@Override
	public ArrayList<String> getFiles(String projectName, String developer,
			String start, String end,String owner) {
		int developer_id = MetaDaoFactory.getContributorDao().getContributor(developer).getId();
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		List<Commit> metacommits = MetaDaoFactory.getCommitDao().getCommits(project_id, developer_id);
		List<String> shas = new ArrayList<String>();
		for(Commit c:metacommits){
			int left = Dates.compare_date(start, Dates.dateToString(c.getCommitDate()));
			int right = Dates.compare_date(end, Dates.dateToString(c.getCommitDate()));
			//left should be 0 or -1
			//right should be 0 or 1
			if(left== 0 || left == -1){
				if(right ==0 || right == 1){
					shas.add(c.getSha());
				}
			}
		}
		ArrayList<String> files = new ArrayList<String>();
		for(String sha:shas){
			CommitFile cf = MetaDaoFactory.getCommitFileDao().getCommitFile(sha);
			if(cf!=null)
				files.add(cf.getFilename());
		}
		
		return files;
	}

	@Override
	public ArrayList<usefuldata.Issue> getIssues(String projectName,String owner) {
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		ArrayList<usefuldata.Issue> issues = MetaDaoFactory.getIssueDao().getAllIssues(project_id);
		return issues;
	}

	@Override
	public ArrayList<Comment> getComments(String projectName,String owner) {
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		ArrayList<Comment> comments = MetaDaoFactory.getCommentDao().getUsefulComments(projectName, project_id);
		return comments;
	}

	private int getContributions(int developer_id,int project_id,int release_id){
		int contributions = 0;
		UnPublishedRelease upr = MetaDaoFactory.getUnPublishedReleaseDao().getUnPublishedRelease(release_id);
		
		List<String> dates = new ArrayList<String>();
		//List<UnPublishedRelease> all = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
		if(this.ups != null){
			for(UnPublishedRelease u:this.ups){
				if(u!=null)
				dates.add(u.getDate());
			}
		}
		
		List<Commit> commits = MetaDaoFactory.getCommitDao().getCommits(project_id, developer_id);
		
		for(int i = 0;i<commits.size();i++){
			String date = Dates.dateToString(commits.get(i).getCommitDate());
			if(Dates.BelongToRelease(date,upr.getDate(),dates)){
				contributions += commits.get(i).getAdditionsCount() + commits.get(i).getDeletionsCount();		
			}
			
		}
		
		return contributions;
	}

	@Override
	public int getReleaseCommits(String projectName, String release,String owner) {
		String start_time = "";
		String end_time = "";
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
		for(int i = 0;i<uprs.size();i++){
			if(uprs.get(i).getName().equals(release)){
				start_time = uprs.get(i).getDate();
				if(i!=uprs.size()-1)
					end_time = uprs.get(i+1).getDate();
				
				break;
			}
			
		}
		
		int num = 0;
		if(!end_time.equals(""))
			num = MetaDaoFactory.getCommitDao().releaseCommits(project_id, start_time, end_time);
		else
			num = MetaDaoFactory.getCommitDao().releaseCommits(project_id, start_time);
		
		return num;
	}

	@Override
	public int getIssueNum(String projectName, String release,String owner) {
		String start_time = "";
		String end_time = "";
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
		for(int i = 0;i<uprs.size();i++){
			if(uprs.get(i).getName().equals(release)){
				start_time = uprs.get(i).getDate();
				if(i!=uprs.size()-1)
					end_time = uprs.get(i+1).getDate();
				
				break;
			}
			
		}
		
		int num = 0;
		if(!end_time.equals(""))
			num = MetaDaoFactory.getIssueDao().IssueNum(project_id, start_time, end_time);
		else
			num = MetaDaoFactory.getIssueDao().IssueNum(project_id, start_time);
		
		return num;
	}

	@Override
	public int getComprehensive() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int getTest() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int getDocument() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public List<Vitality> getVitality(String projectName, String developer,String owner) {
		int developer_id = MetaDaoFactory.getContributorDao().getContributor(developer).getId();
		int project_id = MetaDaoFactory.getProjectDao().getProject(owner,projectName).getId();
		List<Vitality> vitalities = new ArrayList<Vitality>();
				
		List<Commit> commits = MetaDaoFactory.getCommitDao().getCommits(project_id, developer_id);
		Map<String,Integer> date_commits = new HashMap<String,Integer>();
		
		List<String> all_dates = new ArrayList<String>();	
		if(this.ups != null){
			for(UnPublishedRelease u:this.ups){
				if(u!=null)
					all_dates.add(u.getDate());
			}
		}
			
		for(int i = 0;i<commits.size();i++){						
			String date = Dates.dateToString(commits.get(i).getCommitDate());			
			if(date_commits.containsKey(date)){
				Integer value = date_commits.get(date);
				date_commits.replace(date, value + 1);
			}
			else
				date_commits.put(date, 1);
		}
		
		Set<String> date_set = date_commits.keySet();
		for(String d:date_set){
			for(UnPublishedRelease u :this.ups){
				if(Dates.BelongToRelease(d, u.getDate(), all_dates)){
					Vitality v = new Vitality();
					v.setId(0);
					v.setProject_id(project_id);
					v.setRelease_id(u.getId());
					v.setDeveloper_id(developer_id);
					v.setDate(d);
					v.setVitality(date_commits.get(d));
					
					vitalities.add(v);
					break;
				}
			}
						
		}
		
		
		return vitalities;
	}

	@Override
	public String packFile(String filepath) {
		// TODO Auto-generated method stub		
		File fileDownload = new File(filepath);
		if (fileDownload.isDirectory()) {			
			createZip(filepath, filepath+".zip");
			return filepath + ".zip";
		}
		return filepath;
		
	}
	
	 private void createZip(String sourcePath, String zipPath) {
	        FileOutputStream fos = null;
	        ZipOutputStream zos = null;
	        try {
	            fos = new FileOutputStream(zipPath);
	            zos = new ZipOutputStream(fos);
	            writeZip(new File(sourcePath), "", zos);
	        } catch (FileNotFoundException e) {
	        } finally {
	            try {
	                if (zos != null) {
	                    zos.close();
	                }
	            } catch (IOException e) {
	            }

	        }
	    }
	    
	    private static void writeZip(File file, String parentPath, ZipOutputStream zos) {
	        if(file.exists()){
	            if(file.isDirectory()){//处理文件夹
	                parentPath+=file.getName()+File.separator;
	                File [] files=file.listFiles();
	                for(File f:files){
	                    writeZip(f, parentPath, zos);
	                }
	            }else{
	                FileInputStream fis=null;
	                DataInputStream dis=null;
	                try {
	                    fis=new FileInputStream(file);
	                    dis=new DataInputStream(new BufferedInputStream(fis));
	                    ZipEntry ze = new ZipEntry(parentPath + file.getName());
	                    zos.putNextEntry(ze);
	                    byte [] content=new byte[1024];
	                    int len;
	                    while((len=fis.read(content))!=-1){
	                        zos.write(content,0,len);
	                        zos.flush();
	                    }
	                    	                
	                } catch (FileNotFoundException e) {
	                } catch (IOException e) {
	                }finally{
	                    try {
	                        if(dis!=null){
	                            dis.close();
	                        }
	                    }catch(IOException e){
	                    }
	                }
	            }
	        }
	    }

		@Override
		public ArrayList<String> getIssueIds(String releaseName,
				String project, String owner) {
			ArrayList<String> ids = new ArrayList<String>();
			
			int project_id = MetaDaoFactory.getProjectDao().getProject(owner,project).getId();
			ArrayList<Issue> issues = MetaDaoFactory.getIssueDao().getAllIssues(project_id);
			
			String start_time = "";
			String end_time = "";
			
			List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
			for(int i = 0;i<uprs.size();i++){
				if(uprs.get(i).getName().equals(releaseName)){
					start_time = uprs.get(i).getDate();
					if(i!=uprs.size()-1)
						end_time = uprs.get(i+1).getDate();
					
					break;
				}
				
			}
			
			for(int i = 0;i<issues.size();i++){
				if(inPeriod(issues.get(i).getInjectedDate(),start_time,end_time))
					ids.add(issues.get(i).getIssueId() + "");
			}
			
			return ids;
		}

		@Override
		public ArrayList<String> getRelevantPersonsInOneIssue(String issueId) {
			// TODO Auto-generated method stub
			return null;
		}    
	
		private boolean inPeriod(String date,String start_time,String end_time){
			int result1 = Dates.compare_date(date, start_time);
			int result2 = Dates.compare_date(date, end_time);
			
			if(result1 == 1 && result2 == -1)
				return true;
			
			return false;
		}
		
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\DevelopDigram.java
package analysis;

import java.util.ArrayList;

public interface DevelopDigram {
	/**
	 * focus on a release of a project developed by a developer 
	 * @param filenames 
	 * @return package structure with json format
	 * 
	 * developer_echarts
	 */
	public String getDevelopDigramByVersion( ArrayList<String> filenames);

	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\DevelopDigramImpl.java
package analysis;

import java.util.ArrayList;

import net.sf.json.JSONArray;
import usefuldata.PackageNode;

public class DevelopDigramImpl implements DevelopDigram {

	private ArrayList<PackageNode> architectures;
	private boolean toJson;
	
	public  DevelopDigramImpl()
	{
		architectures= new ArrayList<PackageNode>();
		toJson=false;
	}

	private String architecturesToJson(boolean toJson) {
		
		if(toJson)
		{
		JSONArray json = JSONArray.fromObject(architectures.get(0));
		String jsonStr=json.toString();
		String resultStr=jsonStr.substring(1,jsonStr.length()-1);
	
		//String resultStr=json.toString().substring(1,json.toString().length()-1);
		architectures = new ArrayList<PackageNode>();
		return resultStr;
		}
		else return null;
	}

	private int findPakage(String path) {
		int result = -1;

		for (int i = 0; i < architectures.size(); i++) {
			if (path.equals(architectures.get(i).takePath())) {
				result = i;
				break;
			}

		}

		return result;
	}

	private void traverse(int i) {
		//System.out.println(i);
		PackageNode pnc = architectures.get(i);
		if (pnc.takeCIndex() != null) {
			for (Integer j : pnc.takeCIndex()) {
				traverse(j);
				PackageNode pnc2 = architectures.get(j);
				pnc.addChild(pnc2);
				//System.out.println(pnc.getPath()+"child:");
				//System.out.println(pnc2.getPath());
				architectures.set(i, pnc);
			}
		}

	}

	@Override
	public String getDevelopDigramByVersion(ArrayList<String> filenames) {
		// TODO Auto-generated method stub

		for (String file : filenames) {
			file="./"+file;
			String pathName = "";
			String[] pakageNames = file.split("/");
			for (int i = 0; i < pakageNames.length; i++) {
				if (i == (pakageNames.length - 1))
					pathName += pakageNames[i];
				else
					pathName += pakageNames[i] + "/";
			
				if (findPakage(pathName) == -1) 
				{
					
					PackageNode pakagenode = new PackageNode(pathName,
							pakageNames[i]);
					architectures.add(pakagenode);
				}
			}

		}

		
		//System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"+architectures.size());
		for (int i = 0; i < architectures.size(); i++) {
			PackageNode pn = architectures.get(i);
			String pnPath = pn.takePath();
			String[] fns = pnPath.split("/");

			for (int j = 0; j < architectures.size(); j++) {
				PackageNode pn2 = architectures.get(j);
				String pn2Path = pn2.takePath();

				if (pn2Path.length() > pnPath.length()) {
					if (findPakage(pn2Path) != -1) {

						String[] fns2 = pn2Path.split("/");

						if (pn2Path.contains(pnPath)
								&& (fns2.length - fns.length) == 1) {
							pn.addChild(j);
						}

						architectures.set(i, pn);
					}
				}
				
				
			}
			
		}

		if(filenames.size()!=0)
		{
		traverse(0);
	    toJson=true;
		}
		
		return architecturesToJson(toJson);
	}

}



C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\EvolveAnalysis.java
package analysis;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import usefuldata.Comment;
import usefuldata.CommitDate;
import usefuldata.Link;
import usefuldata.Movement;
import usefuldata.Node;
import usefuldata.Radar;
import usefuldata.Version;
import usefuldata.VersionDate;
import net.sf.json.JSONArray;

public class EvolveAnalysis {
	private DataHelper dh;
	private ArrayList<String> developers;
	private String projectName;
	// private ArrayList<String> releases;
	private List<Movement> movements;
	private ArrayList<Integer> developerSizeInVersion;
	private ArrayList<CommitDate> allCommits;
	private ArrayList<VersionDate> versionDates;
	private int[] sizeRank = { 180, 130, 100, 75, 55, 40, 25, 15, 10, 5 };

	private String owner;
	
	
	public EvolveAnalysis(String projectName,String owner) {
		dh = new DataHelperImpl();
		this.projectName = projectName;
		this.owner = owner;
		
		versionDates = dh.getVersions(projectName,owner);
		versionDates = orderVersions(versionDates);
		
		allCommits = dh.getCommits(projectName,owner);
		developerSizeInVersion = new ArrayList<Integer>();

		developers = dh.getAllDeveloperNames(projectName,owner);
		// releases = dh.getReleaseNames(projectName);
		movements = new ArrayList<Movement>();

	}

	private String getNodesJson(String releaseName) {
		List<Node> nodes = new ArrayList<Node>();
		ArrayList<String> nodeNames = new ArrayList<String>();
		for (Movement mm : movements) {
			if (mm.getMove().equals("join")) {
				String dname = mm.getName();
				if (!nodeNames.contains(dname))
					nodeNames.add(dname);
			}
		}

		int i = 0;
		for (; i < nodeNames.size(); i++) {
			String developerName = nodeNames.get(i);
			int dsize = 0;
			 int index=getVersionDateNum(releaseName);
			 for(VersionDate vd:versionDates)
			 {  
				 if(vd.getOrder()<=index)
				 {
					 dsize+=dh.getSize(developerName, projectName, vd.getVersion(),this.owner);
				 }
			 }
			
			Node node = new Node(developerName, dsize);

			nodes.add(node);
		}
		sort(nodes,0, nodes.size() - 1);

		i=0;
		for (; i < nodes.size(); i++) {
			Node node = null;
			node = nodes.get(i);
			if (i < 10)
				node.setSize(sizeRank[i]);
			else
				node.setSize(sizeRank[9] + 30);

		}// 将size调整为比较好显示的数据
		JSONArray json = JSONArray.fromObject(nodes);
		String jsonStr = json.toString();
		return jsonStr;
	}
	
	
	private List<Node> sort(List<Node> ns,int low, int high) {
		List<Node> nodes=new ArrayList<Node>();
		nodes=ns;
		int l = low;
		int h = high;
		int povit = nodes.get(low).getSize();

		while (l < h) {
			while (l < h && nodes.get(h).getSize() <= povit)
				h--;
			if (l < h) {
				Node temp = nodes.get(h);
				nodes.set(h, nodes.get(l));
				nodes.set(l, temp);
				l++;

			}
			while (l < h && nodes.get(l).getSize() >= povit)
				l++;
			if (l < h) {
				Node temp = nodes.get(h);
				nodes.set(h, nodes.get(l));
				nodes.set(l, temp);
				h--;
			}

		}
	

		if (l > low)
			return sort(nodes,low, h - 1);
		if (h < high)
			return sort(nodes,l + 1, high);
		return nodes;
	}


	private boolean isLinked(ArrayList<String> filenames,
			ArrayList<String> filenamesToCompare) {
		boolean result = false;

		for (String file : filenames) {
			int l = file.split("/").length;
			String filename = file.split("/")[l - 1];
			String filePath = file.substring(0,
					file.length() - filename.length());

			for (String fileToComepare : filenamesToCompare) {
				int l2 = fileToComepare.split("/").length;
				String filename2 = fileToComepare.split("/")[l2 - 1];
				String filePath2 = fileToComepare.substring(0,
						fileToComepare.length() - filename2.length());

				// System.out.println("filePath:"+filePath);
				// System.out.println("filePath2:"+filePath2);
				if (filePath.equals(filePath2)) {
					result = true;
					break;
				}
			}
			if (result)
				break;
		}

		return result;
	}

	private String getLinksJson(String releaseName) {
		VersionDate vd = new VersionDate();
		vd = getVersionDate(releaseName);// get release date

		ArrayList<String> nodeNames = new ArrayList<String>();
		for (Movement mm : movements) {
			if (mm.getMove().equals("join")) {
				String dname = mm.getName();
				if (!nodeNames.contains(dname))
					nodeNames.add(dname);
			}
		}
		List<Link> links = new ArrayList<Link>();
		int i = 0;
		for (; i < nodeNames.size(); i++) {
			String developerName1 = nodeNames.get(i);
			ArrayList<String> files1 = new ArrayList<String>();
			Date now = new Date();
			SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd");
			String dtStr = sdf.format(now);// get instant time

			files1 = dh.getFiles(projectName, developerName1, vd.getDate(),
					dtStr,this.owner);
			int j = 0;
			for (; j < nodeNames.size(); j++) {
				if (j != i) {
					String developerName2 = nodeNames.get(j);
					ArrayList<String> files2 = new ArrayList<String>();

					files2 = dh.getFiles(projectName, developerName2,
							vd.getDate(), dtStr,this.owner);
					Link link = new Link(i, j);
					boolean linked = false;
					linked = isLinked(files1, files2);
					if (linked) {
						// System.out.println("Linked!!");
						if (links.size() == 0) {
							links.add(link);
						} else {

							boolean add = true;
							for (int p = 0; p < links.size(); p++) {
								Link l = links.get(p);
								int s = l.getSource();
								int t = l.getTarget();

								if (s == link.getTarget()
										&& t == link.getSource())
									add = false;
								if (t == link.getTarget()
										&& s == link.getSource())
									add = false;
							}
							if (add) {
								links.add(link);
							}
						}
					}
				}
			}
		}
		JSONArray json = JSONArray.fromObject(links);
		String jsonStr = json.toString();
		return jsonStr;

	}

	/**
	 * 从前到后的发布顺序排序版本
	 * 
	 * @param v
	 * @return
	 */
	private ArrayList<VersionDate> orderVersions(ArrayList<VersionDate> v) {
		ArrayList<VersionDate> versions = new ArrayList<VersionDate>();

		versions = v;
		int i = versions.size() - 1;
		for (; i > 0; --i) {
			int j = 0;
			for (; j < i; ++j) {

				if (versions.get(i).getOrder() < versions.get(j).getOrder()) {
					// System.out.println("ij:" + i + "," + j);
					VersionDate temp = versions.get(j);
					versions.set(j, versions.get(i));
					versions.set(i, temp);
					break;

				}
			}

		}
		
//		System.out.println(versions.size());
//		for(VersionDate vd:versions)
//		{
//			System.out.println(vd.getVersion()+":"+vd.getOrder());
//			System.out.println(vd.getVersion()+":"+vd.getDate());
//		}

		return versions;

	}

	/**
	 * 两次日期比较，是否前一个大于等于（近于）后一个
	 * 
	 * @param date
	 * @param dateToCompare
	 * @return
	 */
	private boolean DateIsGreater(String date, String dateToCompare) {
		int date1 = Integer.parseInt(date.replace("-", ""));
		int date2 = Integer.parseInt(dateToCompare.replace("-", ""));

		return date1 >= date2;
	}

	/*
	*//**
	 * 得到一个发布版本中所有的commit
	 * 
	 * @param commits
	 * @param release
	 * @return
	 */
	/*
	 * private ArrayList<CommitDate> CommitsInOneRelease( ArrayList<CommitDate>
	 * commits, String release) { ArrayList<CommitDate> commitsInOneRelease =
	 * new ArrayList<CommitDate>(); ArrayList<CommitDate> allCommits = new
	 * ArrayList<CommitDate>(); allCommits = commits; int i = 0; for (; i <
	 * allCommits.size(); i++) { if (DateIsGreater(release,
	 * allCommits.get(i).getDate())) { commitsInOneRelease.add(commits.get(i));
	 * }
	 * 
	 * } return commitsInOneRelease; }
	 */
	//
	/**
	 * 获得某个用户最近一次的迁移情况
	 * 
	 * @param developerName
	 * @return
	 */
	private Movement getLatestMoveOfOne(String developerName) {
		ArrayList<Movement> mms = new ArrayList<Movement>();

		for (Movement mm : movements) {
			if (mm.getName().equals(developerName)) {
				mms.add(mm);
			}
		}

		int i = mms.size() - 1;
		for (; i > 0; --i) {
			Movement mm1 = new Movement();
			mm1 = mms.get(i);
			int j = 0;
			for (; j < i; ++j) {
				Movement mm2 = mms.get(j);
				if (DateIsGreater(mm1.getDate(), mm2.getDate())) {
					Movement temp = mm2;
					mms.set(j, mm1);
					mms.set(i, temp);
				}
			}
		}

		if (mms.size() > 0) {

			return mms.get(0);
		} else
			return null;

	}

	/**
	 * 某开发者之前是否加入过项目
	 * 
	 * @param developerName
	 * @return
	 */
	private boolean isJoined(String developerName) {
		boolean result = false;
		for (Movement mm : movements) {
			if (mm.getName().equals(developerName)) {
				result = true;
				break;
			}
		}
		return result;
	}

	/**
	 * 获得从某个版本到今的所有VersionDate
	 * 
	 * @param release
	 * @return
	 */
	private ArrayList<VersionDate> getVersionDatesTillNow(String release) {
		ArrayList<VersionDate> versions = new ArrayList<VersionDate>();
		VersionDate versiondate = new VersionDate();
		versiondate = getVersionDate(release);
		for (VersionDate vd : versionDates) {

			if (DateIsGreater(vd.getDate(), versiondate.getDate())) {
				versions.add(vd);

			}

		}

		return versions;
	}

	/**
	 * 跟据版本号取得VersionDate实体
	 * 
	 * @param release
	 * @return VersionDate
	 */
	private VersionDate getVersionDate(String release) {
		VersionDate versiondate = new VersionDate();
		for (VersionDate vd : versionDates) {
			if (vd.getVersion().equals(release)) {
				versiondate = vd;
				break;
			}
		}

		return versiondate;
	}

	/**
	 * 跟据版本号取得VersionDate序号,是所有版本中的第几个版本
	 * 
	 * @param release
	 * @return VersionDate
	 */
	private int getVersionDateNum(String release) {
		int result = -1;
		int i = 0;
		for (; i < versionDates.size(); i++) {
			if (versionDates.get(i).getVersion().equals(release)) {
				result = i;
				break;
			}
		}

		return result;
	}

	/**
	 * 跟据版本号取得上一个VersionDate实体
	 * 
	 * @param release
	 * @return VersionDate
	 */

	private VersionDate getPreVersionDate(String release) {
		VersionDate versiondate = new VersionDate();

		for (VersionDate vd : versionDates) {
			if (vd.getVersion().equals(release)) {
				versiondate = vd;
				break;
			}
		}

		int i = 0;

		for (; i < versionDates.size(); i++) {
			if (versiondate.getVersion().equals(
					versionDates.get(i).getVersion())) {
				if (i != 0)
					versiondate = versionDates.get(i - 1);
				else
					versiondate = null;
			}

		}
		return versiondate;
	}

	/**
	 * 得到从某个版本发布时间到现在的所有CommitDate
	 * 
	 * @param release
	 * @return
	 */
	private ArrayList<CommitDate> getCommitFromVersionToNow(String release) {
		ArrayList<CommitDate> commits = new ArrayList<CommitDate>();

		VersionDate versiondate = new VersionDate();
		versiondate = getVersionDate(release);

		for (CommitDate cd : allCommits) {
			if (DateIsGreater(cd.getDate(), versiondate.getDate())) {
				commits.add(cd);
			}
		}

		return commits;

	}

	private String getMovementsJson(String release) {
		// 运行此方法 还会取得在所请求版本号的前一个版本发布时间往后所有的movement，保存在全局变量里。
		
		ArrayList<CommitDate> commits = new ArrayList<CommitDate>();
		ArrayList<VersionDate> versions = new ArrayList<VersionDate>();
		versions = getVersionDatesTillNow(release);// 得到包括请求在内，往后的所有开发版本号
		versions = orderVersions(versions);// 对其发布顺序从前到后排序
		int i = 0;
		for (; i <= versions.size(); i++) {
			allCommits = dh.getCommits(projectName,owner);

			if (i == versions.size()) {// 算最后一个版本之后的commits
				VersionDate versiondate = new VersionDate();
				versiondate = versions.get(i - 1);
				commits = getCommitFromVersionToNow(versiondate.getVersion());

			} else if (getVersionDateNum(versions.get(i).getVersion()) == 0) {// 如果请求的版本号是第一个版本，选返回所有commits再减去第一个版本发布时间后的所有commits
				commits = allCommits;
				VersionDate versiondate = new VersionDate();
				versiondate = versions.get(i);
				ArrayList<CommitDate> commitsToRemove = new ArrayList<CommitDate>();
				commitsToRemove = getCommitFromVersionToNow(versiondate
						.getVersion());// 第一个版本发布时间后的所有commits
				commits.removeAll(commitsToRemove);

			} else {// 否则返回在之前的一个版本发布时间往后的所有commit,再减去所请求版本发布时间后的所有commits

				VersionDate versiondate = new VersionDate();
				int versionNum = getVersionDateNum(versions.get(i).getVersion());
				versiondate = versionDates.get(versionNum - 1);
				commits = getCommitFromVersionToNow(versiondate.getVersion());
				versiondate = new VersionDate();
				versiondate = versions.get(i);
				ArrayList<CommitDate> commitsToRemove = new ArrayList<CommitDate>();
				commitsToRemove = getCommitFromVersionToNow(versiondate
						.getVersion());
				commits.removeAll(commitsToRemove);

			}

			developers = dh.getAllDeveloperNames(projectName,this.owner);
			ArrayList<String> developersInVersion = new ArrayList<String>();
			for (CommitDate cd : commits) {

				// --判断join迁移
				Movement mm = new Movement();
				mm.setName(cd.getName());
				mm.setMove("join");
				mm.setDate(cd.getDate().replace("-", ""));

				Movement latestMm = getLatestMoveOfOne(cd.getName());// 某开发者最近一次迁移情况

				if (latestMm != null) {
					// if(cd.getName().equals("a45"))
					// {
					// System.out.println(latestMm.getDate());
					// }
					// 之前参加项目
					if (latestMm.getMove().equals("leave")) {
						movements.add(mm);
						// 是leave就加入，如果之前是join无须加入
					}
				} else {
					movements.add(mm);
					// 之前没有参加项目则加入
				}

				if (!developersInVersion.contains(cd.getName()))
					developersInVersion.add(cd.getName());
			}
			developerSizeInVersion.add(developersInVersion.size());
			// --判断leave迁移

			ArrayList<String> developersNotInVersion = new ArrayList<String>();
			developersNotInVersion = developers;
			developersNotInVersion.removeAll(developersInVersion);// 获得此版本没有加入开发的开发者

			for (String developer : developersNotInVersion) {

				// 如果是第一个版本不存在leave于否
				if (getVersionDateNum(release) != 0) {
					// 首先开发者参与了才能离开
					if (isJoined(developer)) {
						Movement mm = new Movement();
						mm.setName(developer);
						mm.setMove("leave");
						mm.setDate(versions.get(i - 1).getDate()
								.replace("-", ""));
						movements.add(mm);
					}
				}
			}

		}
		JSONArray json = JSONArray.fromObject(movements);
		String jsonStr = json.toString();

		// for (Movement mm : movements) {
		// System.out.println(mm.getName() + ":" + mm.getMove() + ";"
		// + mm.getDate());
		// }
		return jsonStr;

	}

	/**
	 * 判断时间是否在两个版本发布时间之间，也就是属于某个版本
	 * 
	 * @param prevd
	 * @param vd
	 * @return
	 */
	private boolean dateIsBetweenTwoVersions(VersionDate prevd, VersionDate vd,
			String date) {
		boolean result = false;
		if (DateIsGreater(vd.getDate(), date)
				&& DateIsGreater(date, prevd.getDate())
				&& (!date.equals(prevd.getDate())))// 如果发布时间先于等于传入 且
													// 传入时间先于前一个版本发布时间 且
													// 传入时间不等于前一个版本发布时间
		{
			result = true;
		}
		return result;
	}

	/**
	 * try to get the count of Comments in One release
	 * 
	 * @param projectName
	 * @param releaseName
	 * @return
	 */
	private int getCommentCount(String projectName, String releaseName) {
		int commentCount = 0;
		ArrayList<Comment> comentList = new ArrayList<Comment>();
		comentList = dh.getComments(projectName,this.owner);
		if (releaseName.equals(versionDates.get(0).getVersion())) {// 如果是第一个版本，取第个版本之前的时间（包含）
			VersionDate vd = new VersionDate();
			vd = getVersionDate(releaseName);
			for (Comment comment : comentList) {
				if (DateIsGreater(vd.getDate(), comment.getDate()))
					commentCount++;
			}

		} else {

			VersionDate vd = new VersionDate();
			vd = getVersionDate(releaseName);
			VersionDate prevd = new VersionDate();
			prevd = getPreVersionDate(releaseName);

			for (Comment comment : comentList) {
				if (dateIsBetweenTwoVersions(prevd, vd, comment.getDate()))
					commentCount++;
			}
		}

		return commentCount;
	}

	/**
	 * try to get the count of Issues in One release
	 * 
	 * @param projectName
	 * @param releaseName
	 * @return
	 */
	private int getIssueCount(String projectName, String releaseName) {
		int issueCount = 0;
		ArrayList<usefuldata.Issue> issueList = new ArrayList<usefuldata.Issue>();
		issueList = dh.getIssues(projectName,this.owner);
		if (releaseName.equals(versionDates.get(0).getVersion())) {// 如果是第一个版本，取第个版本之前的时间（包含）
			VersionDate vd = new VersionDate();
			vd = getVersionDate(releaseName);
			for (usefuldata.Issue issue : issueList) {
				if (DateIsGreater(vd.getDate(), issue.getInjectedDate()))
					issueCount++;

			}
		} else {// 不是第一个版本，则都取与之前版本（不包含）之间的时间

			VersionDate vd = new VersionDate();
			vd = getVersionDate(releaseName);
			VersionDate prevd = new VersionDate();
			prevd = getPreVersionDate(releaseName);

			for (usefuldata.Issue issue : issueList) {
				if (dateIsBetweenTwoVersions(prevd, vd, issue.getInjectedDate()))
					issueCount++;

			}

		}
		return issueCount;
	}

	private String getRadarJson(String release) {
		ArrayList<Version> versions = new ArrayList<Version>();

		int maxDeveloperSize = 0;
		int maxCodes = 0;
		int maxCommits = 0;
		int maxComments = 0;
		int maxIssues = 0;

		ArrayList<CommitDate> commits = new ArrayList<CommitDate>();
		ArrayList<VersionDate> versiondates = new ArrayList<VersionDate>();
		versiondates = getVersionDatesTillNow(release);// 得到包括请求在内，往后的所有开发版本号
		versiondates = orderVersions(versiondates);// 对其发布顺序从前到后排序
		int j = 0;
		

		for (; j < versiondates.size(); j++) {

			// 计算issue comment commit codes developers 指标最大量
			allCommits = dh.getCommits(projectName,this.owner);

			if (getVersionDateNum(versiondates.get(j).getVersion()) == 0) {// 如果请求的版本号是第一个版本，选返回所有commits，再减去第一个版本发布时间后的所有commits
				commits = allCommits;
				VersionDate versiondate = new VersionDate();
				versiondate = versiondates.get(j);
				ArrayList<CommitDate> commitsToRemove = new ArrayList<CommitDate>();
				commitsToRemove = getCommitFromVersionToNow(versiondate
						.getVersion());
				commits.removeAll(commitsToRemove);

			} else {// 否则返回在之前的一个版本发布时间往后的所有commit,再减去所请求版本发布时间后的所有commits

				VersionDate versiondate = new VersionDate();
				int versionNum = getVersionDateNum(versiondates.get(j)
						.getVersion());
				versiondate = versionDates.get(versionNum - 1);
				commits = getCommitFromVersionToNow(versiondate.getVersion());
				versiondate = new VersionDate();
				versiondate = versiondates.get(j);
				ArrayList<CommitDate> commitsToRemove = new ArrayList<CommitDate>();
				commitsToRemove = getCommitFromVersionToNow(versiondate
						.getVersion());
				commits.removeAll(commitsToRemove);

			}

			String thisRelease = versiondates.get(j).getVersion();
			if (developerSizeInVersion.get(j) > maxDeveloperSize)
				maxDeveloperSize = developerSizeInVersion.get(j);

			if (dh.getCodes(projectName, thisRelease,this.owner) > maxCodes)
				maxCodes = dh.getCodes(projectName, thisRelease,this.owner);

			if (commits.size() > maxCommits)
				maxCommits = commits.size();

			if (getCommentCount(projectName, thisRelease) > maxComments)
				maxComments = getCommentCount(projectName, thisRelease);

			if (getIssueCount(projectName, thisRelease) > maxIssues)
			{
				
				maxIssues = getIssueCount(projectName, thisRelease);
//				System.out.println(thisRelease+":");
//				System.out.println("maxIssues:"+maxIssues);
//				System.out.println("Issues:"+getIssueCount(projectName, thisRelease));
			}

		
		}
		

		int i = 0;
		for (; i < versiondates.size(); i++) {
        
			allCommits = dh.getCommits(projectName,this.owner);

			if (getVersionDateNum(versiondates.get(i).getVersion()) == 0) {// 如果请求的版本号是第一个版本，选返回所有commits，再减去第一个版本发布时间后的所有commits
				commits = allCommits;
				VersionDate versiondate = new VersionDate();
				versiondate = versiondates.get(i);
				ArrayList<CommitDate> commitsToRemove = new ArrayList<CommitDate>();
				commitsToRemove = getCommitFromVersionToNow(versiondate
						.getVersion());
				commits.removeAll(commitsToRemove);

			} else {// 否则返回在之前的一个版本发布时间往后的所有commit,再减去所请求版本发布时间后的所有commits

				VersionDate versiondate = new VersionDate();
				int versionNum = getVersionDateNum(versiondates.get(i)
						.getVersion());
				versiondate = versionDates.get(versionNum - 1);
				commits = getCommitFromVersionToNow(versiondate.getVersion());
				versiondate = new VersionDate();
				versiondate = versiondates.get(i);
				ArrayList<CommitDate> commitsToRemove = new ArrayList<CommitDate>();
				commitsToRemove = getCommitFromVersionToNow(versiondate
						.getVersion());
				commits.removeAll(commitsToRemove);

			}

			VersionDate vd = new VersionDate();
			vd = versiondates.get(i);

			Version v = new Version();
			v.setDate(vd.getDate().replace("-", ""));
			v.setName(vd.getVersion());
			List<Radar> radars = new ArrayList<Radar>();
			String thisRelease = vd.getVersion();
			int developerValue = 0;
			if (maxDeveloperSize != 0)
				developerValue = (10 * developerSizeInVersion.get(i)
						/ maxDeveloperSize);
			int codeValue = 0;
			if (maxCodes != 0)
				codeValue = (10 * dh.getCodes(projectName, thisRelease,this.owner)
						/ maxCodes);
			int commitValue = 0;
			if (maxCommits != 0)
				commitValue = (10 * commits.size() / maxCommits);

			int commentValue = 0;
			if (maxComments != 0)
				commentValue = (10 * getCommentCount(projectName, thisRelease) / maxComments);
			int issueValue = 0;
			if (maxIssues != 0)
				issueValue = (10 * getIssueCount(projectName, thisRelease) / maxIssues);
//			System.out.println(thisRelease+":");
//			System.out.println("maxIssues:"+maxIssues);
//			System.out.println("Issues:"+getIssueCount(projectName, thisRelease));
//			System.out.println("issueValue:"+issueValue);

			radars.add(0, new Radar("developer", developerValue));
			// System.out.println(developerSizeInVersion.get(i));
			radars.add(1, new Radar("code", codeValue));
			radars.add(2, new Radar("commit", commitValue));
			radars.add(3, new Radar("comment", commentValue));
			radars.add(4, new Radar("issue", issueValue));

			// radars.add(1,"code",c)
			List<List<Radar>> radarL = new ArrayList<List<Radar>>();

			radarL.add(radars);
			v.setRadar(radarL);
			versions.add(v);

		}

		JSONArray json = JSONArray.fromObject(versions);
		String jsonStr = json.toString();
		// developerSizeInVersion = new ArrayList<Integer>();
		return jsonStr;
	}

	public String getEvolveJson(String release) {
		String movementsJson = getMovementsJson(release);

		String nodesJson = getNodesJson(release);
		String linksJson = getLinksJson(release);
		String radarJson = getRadarJson(release);

		versionDates = dh.getVersions(projectName,this.owner);
		versionDates = orderVersions(versionDates);

		allCommits = dh.getCommits(projectName,this.owner);

		developerSizeInVersion = new ArrayList<Integer>();

		developers = dh.getAllDeveloperNames(projectName,this.owner);
		// releases = dh.getReleaseNames(projectName);
		movements = new ArrayList<Movement>();

		return "{nodes:" + nodesJson + ",links:" + linksJson + ",movements:"
				+ movementsJson + ",version:" + radarJson + "}";

	}

	/*
	 * public static void main(String[] args) { for(int i=0;i<100;i++) {
	 * System.out.println(i); EvolveAnalysis ea = new
	 * EvolveAnalysis("projecName"); System.out.println(ea.getEvolveJson()); } }
	 */

}

C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\PackageDependency.java
package analysis;

import java.util.ArrayList;

public interface PackageDependency {
	
	/**
	 * 
	 * @param release_location
	 * @param all languages
	 * @return package structure with json format
	 */
	public ArrayList<String> getPakageDependency(ArrayList<String> release_location,ArrayList<String> languages);
	
	/**
	 * get main package structure
	 * @param release_location
	 * @param all languages
	 * @return package structure with json format
	 */
	public ArrayList<String> getMainPakageDependency(ArrayList<String> release_location,ArrayList<String> languages);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\PackageDependencyImpl.java
package analysis;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

import net.sf.json.JSONArray;
import usefuldata.PackageNode;

public class PackageDependencyImpl implements PackageDependency {
	private static ArrayList<String> directories = new ArrayList<String>();
	private static List<PackageNode> architectures = new ArrayList<PackageNode>();
	private static ArrayList<String> srcpaths = new ArrayList<String>();

	private static void readZipFile(String file, ArrayList<String> languages)
			throws Exception {

		ZipFile zf = new ZipFile(file);
		InputStream in = new BufferedInputStream(new FileInputStream(file));
		ZipInputStream zin = new ZipInputStream(in);

		ZipEntry ze;

		while ((ze = zin.getNextEntry()) != null) {
			if (!ze.isDirectory()) {

				String fnp = ze.getName();

				String[] fns = fnp.split("/");
				int l = fns.length;
				String fn = fns[l - 1];

				String[] ftypes = fn.split("\\.");
				String ftype = "";

				if (ftypes.length == 2) {
					ftype = ftypes[1];
				}

				String dir = "";

				boolean findLanguageType = false;

				for (String language : languages) {
					String lan = "";
					for (int i = 0; i < language.length(); i++) {
						lan = lan + language.substring(i, i + 1).toLowerCase();
					}

					switch (lan) {
					case "java":
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "groff":
						lan = "1";
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "javascript":
						lan = "js";
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "shell":
						lan = "sh";
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "ruby":
						lan = "rb";
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "postscript":
						if (ftype.equals("cmp") || ftype.equals("eps"))
							findLanguageType = true;
						break;
					case "perl":
						if (ftype.equals("pl") || ftype.equals("pm")
								|| ftype.equals("perl"))
							findLanguageType = true;
						break;
					case "html":
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "css":
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "r":
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "c":
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "php":
						if (lan.equals(ftype))
							findLanguageType = true;
						break;
					case "makefile":
						if (ftype.equals("bcp") || ftype.equals("fmk"))
							findLanguageType = true;
						break;
					case "c++":
						if (ftype.equals("asi") || ftype.equals("bcp")
								|| ftype.equals("c++") || ftype.equals("cc")
								|| ftype.equals("cls") || ftype.equals("cpp")
								|| ftype.equals("crf") || ftype.equals("cxx")
								|| ftype.equals("dbg") || ftype.equals("dpr")
								|| ftype.equals("dsk") || ftype.equals("h")
								|| ftype.equals("hpp") || ftype.equals("hxx"))
							findLanguageType = true;
						break;

					case "python":
						if (ftype.equals("py") || ftype.equals("pyc")
								|| ftype.equals("pyo") || ftype.equals("pyw")
								|| ftype.equals("pyd"))
							findLanguageType = true;
						break;

					case "objective-c":
						if (ftype.equals("c") || ftype.equals("cc")
								|| ftype.equals("ccp") || ftype.equals("h")
								|| ftype.equals("m") || ftype.equals("mm")
								|| ftype.equals("o"))
							findLanguageType = true;
						break;

					case "xslt":
						if (ftype.equals("xslt") || ftype.equals("xsl"))
							findLanguageType = true;
						break;
					case "clojure":
						if (ftype.equals("cjl"))
							findLanguageType = true;
						break;
					case "assembly":
						if (ftype.equals("asm"))
							findLanguageType = true;
						break;
					case "matlab":
						if (ftype.equals("m") || ftype.equals("mat"))
							findLanguageType = true;
						break;
					default:
						break;
					}

				}

				if (findLanguageType)

				{
					dir = fnp.substring(0, fnp.length() - fn.length());
				}

				if (!srcpaths.contains(dir))

					srcpaths.add(dir);

			}

		}

		// directories.addAll(srcpaths);
		zf.close();
		zin.close();
		// zin.closeEntry();
	}

	private static void buildArchitectures() {
		for (String str : srcpaths) {
			String[] fns = str.split("/");
			String dir = "";
			for (int i = 0; i < fns.length - 1; i++) {
				dir += fns[i] + "/";
				if (!directories.contains(dir))
					directories.add(dir);
			}
		}

		for (String str : directories) {
			// System.out.println(str);
			String path = str;
			String[] fns = path.split("/");
			int l = fns.length;
			String fn = fns[l - 1];
			PackageNode pn = new PackageNode(path, fn);
			architectures.add(pn);
		}

		for (int i = 0; i < architectures.size(); i++) {
			PackageNode pn = architectures.get(i);
			String path = pn.takePath();
			String[] fns = path.split("/");

			for (int j = 0; j < architectures.size(); j++) {

				PackageNode pn2 = architectures.get(j);
				String path2 = pn2.takePath();
				if (path2.length() > path.length()) {
					if (findPakage(path2) != -1) {

						String[] fns2 = path2.split("/");

						if (path2.contains(path)
								&& (fns2.length - fns.length) == 1) {
							pn.addChild(j);
						}

						architectures.set(i, pn);
					}
				}
			}
		}

		traverse(0);

	}

	private static void traverse(int i) {
		if (i < architectures.size()) {
			PackageNode pnc = architectures.get(i);
			if (pnc.takeCIndex() == null) {

			} else {
				for (Integer j : pnc.takeCIndex()) {
					traverse(j);
					PackageNode pnc2 = architectures.get(j);
					pnc.addChild(pnc2);
					architectures.set(i, pnc);
				}
			}
		}

	}

	private static int findPakage(String path) {
		int result = -1;

		for (int i = 0; i < architectures.size(); i++) {
			if (path.equals(architectures.get(i).takePath())) {
				result = i;
				break;
			}

		}

		return result;
	}

	private static String architecturesToJson() {
		// String json=JSONValue.toJSONString(architectures);

		if (architectures.size() != 0) {
			JSONArray json = JSONArray.fromObject(architectures.get(0));
			String resultStr = json.toString();
			directories = new ArrayList<String>();
			architectures = new ArrayList<PackageNode>();
			srcpaths = new ArrayList<String>();
			return resultStr.substring(1, resultStr.length() - 1);
		}

		return "";
	}

	public ArrayList<String> getPakageDependency(ArrayList<String> files,
			ArrayList<String> languages) {

		ArrayList<String> jsonStrs = new ArrayList<String>();

		for (String file : files) {
			try {
				if (!file.equals(""))
					readZipFile(file, languages);
			}

			catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			if (!file.equals("")) {
				buildArchitectures();

				String jsonStr = architecturesToJson();

				jsonStrs.add(jsonStr);
			}

		}

		return jsonStrs;

	}

	@Override
	public ArrayList<String> getMainPakageDependency(ArrayList<String> files,
			ArrayList<String> languages) {
		// TODO Auto-generated method stub

		return null;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\Relation.java
package analysis;


public interface Relation {
	/**
	 *  force_echarts
	 * @param developers
	 *            ' name
	 * @param projectName
	 * @param releaseName
	 * @return relations with json format
	 */
	public String getRelations();

	/**
	 * force_echarts
	 * @param developers
	 *            ' name
	 * @param projectName
	 * @param releaseName
	 * @return main relations with json format
	 */

	public String getMainRelations();

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\RelationImpl.java
package analysis;

import java.util.ArrayList;
import java.util.List;

import net.sf.json.JSONArray;
import usefuldata.Link;
import usefuldata.Node;

public class RelationImpl implements Relation {

	private DataHelper dh;
	private List<Node> nodes = new ArrayList<Node>();
	private List<Link> links = new ArrayList<Link>();
	private List<ArrayList<String>> files = new ArrayList<ArrayList<String>>();
	private ArrayList<String> developers = new ArrayList<String>();
	private String projectName = null;
	private String releaseName = null;
	private String owner = null;
	private int[] sizeRank = { 180, 130, 100, 75, 55, 40, 25, 15, 10, 5 };

	public RelationImpl(String projectName, String releaseName,String owner) {
		dh = new DataHelperImpl();
		this.developers = dh.getAllDeveloperNames(projectName,owner);
		this.projectName = projectName;
		this.releaseName = releaseName;
		this.owner = owner;
		setFiles(developers, projectName, releaseName,owner);

	}

	private void setFiles(ArrayList<String> developers, String projectName,
			String releaseName,String owner) {
		for (int i = 0; i < developers.size(); i++) {
			ArrayList<String> filenames = new ArrayList<String>();
			filenames = dh.getFiles(projectName, releaseName, developers.get(i),owner);
			files.add(filenames);

		}

	}

	private void sort(int low, int high) {
		int l = low;
		int h = high;
		int povit = nodes.get(low).getSize();

		while (l < h) {
			while (l < h && nodes.get(h).getSize() <= povit)
				h--;
			if (l < h) {
				Node temp = nodes.get(h);
				nodes.set(h, nodes.get(l));
				nodes.set(l, temp);
				l++;

			}
			while (l < h && nodes.get(l).getSize() >= povit)
				l++;
			if (l < h) {
				Node temp = nodes.get(h);
				nodes.set(h, nodes.get(l));
				nodes.set(l, temp);
				h--;
			}

		}

		if (l > low)
			sort(low, h - 1);
		if (h < high)
			sort(l + 1, high);
	}

	private int getNodeIndex(String name) {
		int result = -1;
		for (int i = 0; i < developers.size(); i++) {

			if (developers.get(i).equals(name)) {
				result = i;
			}

		}
		return result;
	}

	@Override
	public String getRelations() {
		for (int i = 0; i < developers.size(); i++) {
			int dsize = dh.getSize(developers.get(i), projectName, releaseName,this.owner);

			Node node = new Node(developers.get(i), dsize);
			nodes.add(node);

			ArrayList<String> filenames = new ArrayList<String>();
			filenames = files.get(i);

			for (int j = 0; j < developers.size(); j++) {
				if (i != j) {
					ArrayList<String> filenamesToCompare = new ArrayList<String>();
					filenamesToCompare = files.get(j);
					if (isLinked(filenames, filenamesToCompare)) {
						Link link = new Link(i, j);
						addLink(link);
					}
				}

			}

		}

		sort(0, nodes.size() - 1);

		for (int i = 0; i < nodes.size(); i++) {
			Node node = null;
			node = nodes.get(i);
			if (i < 10)
				node.setSize(sizeRank[i]);
			else
				node.setSize(sizeRank[9] + 30);

		}// 将size调整为比较好显示的数据

		JSONArray jsonNode = JSONArray.fromObject(nodes);
		JSONArray jsonLink = JSONArray.fromObject(links);
		String resultStr = "{ 'nodes': " + jsonNode.toString() + ", 'links':"
				+ jsonLink.toString() + "}";

		nodes = new ArrayList<Node>();
		links = new ArrayList<Link>();

		return resultStr;
	}

	private void addLink(Link link) {
		if (links.size() == 0) {
			links.add(link);
		} else {

			boolean add = true;
			for (int i = 0; i < links.size(); i++) {
				Link l = links.get(i);
				int s = l.getSource();
				int t = l.getTarget();

				if (s == link.getTarget() && t == link.getSource())
					add = false;
				if (t == link.getTarget() && s == link.getSource())
					add = false;
			}
			if (add) {
				links.add(link);
			}
		}
	}

	private boolean isLinked(ArrayList<String> filenames,
			ArrayList<String> filenamesToCompare) {
		boolean result = false;

		for (String file : filenames) {
			int l = file.split("/").length;
			String filename = file.split("/")[l - 1];
			String filePath = file.substring(0,
					file.length() - filename.length());

			for (String fileToComepare : filenamesToCompare) {
				int l2 = fileToComepare.split("/").length;
				String filename2 = fileToComepare.split("/")[l2 - 1];
				String filePath2 = fileToComepare.substring(0,
						fileToComepare.length() - filename2.length());

				if (filePath.equals(filePath2)) {
					result = true;
					break;
				}
			}
			if (result)
				break;
		}

		return result;
	}

	@Override
	public String getMainRelations() {

		for (int i = 0; i < developers.size(); i++) {
			int dsize = dh.getSize(developers.get(i), projectName, releaseName,this.owner);
			Node node = new Node(developers.get(i), dsize);

			nodes.add(node);
		}

		sort(0, nodes.size() - 1);

		int length = nodes.size();
		if (length > 10)
			length = 10;

		for (int i = 0; i < length; i++) {
			ArrayList<String> filenames = new ArrayList<String>();
			filenames = files.get(getNodeIndex(nodes.get(i).getName()));

			for (int j = 0; j < length; j++) {
				if (i != j) {

					ArrayList<String> filenamesToCompare = new ArrayList<String>();

					filenamesToCompare = files.get(getNodeIndex(nodes.get(j)
							.getName()));

					if (isLinked(filenames, filenamesToCompare)) {
						Link link = new Link(getNodeIndex(nodes.get(i)
								.getName()), getNodeIndex(nodes.get(j)
								.getName()));
						addLink(link);
					}
				}

			}
		}

		for (int i = 0; i < nodes.size(); i++) {
			Node node = null;
			node = nodes.get(i);
			if (i < 10)
				node.setSize(sizeRank[i]);
			else
				node.setSize(sizeRank[9] + 30);

		}// 将size调整为比较好显示的数据

		JSONArray jsonNode = JSONArray.fromObject(nodes);
		JSONArray jsonLink = JSONArray.fromObject(links);

		String resultStr = "{ 'nodes': " + jsonNode.toString() + ", 'links':"
				+ jsonLink.toString() + "}";
		nodes = new ArrayList<Node>();
		links = new ArrayList<Link>();
		return resultStr;

	}


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\TestFilesStatistics.java
package analysis;

public interface TestFilesStatistics 
{
	/**
	 * @param release filePath
	 * @return testfilecount
	 */
	public int getTestFilesCount(String filePath);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\TestFilesStatisticsImpl.java
package analysis;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

public class TestFilesStatisticsImpl implements TestFilesStatistics
{

	private static int count=0;
	@Override
	public int getTestFilesCount(String filePath) {

		try {
			readZipFile(filePath);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return count;
	}

	private static void readZipFile(String file) throws Exception {
		ZipFile zf = new ZipFile(file);
		InputStream in = new BufferedInputStream(new FileInputStream(file));
		ZipInputStream zin = new ZipInputStream(in);
		ZipEntry ze;
        count=0;

		while ((ze = zin.getNextEntry()) != null) {
			if (!ze.isDirectory()) {
				String fnp = ze.getName();
				if(fnp.indexOf("test")!=-1)
				{
					count++;
				}

			}

		}
		
		zin.close();
		zf.close();
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\analysis\VitalityCount.java
package analysis;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import usefuldata.Vitality;
import util.Dates;
import dao.DeveloperDao;
import dao.ProjectDao;
import dao.ReleaseDao;
import factory.DaoFactory;

/**
 * this method used to compute vitality with 
 * crawled rawVitality  
 * @author guanjun
 *
 */
public class VitalityCount {
	
	private ReleaseDao releaseDao;
	private ProjectDao projectDao;
	private DeveloperDao developerDao;
	
	public VitalityCount(){
		releaseDao = DaoFactory.getReleaseDao();
		projectDao = DaoFactory.getProjectDao();
		developerDao = DaoFactory.getDeveloperDao();
	}
	
	public List<Vitality> handleVitalityRelease(List<Vitality> rawVitality,String projectName,String developer,String owner){
		int project_id = projectDao.getProject(owner,projectName).getId();
		int developer_id = developerDao.findDeveloper(developer).getId();
		
		List<usefuldata.Release> releases = releaseDao.getAllRelease(project_id);
		Map<String,String> dateMap = new HashMap<String,String>();
		for(int i = 0;i<releases.size();i++){
			String tagName = releases.get(i).getName();
			String tagDate = releases.get(i).getDate();
			
			dateMap.put(tagName, tagDate);
		}
		
		ArrayList<String> sorted_release = Dates.dateSort(dateMap);
		
		List<Vitality> results = new ArrayList<Vitality>();
		int position = 0;
		for(int j = 0;j<rawVitality.size();j++){
			rawVitality.get(j).setProject_id(project_id);
			rawVitality.get(j).setDeveloper_id(developer_id);;
			
			position = Dates.getDateIndex(rawVitality.get(j).getDate(),dateMap);
			
			if(position >= sorted_release.size())
				 position = sorted_release.size() - 1;
			
			String tagBelong = sorted_release.get(position);
			
			for(usefuldata.Release selectedRel:releases){
				if(selectedRel.getName().equals(tagBelong)){
					rawVitality.get(j).setRelease_id(selectedRel.getId());
					break;
				}
			}
			
			results.add(rawVitality.get(j));
		}
		
		return results;
	}
	

	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\crawler\CrawlController.java
package crawler;

import java.util.ArrayList;
import java.util.List;

import entity.Contributor;
import entity.Crawlindex;
import entity.Project;
import entity.User;
import http.HttpModule;

import com.google.inject.Guice;
import com.google.inject.Injector;

import search.MetaSearchGitHub;
import search.SearchModule;

public class CrawlController {
	private MetaSearchGitHub MetasearchGitHub;
	private String projectName;
	private String projectOwner;
	private int project_id;
	
	private Crawlindex crawlIndex;
	
	public CrawlController(String projectName,String projectOwner){
		Injector injector = Guice.createInjector(new SearchModule(), new HttpModule());
		MetasearchGitHub = injector.getInstance(MetaSearchGitHub.class);
		this.projectName = projectName;
		this.projectOwner = projectOwner;
	}
	
	public entity.Project getProject(){
		try{
			Project p = MetasearchGitHub.getProject(projectName, projectOwner);
			if(p!=null){
				this.project_id = p.getId();
				return p;
			}else
				return null;
			}catch(Exception e){
				e.printStackTrace();
			}
		return null;
	}
	
	public List<Contributor> getContributors(){
		try{
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<Contributor> cts = MetasearchGitHub.getAllProjectContributors(p);
			if(cts!=null){
				return cts;
			}else
				return null;
			}catch(Exception e){
				e.printStackTrace();
			}
		return null;
	}
	
	public List<Contributor> getContributors(int contributor_page){
		try{
			if(contributor_page == 0)
				contributor_page = 1;
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<Contributor> cts = MetasearchGitHub.getAllProjectContributors(p,contributor_page);
			if(cts!=null){
				return cts;
			}else
				return null;
			}catch(Exception e){
				e.printStackTrace();
			}
		return null;		
	}
		
	public List<entity.Commit> getCommits(String developer){
		try {
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<entity.Commit> commits = MetasearchGitHub.getProjectCommitsByCommiter(p,developer);
			if(commits!=null)
				return commits;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	
	public List<entity.Commit> getCommits(int commit_page){
		try {
			if(commit_page == 0)
				commit_page = 1;
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<entity.Commit> commits = MetasearchGitHub.getProjectCommits(p, commit_page);
			if(commits!=null)
				return commits;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
		
	public List<entity.Issue> getIssues(){
		try {
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<entity.Issue> issues = MetasearchGitHub.getAllProjectIssues(p);
			if(issues!=null)
				return issues;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
		
	}
	
	public List<entity.Issue> getIssues(int issue_page){
		try {
			if(issue_page == 0)
				issue_page = 1;
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<entity.Issue> issues = MetasearchGitHub.getAllProjectIssues(p,issue_page);
			if(issues!=null)
				return issues;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
		
	}
	
	public List<entity.UnPublishedRelease> getUnPublishedRelease(){
		try {
			List<entity.UnPublishedRelease> upr = MetasearchGitHub.getAllUnPublishedRelease(projectOwner, projectName);
			if(upr!=null)
				return upr;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
		
	}
	
	public List<entity.UnPublishedRelease> getUnPublishedRelease(int upr_page){
		try {
			if(upr_page == 0)
				upr_page = 1;
			List<entity.UnPublishedRelease> upr = MetasearchGitHub.getAllUnPublishedRelease(projectOwner, projectName,upr_page);
			if(upr!=null)
				return upr;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
		
	}
	
	public List<entity.CommitFile> getCommitFile(String sha){
		try {
			List<entity.CommitFile> cmfs = MetasearchGitHub.getCommitFiles(projectOwner, projectName, sha);
			if(cmfs!=null)
				return cmfs;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	
	public List<entity.Comment> getComments(){
		try{
			List<entity.Comment> comments = MetasearchGitHub.getComments(projectName, projectOwner);
			if(comments!=null)
				return comments;
		}catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public List<entity.Comment> getComments(int comment_page){
		try{
			if(comment_page == 0)
				comment_page = 1;
			List<entity.Comment> comments = MetasearchGitHub.getComments(projectName, projectOwner,comment_page);
			if(comments!=null)
				return comments;
		}catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	
	public entity.User getUser(String login){
		try{
			entity.User user = MetasearchGitHub.getUser(login);
			if(user!=null)
				return user;
		}catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	
	public List<entity.User> getAllUsers(List<String> logins){
		List<entity.User> users = new ArrayList<entity.User>();
		for(String login:logins){
			User u = MetasearchGitHub.getUser(login);
			users.add(u);
		}
		
		return users;
	}
	
	public List<entity.Release> getPublishedRelease(){
		try{
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<entity.Release> releases = MetasearchGitHub.getAllProjectReleases(p);
			if(releases!=null)
				return releases;
		}catch (Exception e) {
			e.printStackTrace();
		}
		return null;
		
	}

	public List<entity.Release> getPublishedRelease(int pbr_page){
		try{
			if(pbr_page == 0)
				pbr_page = 1;
			entity.Project p = new Project(new User(projectOwner), projectName);
			List<entity.Release> releases = MetasearchGitHub.getAllProjectReleases(p,pbr_page);
			if(releases!=null)
				return releases;
		}catch (Exception e) {
			e.printStackTrace();
		}
		return null;
		
	}
	
	
	public MetaSearchGitHub getMetasearchGitHub() {
		return MetasearchGitHub;
	}

	public void setMetasearchGitHub(MetaSearchGitHub metasearchGitHub) {
		MetasearchGitHub = metasearchGitHub;
	}

	public String getProjectName() {
		return projectName;
	}

	public void setProjectName(String projectName) {
		this.projectName = projectName;
	}

	public String getProjectOwner() {
		return projectOwner;
	}

	public void setProjectOwner(String projectOwner) {
		this.projectOwner = projectOwner;
	}

	public Crawlindex getCrawlIndex() {
		return crawlIndex;
	}

	public void setCrawlIndex(Crawlindex crawlIndex) {
		this.crawlIndex = crawlIndex;
	}

	public int getProject_id() {
		return project_id;
	}

	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\crawler\CrawlGitHub.java
package crawler;

import java.io.File;
import java.io.IOException;
import java.net.URL;

import org.apache.commons.io.FileUtils;

import entity.Project;
import scmclient.GitClient;

import com.google.inject.Inject;


public class CrawlGitHub extends ForgeCrawler{
	
	private final GitClient gitClient;
	private final File destinationFolder;

	@Inject
	public CrawlGitHub(GitClient gitClient, File destinationFolder) {
		this.gitClient = gitClient;
		this.destinationFolder = destinationFolder;
	}

	@Override
	public File downloadProject(Project project) throws DownloadException {
		String projectName = project.getName();
		String projectUrl = project.getCheckoutURL();
		File projectDestinationFolder = new File(destinationFolder, projectName);

		System.out.println(String.format("Downloading %s project..", project.getName()));

		try {
			this.gitClient.clone(projectUrl, projectDestinationFolder);
			System.out.println(String.format("Done! The project is available at %s", projectDestinationFolder.getAbsolutePath()));
			return projectDestinationFolder;
		} catch (Exception e) {
			String error = String.format("Unable to download %s (%s) project", project.getName(), project.getCheckoutURL());
			System.out.println(error);
			throw new DownloadException(error);
		}
	}
	
	/**
	 * use Apache common IO to download
	 * @param httpUrl
	 * @param path
	 * @param saveFile
	 * @return 
	 */
	public boolean httpDownload(String httpUrl,String path,String saveFile){  
	      
		File file = new File(path + saveFile);
		try{
		FileUtils.copyURLToFile(new URL(httpUrl),file);
		System.out.println("now downloading ... " + saveFile);
		}catch(IOException ioe){
			try {
				//wait 5 minutes
				Thread.sleep(1000 * 60 * 5);
				httpDownload(httpUrl,path,saveFile);
			
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		catch(Exception e){
			e.printStackTrace();
			return false;
		}
		
		System.out.println(saveFile + " completed!");
		return true;
	   }
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\crawler\CrawlModule.java
package crawler;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import scmclient.GitClient;
import util.FileHelper;
import entity.Comment;
import entity.Commit;
import entity.CommitFile;
import entity.Contributor;
import entity.Crawlindex;
import entity.Issue;
import entity.IssueLabel;
import entity.Language;
import entity.License;
import entity.Milestone;
import entity.Project;
import entity.PullRequest;
import entity.Release;
import entity.UnPublishedRelease;
import entity.User;
import factory.MetaDaoFactory;

/**
 * crawl all data to server
 * @author guanjun
 *
 */
public class CrawlModule extends DataSource{
	private CrawlController crawlController;
	private CrawlGitHub crawlGitHub;
	private File destinationFile;
	
	private String latest_path;
	private String unpublished_path;//filepath for unpublished_releases
	private ArrayList<String> unpublished_file = new ArrayList<String>();//filename for unpublished_releases
	private ArrayList<String> release_location = new ArrayList<String>();
	
	private List<Comment> comments;
	private List<Contributor> contributors;
	private List<Issue> issues;
	private IssueLabel issuelabel;
	private Language language;
	private License license;
	private Milestone milestone;
	private Project project;
	private PullRequest pullrequest;
	private List<Release> releases;
	private List<UnPublishedRelease> unpublish_releases;
	private List<User> users;
	
	private int commit_page;
	
	private Crawlindex IncrawlIndex;
	private Crawlindex OutcrawlIndex;
	
	private String projectName;
	private String owner;
	
	public CrawlModule(String projectName,String projectOwner,String destinationFolder){
		this.crawlController = new CrawlController(projectName,projectOwner);
		destinationFile = new File(destinationFolder);
		crawlGitHub= new CrawlGitHub(new GitClient(), destinationFile);
				
		this.projectName = projectName;
		this.owner = projectOwner;
		Project p = MetaDaoFactory.getProjectDao().getProject(projectOwner, projectName);
				
		if(p == null)
			this.IncrawlIndex = null;
		else{
			this.IncrawlIndex = MetaDaoFactory.getCrawlindexDao().getCrawlindex(p.getId());
		}
			
	}	
	
	/**
	 * crawl all info and download releases to server
	 */
	public void getData(){
		int release_idx = 0;
		
		if(this.IncrawlIndex == null){
			
			CrawlProjectInfo();
			CrawlCommitsToDB(1);
				
			downLoadOneProject();		
			downLoadUnpublish_releases(this.getUnpublish_releases());						
			release_idx = this.getUnpublish_releases().size();
		}
		
		else{	
			System.out.println("trying to update this project info...");
			
			CrawlProjectInfo();
			CrawlCommitsToDB(this.IncrawlIndex.getCommit_page());
			
			downLoadOneProject();
			
			List<UnPublishedRelease> uprs = this.getUnpublish_releases();
			List<UnPublishedRelease> upr = new ArrayList<UnPublishedRelease>();
			int i = this.IncrawlIndex.getRelease_idx()-1;
			if(i<0)
				i = 0;
			
			for(;i<uprs.size();i++){
				upr.add(uprs.get(i));			
			}
			
			release_idx = uprs.size();
			if(!upr.isEmpty())
				downLoadUnpublish_releases(upr);
		}
		
		/* 
		   milestone pullrequest_page not yet
		   update crawlIndex
		*/
		
		this.OutcrawlIndex = crawlController.getMetasearchGitHub().getCrawlIndex();
		this.OutcrawlIndex.setCommit_page(this.commit_page);
		this.OutcrawlIndex.setUser_page(this.OutcrawlIndex.getContributor_page());
		this.OutcrawlIndex.setProject_id(crawlController.getProject_id());
		this.OutcrawlIndex.setRelease_idx(release_idx);
				
	}
	
	
	public void CrawlProjectInfo(){
		if(this.IncrawlIndex == null){
			project = crawlController.getProject();
			
			//sometimes the language is UpperCase
			project.setLanguage(project.getLanguage().toLowerCase());
			contributors = crawlController.getContributors();
			issues = crawlController.getIssues();
			comments = crawlController.getComments();
			releases = crawlController.getPublishedRelease();
			unpublish_releases = crawlController.getUnPublishedRelease();		
			users = crawlController.getAllUsers(this.getLogins(contributors));
		}else{
			project = crawlController.getProject();
						
			project.setLanguage(project.getLanguage().toLowerCase());
			contributors = crawlController.getContributors(IncrawlIndex.getContributor_page());
			issues = crawlController.getIssues(IncrawlIndex.getIssue_page());
			comments = crawlController.getComments(IncrawlIndex.getComment_page());
			releases = crawlController.getPublishedRelease(IncrawlIndex.getRelease_page());
			unpublish_releases = crawlController.getUnPublishedRelease(IncrawlIndex.getUpbrelease_page());		
			users = crawlController.getAllUsers(this.getLogins(contributors));	
		}		
	}
	
	public void CrawlCommitsToDB(){
		int num = 0;
		for(Contributor c:contributors){
			List<Commit> commits = crawlController.getCommits(c.getLogin());	
			num += commits.size();
			for(Commit commit:commits){
				MetaDaoFactory.getCommitDao().addCommit(commit, project.getId());
				List<CommitFile> cmf = crawlController.getCommitFile(commit.getSha());
				if(cmf != null)
					MetaDaoFactory.getCommitFileDao().addCommitFiles(cmf);
			}		
		}	
		if(num < 80){
			this.commit_page = 1;
		}else if(num == 80){
			this.commit_page = 2;
		}else{
			this.commit_page = num/80 + 1;
		}
		
		
	}
	
	public void CrawlCommitsToDB(int commit_page){
		List<Commit> commits = crawlController.getCommits(commit_page);			
		int num = commits.size();
		for(Commit commit:commits){
			int flag = MetaDaoFactory.getCommitDao().CheckaddCommit(commit, project.getId(),commit.getCommiter().getId());
			if(flag == 1){
				List<CommitFile> cmf = crawlController.getCommitFile(commit.getSha());
				if(cmf != null)
					MetaDaoFactory.getCommitFileDao().addCommitFiles(cmf);
			}
		}
		
		if(num < 80){
			this.commit_page = 1;
		}else if(num == 80){
			this.commit_page = 2;
		}else{
			this.commit_page = num/80 + 1;
		}
	}
	
	public void downLoadOneProject(){
		String projectName = crawlController.getProjectName();
		String checkoutURL = "https://github.com/" + crawlController.getProjectOwner() + "/" + projectName;
		Project p = new Project(projectName, "description", checkoutURL);
		if(destinationFile.exists())
			FileHelper.deleteDirectory(destinationFile.getAbsolutePath());	
		try{
			latest_path = crawlGitHub.downloadProject(p).getAbsolutePath();
		}catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	public void downLoadUnpublish_releases(List<UnPublishedRelease> unpublish_releases){
		String projectName = crawlController.getProjectName();
		String owner = crawlController.getProjectOwner();
		unpublished_path = "Downloads/"+owner+"_"+projectName +"/" ;
		
		for(UnPublishedRelease upr:unpublish_releases){
			String httpurl = upr.getZipball_url();
			crawlGitHub.httpDownload(httpurl, unpublished_path, upr.getName() + ".zip");
			unpublished_file.add(upr.getName() + ".zip");
			
			release_location.add(unpublished_path + upr.getName() + ".zip");
		}
		
	}
	
	public List<String> getLogins(List<Contributor> contributors){
		List<String> logins = new ArrayList<String>();
		for(Contributor ctb:contributors){
			String login = ctb.getLogin();
			logins.add(login);
		}
		return logins;
	}
		
	public String getLatest_path(){
		return this.latest_path;
	}

	public CrawlController getCrawlController() {
		return crawlController;
	}

	public void setCrawlController(CrawlController crawlController) {
		this.crawlController = crawlController;
	}

	public CrawlGitHub getCrawlGitHub() {
		return crawlGitHub;
	}

	public void setCrawlGitHub(CrawlGitHub crawlGitHub) {
		this.crawlGitHub = crawlGitHub;
	}

	public File getDestinationFile() {
		return destinationFile;
	}

	public void setDestinationFile(File destinationFile) {
		this.destinationFile = destinationFile;
	}

	public List<Comment> getComments() {
		return comments;
	}

	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}

	public List<Contributor> getContributors() {
		return contributors;
	}

	public void setContributors(List<Contributor> contributors) {
		this.contributors = contributors;
	}

	public List<Issue> getIssues() {
		return issues;
	}

	public void setIssues(List<Issue> issues) {
		this.issues = issues;
	}

	public IssueLabel getIssuelabel() {
		return issuelabel;
	}

	public void setIssuelabel(IssueLabel issuelabel) {
		this.issuelabel = issuelabel;
	}

	public Language getLanguage() {
		return language;
	}

	public void setLanguage(Language language) {
		this.language = language;
	}

	public License getLicense() {
		return license;
	}

	public void setLicense(License license) {
		this.license = license;
	}

	public Milestone getMilestone() {
		return milestone;
	}

	public void setMilestone(Milestone milestone) {
		this.milestone = milestone;
	}

	public Project getProject() {
		return project;
	}

	public void setProject(Project project) {
		this.project = project;
	}

	public PullRequest getPullrequest() {
		return pullrequest;
	}

	public void setPullrequest(PullRequest pullrequest) {
		this.pullrequest = pullrequest;
	}

	public List<Release> getReleases() {
		return releases;
	}

	public void setReleases(List<Release> releases) {
		this.releases = releases;
	}

	public List<UnPublishedRelease> getUnpublish_releases() {
		return unpublish_releases;
	}

	public void setUnpublish_releases(List<UnPublishedRelease> unpublish_releases) {
		this.unpublish_releases = unpublish_releases;
	}

	public List<User> getUsers() {
		return users;
	}

	public void setUsers(List<User> users) {
		this.users = users;
	}

	public void setLatest_path(String latest_path) {
		this.latest_path = latest_path;
	}

	public String getUnpublished_path() {
		return unpublished_path;
	}

	public void setUnpublished_path(String unpublished_path) {
		this.unpublished_path = unpublished_path;
	}

	public ArrayList<String> getUnpublished_file() {
		return unpublished_file;
	}

	public void setUnpublished_file(ArrayList<String> unpublished_file) {
		this.unpublished_file = unpublished_file;
	}

	public ArrayList<String> getRelease_location() {
		return release_location;
	}

	public void setRelease_location(ArrayList<String> release_location) {
		this.release_location = release_location;
	}

	public ArrayList<String> developers(){
		ArrayList<String> developers = new ArrayList<String>();
		for(Contributor b:this.contributors)
			developers.add(b.getLogin());
		
		return developers;
	}
	
	public Map<String, String> date_map(){
		Map<String, String> date_map = new HashMap<String, String>();
		for(UnPublishedRelease upr:this.unpublish_releases)
			date_map.put(upr.getName(), upr.getDate());
		
		return date_map;
	}
	
	public ArrayList<String> ReleaseName(){
		ArrayList<String> releaseName = new ArrayList<String> ();
		for(int i = 0;i<this.unpublish_releases.size();i++)
			releaseName.add(this.unpublish_releases.get(i).getName());
		
		return releaseName;
	}
	
	public ArrayList<usefuldata.Developer> Developers(){
		ArrayList<usefuldata.Developer> developers = new ArrayList<usefuldata.Developer>();
		for(int i = 0;i<this.users.size();i++){
			developers.add(this.users.get(i).DeveloperTransform());
		}
		return developers;
	}
	
	public List<String> allReleaseDates(){
		List<String> dates = new ArrayList<String>();
		for(int i = 0;i<this.unpublish_releases.size();i++)
			dates.add(this.unpublish_releases.get(i).getDate());
		
		return dates;
	}

	public int getCommit_page() {
		return commit_page;
	}

	public void setCommit_page(int commit_page) {
		this.commit_page = commit_page;
	}

	public Crawlindex getIncrawlIndex() {
		return IncrawlIndex;
	}

	public void setIncrawlIndex(Crawlindex incrawlIndex) {
		IncrawlIndex = incrawlIndex;
	}

	public Crawlindex getOutcrawlIndex() {
		return OutcrawlIndex;
	}

	public void setOutcrawlIndex(Crawlindex outcrawlIndex) {
		OutcrawlIndex = outcrawlIndex;
	}

	public Crawlindex getCrawlIndex() {
		return OutcrawlIndex;
	}

	@Override
	public Crawlindex getOutIndex() {
		return OutcrawlIndex;
	}

	@Override
	public Crawlindex getInIndex() {
		return IncrawlIndex;
	}
	
	public String getLatest_location() {
		return latest_path;
	}

	public String getProjectName() {
		return projectName;
	}

	public void setProjectName(String projectName) {
		this.projectName = projectName;
	}

	public String getOwner() {
		return owner;
	}

	public void setOwner(String owner) {
		this.owner = owner;
	}

	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\crawler\DataSource.java
package crawler;

import java.util.ArrayList;
import java.util.List;

import entity.Comment;
import entity.Contributor;
import entity.Crawlindex;
import entity.Issue;
import entity.IssueLabel;
import entity.Language;
import entity.License;
import entity.Milestone;
import entity.Project;
import entity.PullRequest;
import entity.Release;
import entity.UnPublishedRelease;
import entity.User;

public abstract class DataSource {
	private String projectName;
	private String owner;
	private String destinationFolder;
	
	private ArrayList<String> release_location;
	private String latest_location;
	private List<Comment> comments;
	private List<Contributor> contributors;
	private List<Issue> issues;
	private IssueLabel issuelabel;
	private Language language;
	private License license;
	private Milestone milestone;
	private Project project;
	private PullRequest pullrequest;
	private List<Release> releases;
	private List<UnPublishedRelease> unpublish_releases;
	private List<User> users;
		
	public DataSource(){
		super();
	}
	
	public DataSource(String projectName, String owner, String destinationFolder) {
		super();
		this.projectName = projectName;
		this.owner = owner;
		this.destinationFolder = destinationFolder;
	}

	/**
	 * get metadata to attributes
	 */
	public abstract void getData();

	public ArrayList<String> getRelease_location() {
		return release_location;
	}

	public void setRelease_location(ArrayList<String> release_location) {
		this.release_location = release_location;
	}

	public String getLatest_location() {
		return latest_location;
	}

	public void setLatest_location(String latest_location) {
		this.latest_location = latest_location;
	}

	public List<Comment> getComments() {
		return comments;
	}

	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}

	public List<Contributor> getContributors() {
		return contributors;
	}

	public void setContributors(List<Contributor> contributors) {
		this.contributors = contributors;
	}

	public List<Issue> getIssues() {
		return issues;
	}

	public void setIssues(List<Issue> issues) {
		this.issues = issues;
	}

	public IssueLabel getIssuelabel() {
		return issuelabel;
	}

	public void setIssuelabel(IssueLabel issuelabel) {
		this.issuelabel = issuelabel;
	}

	public Language getLanguage() {
		return language;
	}

	public void setLanguage(Language language) {
		this.language = language;
	}

	public License getLicense() {
		return license;
	}

	public void setLicense(License license) {
		this.license = license;
	}

	public Milestone getMilestone() {
		return milestone;
	}

	public void setMilestone(Milestone milestone) {
		this.milestone = milestone;
	}

	public Project getProject() {
		return project;
	}

	public void setProject(Project project) {
		this.project = project;
	}

	public PullRequest getPullrequest() {
		return pullrequest;
	}

	public void setPullrequest(PullRequest pullrequest) {
		this.pullrequest = pullrequest;
	}

	public List<Release> getReleases() {
		return releases;
	}

	public void setReleases(List<Release> releases) {
		this.releases = releases;
	}

	public List<UnPublishedRelease> getUnpublish_releases() {
		return unpublish_releases;
	}

	public void setUnpublish_releases(List<UnPublishedRelease> unpublish_releases) {
		this.unpublish_releases = unpublish_releases;
	}

	public List<User> getUsers() {
		return users;
	}

	public void setUsers(List<User> users) {
		this.users = users;
	}

	public String getProjectName() {
		return projectName;
	}

	public void setProjectName(String projectName) {
		this.projectName = projectName;
	}

	public String getOwner() {
		return owner;
	}

	public void setOwner(String owner) {
		this.owner = owner;
	}

	public String getDestinationFolder() {
		return destinationFolder;
	}

	public void setDestinationFolder(String destinationFolder) {
		this.destinationFolder = destinationFolder;
	}

	public abstract Crawlindex getOutIndex();

	public abstract Crawlindex getInIndex();
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\crawler\DownloadException.java
package crawler;

import entity.GroundhogException;


public class DownloadException extends GroundhogException {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3008366459405858621L;

	public DownloadException(String msg) {
		super(msg);
	}

	public DownloadException(String msg, Throwable cause) {
		super(msg, cause);
	}

	public DownloadException(Throwable cause) {
		super(cause);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\crawler\ForgeCrawler.java
package crawler;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import entity.Project;

/**
 * An abstract class that defines the forge crawl functionality.
 * A forge crawler downloads projects from a certain forge
 * to a given folder. 
 * 
 *
 */
public abstract class ForgeCrawler {
	
	/**
	 * Downloads a single project and returns its repository folder. A project
	 * repository folder is useful to be manipulated by {@link CodeHistory}
	 * class and to be parsed by {@link Parser} class.
	 * 
	 * @param a project
	 * 
	 * @return a repository folder
	 * @throws DownloadException
	 *             when something nasty happens
	 */
	public abstract File downloadProject(Project project) throws DownloadException;
	
	/**
	 * Downloads the given list of projects, returning the files objects. Each
	 * file represents the repository folder of a project, according to
	 * ForgeProject list ordering. A project repository folder is useful to be
	 * manipulated by {@link CodeHistory} class and to be parsed by Parser class.
	 * 
	 * @param list of Projects
	 * @return list of repository folders as File objects
	 */
	public List<File> downloadProjects(List<Project> projects) {
		List<Future<File>> futures = asyncDownloadProjects(projects);
		
		try {
			List<File> files = new ArrayList<>();
			for (Future<File> future : futures) {
					File f = future.get();
					files.add(f);
			}
			return files;
		} catch (InterruptedException | ExecutionException e) {
			e.printStackTrace();
			throw new DownloadException(e.getLocalizedMessage());
		}
	}

	/**
	 * Downloads the given list of projects, returning futures with files objects.
	 * Each file represents the repository folder of a project,
	 * according to ForgeProject list ordering. To get a future result, 
	 * just call its .get() method. A project repository folder is useful to be
	 * manipulated by {@link CodeHistory} class and to be parsed by {@link Parser} class.
	 * 
	 * @param list of Projects, usually given by a ForgeSearch subclass
	 * @return list of futures with repository folders as File objects
	 */
	public List<Future<File>> asyncDownloadProjects(List<Project> projects) {
		ExecutorService ex = Executors.newCachedThreadPool();
		
		List<Future<File>> fs = new ArrayList<Future<File>>();
		
		for (final Project p : projects) {
			Future<File> f = ex.submit(new Callable<File>() {
				public File call() throws Exception {
					return downloadProject(p);
				}
			});
			fs.add(f);
		}
		
		ex.shutdown();
		
		return fs;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\DaoController.java
package dao;

import java.util.List;

import usefuldata.Developer;
import usefuldata.DeveloperEcharts;
import usefuldata.EvolveEcharts;
import usefuldata.ForceEcharts;
import usefuldata.Project;
import usefuldata.ProjectContribution;
import usefuldata.Release;
import usefuldata.ReleaseContribution;
import usefuldata.ReleaseEcharts;
import usefuldata.Vitality;
import factory.DaoFactory;
import analysis.AnalysisModule;

public class DaoController {
	private AnalysisModule anm;
	
	public DaoController(AnalysisModule anm){
		this.anm = anm;
	}
	
	/**
	 * save all analysis data to database
	 */
	public void IntoDataBase(){
		List<Developer> dps = this.anm.getDevelopers();
		DaoFactory.getDeveloperDao().addDevelopers(dps);
		
		List<DeveloperEcharts> dp_charts = this.anm.getDeveloper_echarts();
		DaoFactory.getDeveloperEchartsDao().addEcharts(dp_charts);
				
		List<ForceEcharts> fe = this.anm.getForce_echarts();
		DaoFactory.getForceChartDao().addForceCharts(fe);
		
		Project p = this.anm.getProject();
		DaoFactory.getProjectDao().addProject(p);
		
		List<ProjectContribution> pct = this.anm.getProject_contribution();
		DaoFactory.getProjectContribution().addProjectContributions(pct);
				
		List<Vitality> vs = this.anm.getVitalities();
		DaoFactory.getVitalityDao().addVitalities(vs);
		
		List<ReleaseEcharts> res = this.anm.getRelease_echarts();
		DaoFactory.getReleaseEchartsDao().addReleaseEcharts(res);
		
		List<Release> releases = this.anm.getReleases();		
		DaoFactory.getReleaseDao().addReleases(releases);
		
		List<ReleaseContribution> rct = this.anm.getRelease_contributions();
		DaoFactory.getReleaseContribution().addReleaseContributions(rct);
	}
	
	public void EvolveIntoDB(List<EvolveEcharts> ev_charts){
		DaoFactory.getEvolveEchartsDao().addEcharts(ev_charts);
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\DeveloperDao.java
package dao;

import java.util.List;

import usefuldata.Developer;
import usefuldata.Vitality;

public interface DeveloperDao {
	
	/**
	 * try to find developer with id(for other operations)
	 * @param name
	 * @return Developer with basic info
	 */
	public Developer findDeveloper(String name);
	
	
	/**
	 * try to find developer with id(for other operations)
	 * @param id
	 * @return Developer with basic info
	 */
	public Developer findDeveloperForName(int id);
	
	 
	/**
	 * try to find vitality list using developer's id
	 * @param developer
	 * @return Developer with list<vitality>
	 */
	public Developer findDeveloperWithVitality(Developer developer);
	
	/**
	 * try to find vitality list using developer's id
	 * @param developer
	 * @return list<vitality>
	 */
	public List<Vitality> findDeveloperForVitality(Developer developer);
		
	/**
	 * try to find project list using developer's id
	 * @param developer
	 * @return list<project> with reference uninitialized
	 */
	public List<usefuldata.Project> findDeveloperForProjects(Developer developer);
	
	/**
	 * try to delete developer.
	 * this doesn't delete involved project or release
	 * @param name
	 * @return
	 */
	public boolean deleteDeveloper(String name);
	
	/**
	 * try to add developer.do nothing to involved project or release
	 * @param developer
	 * @return
	 */
	public boolean addDeveloper(Developer developer);
	
	
	public boolean addDevelopers(List<Developer> dps);
	
	public boolean updateDeveloper(Developer developer);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\DeveloperEchartsDao.java
package dao;

import java.util.List;

import usefuldata.DeveloperEcharts;

public interface DeveloperEchartsDao {

	public boolean addDeveloperEcharts(int project_id,int release_id,int developer_id,String json);

	public boolean addEcharts(DeveloperEcharts dpe);
	
	public String getDeveloperEcharts(int project_id, int release_id,
			int developer_id);
	
	public DeveloperEcharts getDeveloperEchart(int project_id, int release_id,
			int developer_id);
		
	public boolean addEcharts(List<DeveloperEcharts> des);
	
	public boolean updateEcharts(DeveloperEcharts dpe);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\EvolveEchartsDao.java
package dao;

import java.util.List;

import usefuldata.EvolveEcharts;

public interface EvolveEchartsDao {
	public boolean addEvolveEcharts(int project_id,int release_id,String json);
	
	public boolean addEcharts(EvolveEcharts eve);
	
	public boolean addEcharts(List<EvolveEcharts> ev_charts);
	
	public EvolveEcharts getEvolveEcharts(int project_id,int release_id);
	
	public boolean updateEcharts(EvolveEcharts eve);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\ForceChartDao.java
package dao;

import java.util.ArrayList;
import java.util.List;

import usefuldata.ForceEcharts;

public interface ForceChartDao {
	public boolean addForceChart(int project_id, int release_id,
			String relation,String main_relation);
	
	public boolean addForceChart(ForceEcharts fc);
	
	
	public ArrayList<String> getForceChart(int project_id,
			int release_id);
	
	public boolean addForceCharts(List<ForceEcharts> fe);
	
	public ForceEcharts getForceChartPj(int project_id,int release_id);
	
	public boolean updateForceChart(ForceEcharts fc);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\DaoHelperImpl.java
package dao.impl;

import helper.DBHelper;

public class DaoHelperImpl extends DBHelper{
		
	private static DBHelper baseDao = new DaoHelperImpl();
		
	private DaoHelperImpl(){
      super();
	}
	
	public static DBHelper getBaseDaoInstance(){
		return baseDao;
	}
		
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\DeveloperDaoImpl.java
package dao.impl;


import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import usefuldata.Developer;
import usefuldata.Project;
import usefuldata.Vitality;
import dao.DeveloperDao;

public class DeveloperDaoImpl implements DeveloperDao{

	private static DeveloperDaoImpl developerDao=new DeveloperDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static DeveloperDaoImpl getInstance(){
		return developerDao;
	}
	
	
	@Override
	public Developer findDeveloper(String name) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.developer where login =?");
			ps.setString(1,name);
			rs=ps.executeQuery();
			Developer developer = null;
			if(rs.next()){
				developer = new Developer();
				developer.setId(rs.getInt("id"));
				developer.setLogin(rs.getString("login"));
				developer.setEmail(rs.getString("email"));
				developer.setUrl(rs.getString("url"));
			}	
			
			return developer;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}
	
	@Override
	public Developer findDeveloperWithVitality(Developer developer) {
		List<Vitality> a = findDeveloperForVitality(developer);
		if(a != null){
			developer.setVitalities(a);
			return developer;
		}
		
		return null;
	}
	
	@Override
	public List<Vitality> findDeveloperForVitality(Developer developer) {
				Connection con=daoHelper.getConnection();
				PreparedStatement ps=null;
				ResultSet rs=null;
				
				try{
					ps=con.prepareStatement("select * from gitcrawler.vitality where developer_id =?");
					ps.setInt(1, developer.getId());
					rs=ps.executeQuery();
					
					ArrayList<Vitality> a1 = new ArrayList<Vitality>();
					
					while(rs.next()){
						Vitality v = new Vitality();
						v.setId(rs.getInt("id"));
						v.setDate(rs.getString("date"));
						v.setVitality(rs.getInt("vitality"));
						
						a1.add(v);			
					}	
					
					return a1;
				}catch(SQLException e){
					e.printStackTrace();
				}finally{
					daoHelper.closeResult(rs);
					daoHelper.closePreparedStatement(ps);
					daoHelper.closeConnection(con);
				}
				
				return null;
	}
	
	
	
	@Override
	public List<usefuldata.Project> findDeveloperForProjects(Developer developer) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		ResultSet rs2=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where developer_id =?");
			ps.setInt(1, developer.getId());
			rs=ps.executeQuery();
			
			ArrayList<Project> a1 = new ArrayList<Project>();
			
			while(rs.next()){
				int project_id = rs.getInt("project_id");
				ps = con.prepareStatement("select * from gitcrawler.project where id = ?");
				ps.setInt(1, project_id);
				rs2 = ps.executeQuery();
				if(rs2.next()){
					Project p = new Project();
					p.setId(project_id);
					p.setName(rs2.getString("name"));
					p.setCodes(rs2.getInt("codes"));
					p.setOwner(rs2.getString("owner"));
					p.setDescription(rs2.getString("description"));
					a1.add(p);
				}		
			}	
			
			return a1;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs2);
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}
	
	

	@Override
	public boolean deleteDeveloper(String name) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("delete from gitcrawler.developer where login=?");
			ps.setString(1, name);
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		return false;
	}

	@Override
	public boolean addDeveloper(Developer developer) {
		Developer de = findDeveloperForName(developer.getId());
		if(de != null){
			return updateDeveloper(developer);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`developer` (`id`,`login`,`email`,`url`) VALUES (?,?,?,?)");
				ps.setInt(1,developer.getId());
				ps.setString(2,developer.getLogin());
				ps.setString(3, developer.getEmail());
				ps.setString(4, developer.getUrl());
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}		
			return false;
		}
		
	}


	@Override
	public Developer findDeveloperForName(int id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.developer where id =?");
			ps.setInt(1,id);
			rs=ps.executeQuery();
			Developer developer = null;
			if(rs.next()){
				developer = new Developer();
				developer.setId(rs.getInt("id"));
				developer.setLogin(rs.getString("login"));
				developer.setEmail(rs.getString("email"));
				developer.setUrl(rs.getString("url"));
			}	
			
			return developer;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addDevelopers(List<Developer> dps) {
		for(int i = 0;i<dps.size();i++){
			addDeveloper(dps.get(i));
		}
					
		return true;
	}


	@Override
	public boolean updateDeveloper(Developer developer) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`developer` SET `id`=?,`login`=?,`email`=?,`url`=? where `id` = ?");
			ps.setInt(1,developer.getId());
			ps.setString(2,developer.getLogin());
			ps.setString(3, developer.getEmail());
			ps.setString(4, developer.getUrl());
			
			ps.setInt(5,developer.getId());
			
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\DeveloperEchartsDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import usefuldata.DeveloperEcharts;
import dao.DeveloperEchartsDao;

public class DeveloperEchartsDaoImpl implements DeveloperEchartsDao{

	private static DeveloperEchartsDaoImpl developerEchartsDao=new DeveloperEchartsDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static DeveloperEchartsDaoImpl getInstance(){
		return developerEchartsDao;
	}
	
	@Override
	public boolean addDeveloperEcharts(int project_id, int release_id,
			int developer_id, String json) {
		
		DeveloperEcharts dp = new DeveloperEcharts();
		dp.setDeveloper_id(developer_id);
		dp.setProject_id(project_id);
		dp.setRelease_id(release_id);
		dp.setJson_string(json);
		
		return addEcharts(dp);
	}

	@Override
	public String getDeveloperEcharts(int project_id, int release_id,
			int developer_id) {

		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.developer_echarts where developer_id=? and project_id=? and release_id=?");
			ps.setInt(1, developer_id);
			ps.setInt(2, project_id);
			ps.setInt(3, release_id);
			
			rs=ps.executeQuery();
			String json = null;
			if(rs.next()){
				json = rs.getString("json_string");
			}	
			
			return json;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
		
	}

	@Override
	public boolean addEcharts(DeveloperEcharts dpe) {	
		DeveloperEcharts dd = getDeveloperEchart(dpe.getProject_id(),dpe.getRelease_id(),dpe.getDeveloper_id());
		if(dd != null){
			return updateEcharts(dpe);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`developer_echarts` (`developer_id`,`project_id`,`release_id`,`json_string`) VALUES (?,?,?,?)");
				
				ps.setInt(1,dpe.getDeveloper_id());
				ps.setInt(2,dpe.getProject_id());
				ps.setInt(3,dpe.getRelease_id());
				ps.setString(4, dpe.getJson_string());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}	
	}

	@Override
	public boolean addEcharts(List<DeveloperEcharts> des) {
		for(int i = 0;i<des.size();i++)
			addEcharts(des.get(i));
		
		return true;
	}

	@Override
	public boolean updateEcharts(DeveloperEcharts dpe) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`developer_echarts` SET `developer_id`=?,`project_id`=?,`release_id`=?,`json_string`=? where `developer_id`=? and `project_id`=? and `release_id`=?");
			
			ps.setInt(1,dpe.getDeveloper_id());
			ps.setInt(2,dpe.getProject_id());
			ps.setInt(3,dpe.getRelease_id());
			ps.setString(4, dpe.getJson_string());
			
			ps.setInt(5,dpe.getDeveloper_id());
			ps.setInt(6,dpe.getProject_id());
			ps.setInt(7,dpe.getRelease_id());
			
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public DeveloperEcharts getDeveloperEchart(int project_id, int release_id,
			int developer_id) {
		
		String json = getDeveloperEcharts(project_id,release_id,developer_id);
		if(json != null){
			DeveloperEcharts de = new DeveloperEcharts();
			de.setDeveloper_id(developer_id);
			de.setProject_id(project_id);
			de.setRelease_id(release_id);
			de.setJson_string(json);
			return de;
		}
		
		return null;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\EvolveEchartsDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import usefuldata.EvolveEcharts;
import dao.EvolveEchartsDao;

public class EvolveEchartsDaoImpl implements EvolveEchartsDao{

	private static EvolveEchartsDaoImpl evolveEchartsDaoImpl=new EvolveEchartsDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static EvolveEchartsDaoImpl getInstance(){
		return evolveEchartsDaoImpl;
	}
	
	@Override
	public boolean addEvolveEcharts(int project_id, int release_id, String json) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `gitcrawler`.`evolve_echarts` (`project_id`,`release_id`,`json_string`) VALUES (?,?,?)");
			
			ps.setInt(1,project_id);
			ps.setInt(2,release_id);
			ps.setString(3, json);
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean addEcharts(EvolveEcharts eve) {
		EvolveEcharts evs = getEvolveEcharts(eve.getProject_id(),eve.getRelease_id());
		if(evs !=null){
			return updateEcharts(eve); 
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`evolve_echarts` (`project_id`,`release_id`,`json_string`) VALUES (?,?,?)");
				
				
				ps.setInt(1,eve.getProject_id());
				ps.setInt(2,eve.getRelease_id());
				ps.setString(3, eve.getJson_string());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
		
	}

	@Override
	public boolean addEcharts(List<EvolveEcharts> ev_charts) {
		for(int i = 0;i<ev_charts.size();i++)
			addEcharts(ev_charts.get(i));
		
		return true;
	}

	@Override
	public EvolveEcharts getEvolveEcharts(int project_id, int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.evolve_echarts where project_id =? and release_id =?");
			
			ps.setInt(1, project_id);
			ps.setInt(2,release_id);
						
			rs=ps.executeQuery();
			EvolveEcharts eve = null;
			if(rs.next()){
				eve = new EvolveEcharts();
				eve.setRelease_id(release_id);
				eve.setProject_id(project_id);
				eve.setJson_string(rs.getString("json_string"));
			}	
			
			return eve;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean updateEcharts(EvolveEcharts eve) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`evolve_echarts` SET `project_id`=?,`release_id`=?,`json_string`=? where `project_id`=? and `release_id`=?");
			
			ps.setInt(1,eve.getProject_id());
			ps.setInt(2,eve.getRelease_id());
			ps.setString(3, eve.getJson_string());
			
			ps.setInt(4,eve.getProject_id());
			ps.setInt(5,eve.getRelease_id());
			
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\ForceChartDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import usefuldata.ForceEcharts;
import dao.ForceChartDao;

public class ForceChartDaoImpl implements ForceChartDao{

	private static ForceChartDaoImpl forceChartDao = new ForceChartDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static ForceChartDaoImpl getInstance(){
		return forceChartDao;
	}
	
	
	
	@Override
	public boolean addForceChart(int project_id, int release_id,
			String relation,String main_relation) {

		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `gitcrawler`.`force_chart` (`project_id`,`release_id`,`relation`,`main_relation`) VALUES (?,?,?,?)");
			ps.setInt(1,project_id);
			ps.setInt(2,release_id);
			ps.setString(3, relation);
			ps.setString(4, main_relation);
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}



	@Override
	public ArrayList<String> getForceChart(int project_id,
			int release_id) {

		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.force_chart where project_id=? and release_id=?");
			ps.setInt(1, project_id);
			ps.setInt(2, release_id);
			rs=ps.executeQuery();
			ArrayList<String> results = null;
			if(rs.next()){
				results = new ArrayList<String>();
				results.add(rs.getString("relation"));
				results.add(rs.getString("main_relation"));
				
			}	
			
			return results;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}



	@Override
	public boolean addForceChart(ForceEcharts fc) {
		ForceEcharts fec = getForceChartPj(fc.getProject_id(),fc.getRelease_id());
		if(fec != null){
			return updateForceChart(fc);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`force_chart` (`project_id`,`release_id`,`relation`,`main_relation`) VALUES (?,?,?,?)");
				ps.setInt(1,fc.getProject_id());
				ps.setInt(2,fc.getRelease_id());
				ps.setString(3, fc.getRelation());
				ps.setString(4, fc.getMain_relation());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
			
	}



	@Override
	public boolean addForceCharts(List<ForceEcharts> fe) {
		for(int i = 0;i<fe.size();i++)
			addForceChart(fe.get(i));
		
		return true;
	}



	@Override
	public ForceEcharts getForceChartPj(int project_id, int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.force_chart where project_id=? and release_id=?");
			ps.setInt(1, project_id);
			ps.setInt(2, release_id);
			rs=ps.executeQuery();
			
			ForceEcharts fe = null;
			if(rs.next()){
				fe = new ForceEcharts();
				fe.setProject_id(project_id);
				fe.setRelease_id(release_id);
				fe.setRelation(rs.getString("relation"));
				fe.setMain_relation(rs.getString("main_relation"));
								
			}	
			
			return fe;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}



	@Override
	public boolean updateForceChart(ForceEcharts fc) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`force_chart` SET `project_id`=?,`release_id`=?,`relation`=?,`main_relation`=? where `project_id`=? and `release_id`=?");
			
			ps.setInt(1,fc.getProject_id());
			ps.setInt(2,fc.getRelease_id());
			ps.setString(3, fc.getRelation());
			ps.setString(4, fc.getMain_relation());
			
			ps.setInt(5,fc.getProject_id());
			ps.setInt(6,fc.getRelease_id());			
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\ProjectContributionDaoImpl.java
package dao.impl;
import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import usefuldata.Developer;
import usefuldata.ProjectContribution;
import dao.ProjectContributionDao;
import factory.DaoFactory;

public class ProjectContributionDaoImpl implements ProjectContributionDao{

	
	private static ProjectContributionDaoImpl projectContributionDaoImpl=new ProjectContributionDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static ProjectContributionDaoImpl getInstance(){
		return projectContributionDaoImpl;
	}
	
	
	@Override
	public boolean addProjectContribution(ProjectContribution projectContribution) {
		ProjectContribution pc = findProjectContribution(projectContribution.getProject_id(),projectContribution.getDeveloper_id());
		if(pc != null){
			return updateProjectContribution(projectContribution);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`project_contribution` (`project_id`,`developer_id`,`contributions`) VALUES (?,?,?)");
				ps.setInt(1,projectContribution.getProject_id());
				ps.setInt(2, projectContribution.getDeveloper_id());
				ps.setInt(3, projectContribution.getContributions());
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
				
	}

	@Override
	public ProjectContribution findProjectContribution(int project_id,
			int developer_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where project_id =? and developer_id=?");
			ps.setInt(1, project_id);
			ps.setInt(2, developer_id);
			rs=ps.executeQuery();
			ProjectContribution pcb = null;
			if(rs.next()){
				pcb = new ProjectContribution();
				pcb.setProject_id(project_id);
				pcb.setDeveloper_id(developer_id);
				pcb.setContributions(rs.getInt("contributions"));
			}	
			
			return pcb;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean updateProjectContribution(ProjectContribution pct) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`project_contribution` SET `project_id`=?, `developer_id`=?,`contributions`=? where `project_id`=? and `developer_id`=?");
			ps.setInt(1,pct.getProject_id());
			ps.setInt(2,pct.getDeveloper_id());
			ps.setInt(3,pct.getContributions());
			ps.setInt(4,pct.getProject_id());
			ps.setInt(5,pct.getDeveloper_id());
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean deleteProjectContribution(ProjectContribution pct) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("delete from gitcrawler.project_contribution where project_id=? and developer_id=?");
			ps.setInt(1, pct.getProject_id());
			ps.setInt(2, pct.getDeveloper_id());
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		return false;
	}

	@Override
	public List<ProjectContribution> findProjectContribution(
			int developer_id,List<usefuldata.Project> projects) {
		
		List<ProjectContribution> results = new ArrayList<ProjectContribution>();	
		Developer dp = new Developer();
		dp.setId(developer_id);
				
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
		
		for(int i = 0;i<projects.size();i++){
		
				ps=con.prepareStatement("select * from gitcrawler.project_contribution where project_id =? and developer_id=?");
				ps.setInt(1, projects.get(i).getId());
				ps.setInt(2, developer_id);
				rs=ps.executeQuery();
				
				while(rs.next()){
					ProjectContribution pcb = new ProjectContribution();
					pcb = new ProjectContribution();
					pcb.setProject_id(projects.get(i).getId());
					pcb.setDeveloper_id(developer_id);
					pcb.setContributions(rs.getInt("contributions"));
					pcb.setProjectName(projects.get(i).getName());
					results.add(pcb);
				}	
			}
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		
		return results;
	}

	@Override
	public int getProjectContributions(int developer_id, int project_id) {
		
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where project_id =? and developer_id=?");
			ps.setInt(1, project_id);
			ps.setInt(2, developer_id);
			
			rs=ps.executeQuery();
			if(rs.next()){
				return rs.getInt("contributions");
			}	
			
			return 0;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return 0;
	}


	@Override
	public ArrayList<Integer> getAllProjectContributors(int project_id) {
		
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		ArrayList<Integer> developer_ids = new ArrayList<Integer>();
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where project_id =?");
			ps.setInt(1, project_id);
			
			rs=ps.executeQuery();
			while(rs.next()){
				int id = rs.getInt("developer_id");
				developer_ids.add(id);
			}	
			
			return developer_ids;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addProjectContributions(List<ProjectContribution> pct) {
		for(int i = 0;i<pct.size();i++)
			addProjectContribution(pct.get(i));
		
		return true;
	}


	@Override
	public List<ProjectContribution> findProjectContributionByProjectID(int project_id){
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		List<ProjectContribution> results = new ArrayList<ProjectContribution>();
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where project_id=?");
			ps.setInt(1, project_id);
			rs=ps.executeQuery();
			ProjectContribution pcb = null;
			while(rs.next()){
				pcb = new ProjectContribution();
				pcb.setProject_id(project_id);
				pcb.setDeveloper_id(rs.getInt("developer_id"));
				pcb.setContributions(rs.getInt("contributions"));
				String projectName = DaoFactory.getProjectDao().getProjectById(rs.getInt("project_id")).getName();
				pcb.setProjectName(projectName);
				results.add(pcb);
			}
			System.out.println(project_id);
			System.out.println(results.size());
			return results;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public List<ProjectContribution> findProjectContribution(int developer_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		List<ProjectContribution> results = new ArrayList<ProjectContribution>();
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where developer_id=?");
			ps.setInt(1, developer_id);
			rs=ps.executeQuery();
			ProjectContribution pcb = null;
			while(rs.next()){
				pcb = new ProjectContribution();
				pcb.setProject_id(rs.getInt("project_id"));
				pcb.setDeveloper_id(developer_id);
				pcb.setContributions(rs.getInt("contributions"));
				String projectName = DaoFactory.getProjectDao().getProjectById(rs.getInt("project_id")).getName();
				pcb.setProjectName(projectName);
				results.add(pcb);
			}	
			
			return results;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\ProjectDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import usefuldata.Developer;
import usefuldata.Project;
import usefuldata.Release;
import util.Dates;
import dao.ProjectDao;
import factory.DaoFactory;

public class ProjectDaoImpl implements ProjectDao{

	private static ProjectDaoImpl projectDaoImpl=new ProjectDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	
	public static ProjectDaoImpl getInstance(){
		return projectDaoImpl;
	}
	
	@Override
	public Project getProject(String owner, String projectName) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project where name = ? and owner =?");
			ps.setString(1,projectName);
			ps.setString(2, owner);
			rs=ps.executeQuery();
			Project project = null;
			if(rs.next()){
				project = new Project();
				project.setId(rs.getInt("id"));
				project.setName(rs.getString("name"));
				project.setCodes(rs.getInt("codes"));
				project.setOwner(rs.getString("owner"));
				project.setDescription(rs.getString("description"));
			}	
			
			return project;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public Project getProjectWithId(int project_id, String projectName) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.project where id = ? and name =?");
			ps.setInt(1, project_id);
			ps.setString(2,projectName);
			rs=ps.executeQuery();
			Project project = null;
			if(rs.next()){
				project = new Project();
				project.setId(rs.getInt("id"));
				project.setName(rs.getString("name"));
				project.setCodes(rs.getInt("codes"));
				project.setOwner(rs.getString("owner"));
				project.setDescription(rs.getString("description"));
			}	
			
			return project;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}
	
	
	@Override
	public void deleteProject(String owner, String projectName) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean updateProject(Project project) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`project` SET `id`=?,`name`=?,`codes`=?,`owner`=?,`description`=? where `id`=?");
			
			ps.setInt(1,project.getId());
			ps.setString(2,project.getName());
			ps.setInt(3, project.getCodes());
			ps.setString(4, project.getOwner());
			ps.setString(5, project.getDescription());
			
			ps.setInt(6,project.getId());			
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
		
	}

	@Override
	public boolean addProject(Project project) {
		Project pj = getProjectById(project.getId());
		if(pj != null){
			return updateProject(project);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`project` (`id`,`name`,`codes`,`owner`,`description`) VALUES (?,?,?,?,?)");
				ps.setInt(1,project.getId());
				ps.setString(2,project.getName());
				ps.setInt(3, project.getCodes());
				ps.setString(4, project.getOwner());
				ps.setString(5, project.getDescription());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}		
			return false;
		}
	}

	@Override
	public List<Developer> getAllDevelopers(int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		try{
			ps=con.prepareStatement("select * from gitcrawler.project_contribution where project_id=?");
			ps.setInt(1, project_id);
			rs=ps.executeQuery();
			
			List<Developer> developers = new ArrayList<Developer>();
			
			while(rs.next()){
				int developer_id = rs.getInt("developer_id");
				Developer dp = DaoFactory.getDeveloperDao().findDeveloperForName(developer_id);
				if(dp!=null)
					developers.add(dp);
			}	
			
			return developers;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public List<Release> getAllReleases(String projectName,String owner) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		try{
			int projectId = getProject(owner,projectName).getId();
			con=daoHelper.getConnection();
			
			ps=con.prepareStatement("select * from gitcrawler.releases where project_id=?");
			ps.setInt(1, projectId);
			rs=ps.executeQuery();
			
			List<Release> results = new ArrayList<Release>();
			
			while(rs.next()){
				Release release = null;
				release = new Release();
				release.setId(rs.getInt("id"));
				release.setName(rs.getString("name"));	
				release.setCodes(rs.getInt("codes"));
				release.setDate(rs.getString("date"));
				release.setRelease_commits(rs.getInt("release_commits"));
				
				results.add(release);
			}	
			
			return Dates.releaseSort(results);
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		
		return null;
	}

	

		public Project getProjectById(int project_id) {
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			ResultSet rs=null;
			
			try{
				ps=con.prepareStatement("select * from gitcrawler.project where id = ?");
				ps.setInt(1, project_id);
				rs=ps.executeQuery();
				Project project = null;
				if(rs.next()){
					project = new Project();
					project.setId(rs.getInt("id"));
					project.setName(rs.getString("name"));
					project.setCodes(rs.getInt("codes"));
					project.setOwner(rs.getString("owner"));
					project.setDescription(rs.getString("description"));
				}	
				
				return project;
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closeResult(rs);
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return null;
		}

			@Override
			public ArrayList<Project> getAllProjects() {
				Connection con=daoHelper.getConnection();
				PreparedStatement ps=null;
				ResultSet rs=null;
				ArrayList<Project> projects = new ArrayList<Project>();
				
				try{
					ps=con.prepareStatement("select * from gitcrawler.project");
					rs=ps.executeQuery();
					while(rs.next()){
						Project project = new Project();
						project.setId(rs.getInt("id"));
						project.setName(rs.getString("name"));
						project.setCodes(rs.getInt("codes"));
						project.setOwner(rs.getString("owner"));
						project.setDescription(rs.getString("description"));
						projects.add(project);
					}	
					
					return projects;
				}catch(SQLException e){
					e.printStackTrace();
				}finally{
					daoHelper.closeResult(rs);
					daoHelper.closePreparedStatement(ps);
					daoHelper.closeConnection(con);
				}
				
				return null;
			}
		}
	

	
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\ReleaseContributionDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import usefuldata.Release;
import usefuldata.ReleaseContribution;
import dao.ReleaseContributionDao;
import factory.DaoFactory;

public class ReleaseContributionDaoImpl implements ReleaseContributionDao{

	private static ReleaseContributionDaoImpl releaseContributionDao=new ReleaseContributionDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static ReleaseContributionDaoImpl getInstance(){
		return releaseContributionDao;
	}
	
	@Override
	public ArrayList<ReleaseContribution> getReleaseContribution(
			int project_id, int developer_id) {
		
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.release_contribution where project_id =? and developer_id=?");
			ps.setInt(1, project_id);
			ps.setInt(2, developer_id);
			rs=ps.executeQuery();
			ReleaseContribution rcb = null;
			ArrayList<ReleaseContribution> results = new ArrayList<ReleaseContribution>();
			
			while(rs.next()){
				rcb = new ReleaseContribution();
				int release_id = rs.getInt("release_id");
				String releaseName = DaoFactory.getReleaseDao().getRelease(release_id).getName();
				rcb.setReleaseName(releaseName);
				rcb.setContributions(rs.getInt("contributions"));
				rcb.setRelease_id(release_id);
				rcb.setDeveloper_id(rs.getInt("developer_id"));
				rcb.setProject_id(rs.getInt("project_id"));
				
				results.add(rcb);
			}	
			
			List<Release> reles = DaoFactory.getReleaseDao().getAllRelease(project_id);
			ArrayList<ReleaseContribution> res = new ArrayList<ReleaseContribution>();
			for(Release r:reles){
				res.add(new ReleaseContribution(r.getName(),0));
			}
			
			for(int i = 0;i<results.size();i++){
				for(int j =0;j<res.size();j++){
					if(res.get(j).getReleaseName().equals(results.get(i).getReleaseName())){
						res.get(j).setContributions(results.get(i).getContributions());
						break;
					}
					
				}
				
			}
			
			return res;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public int getReleaseContributions(int developer_id,
			int project_id, int release_id) {		
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.release_contribution where release_id =? and developer_id=? and project_id = ?");
			ps.setInt(1, release_id);
			ps.setInt(2, developer_id);
			ps.setInt(3, project_id);
			
			rs=ps.executeQuery();
			if(rs.next()){
				return rs.getInt("contributions");
			}	
			
			return 0;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return 0;
	}

	@Override
	public boolean addReleaseContribution(ReleaseContribution rc) {
		ReleaseContribution sc = getContributions(rc.getDeveloper_id(), rc.getProject_id(), rc.getRelease_id());
		if(sc == null){
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`release_contribution` (`release_id`,`developer_id`,`project_id`,`contributions`,`releaseName`) VALUES (?,?,?,?,?)");
				ps.setInt(1,rc.getRelease_id());
				ps.setInt(2, rc.getDeveloper_id());
				ps.setInt(3, rc.getProject_id());
				ps.setInt(4, rc.getContributions());
				ps.setString(5, rc.getReleaseName());
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
		
		else
			return updateReleaseContribution(rc);
		
	}

	@Override
	public boolean addReleaseContributions(List<ReleaseContribution> rct) {
		for(int i = 0;i<rct.size();i++)
			addReleaseContribution(rct.get(i));
		return true;
	}

	@Override
	public ReleaseContribution getContributions(int developer_id,
			int project_id, int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.release_contribution where release_id =? and developer_id=? and project_id = ?");
			ps.setInt(1, release_id);
			ps.setInt(2, developer_id);
			ps.setInt(3, project_id);
			
			rs=ps.executeQuery();
			
			ReleaseContribution rcs = null;
			if(rs.next()){
				rcs = new ReleaseContribution();
				rcs.setDeveloper_id(rs.getInt("developer_id"));
				rcs.setProject_id(rs.getInt("project_id"));
				rcs.setRelease_id(rs.getInt("release_id"));
				rcs.setReleaseName(rs.getString("releaseName"));
				rcs.setContributions(rs.getInt("contributions"));
				
			}	
			
			return rcs;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean updateReleaseContribution(ReleaseContribution rc) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`release_contribution` SET `release_id`=?,`developer_id`=?,`project_id`=?,`contributions`=?,`releaseName`=? where `release_id` =? and `developer_id`=? and `project_id` = ?");
						
			ps.setInt(1,rc.getRelease_id());
			ps.setInt(2,rc.getDeveloper_id());
			ps.setInt(3,rc.getProject_id());
			ps.setInt(4,rc.getContributions());
			ps.setString(5, rc.getReleaseName());
			
			ps.setInt(6,rc.getRelease_id());
			ps.setInt(7,rc.getDeveloper_id());
			ps.setInt(8,rc.getProject_id());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\ReleaseDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import usefuldata.Developer;
import usefuldata.Release;
import util.Dates;
import dao.DeveloperDao;
import dao.ReleaseDao;
import factory.DaoFactory;

public class ReleaseDaoImpl implements ReleaseDao{

	private static ReleaseDaoImpl releaseDaoImpl=new ReleaseDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	private static DeveloperDao developerDao = DaoFactory.getDeveloperDao();
	
	public static ReleaseDaoImpl getInstance(){
		return releaseDaoImpl;
	}
	
	@Override
	public Release getRelease(int projectId, String releaseName) {
				Connection con=daoHelper.getConnection();
				PreparedStatement ps=null;
				ResultSet rs=null;
				
				try{
					ps=con.prepareStatement("select * from gitcrawler.releases where name =? and project_id=?");
					ps.setString(1,releaseName);
					ps.setInt(2, projectId);
					rs=ps.executeQuery();
					Release release = null;
					if(rs.next()){
						release = new Release();
						release.setId(rs.getInt("id"));
						release.setName(rs.getString("name"));	
						release.setCodes(rs.getInt("codes"));
						release.setProject_id(rs.getInt("project_id"));
						release.setDate(rs.getString("date"));
						release.setRelease_commits(rs.getInt("release_commits"));
						release.setDocument(rs.getInt("document"));
						release.setTest(rs.getInt("test"));
						release.setCommit_rate(rs.getDouble("commit_rate"));
						release.setIssue_number(rs.getInt("issue_number"));
						release.setComprehensive(rs.getInt("comprehensive"));
					}	
					
					return release;
				}catch(SQLException e){
					e.printStackTrace();
				}finally{
					daoHelper.closeResult(rs);
					daoHelper.closePreparedStatement(ps);
					daoHelper.closeConnection(con);
				}
				
				return null;
	}

	@Override
	public List<Developer> getAllDeveloper(int projectId, String releaseName) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		PreparedStatement ps2=null;
		ResultSet rs=null;
		ResultSet rs2=null;
		try{
			ps=con.prepareStatement("select * from gitcrawler.releases where name =? and project_id=?");
			ps.setString(1,releaseName);
			ps.setInt(2, projectId);
			rs=ps.executeQuery();
			int release_id;
			List<Developer> dvps = null;
			
			if(rs.next()){
				release_id = rs.getInt("id");
				ps2 = con.prepareStatement("select * from gitcrawler.release_contribution where release_id =? and project_id=?");
				ps2.setInt(1, release_id);
				ps2.setInt(2, projectId);
				rs2 = ps2.executeQuery();
				dvps = new ArrayList<Developer>();
				
				while(rs2.next()){
					Developer d = developerDao.findDeveloperForName(rs2.getInt("developer_id"));
					dvps.add(d);
				}
				
			}	
			
			return dvps;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs2);
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps2);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
			
		}
		
		return null;
	}
	
	
	@Override
	public HashMap<Integer, Integer> getContributions(int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.release_contribution where release_id =?");
			ps.setInt(1, release_id);
			rs=ps.executeQuery();
			HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();
			while(rs.next()){
				hm.put(rs.getInt("developer_id"),rs.getInt("contributions") );
			}	
			
			return hm;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}
	
	
	@Override
	public void deleteRelease(String projectName, String releaseName) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean updateReleaseContributon(int release_id,int developer_id,int project_id,int submits) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`release_contribution` SET `release_id`=?, `developer_id`=?,`project_id`=?,`contributions`=? where `release_id`=? and `developer_id`=?");
			ps.setInt(1,release_id);
			ps.setInt(2,developer_id);
			ps.setInt(3,project_id);
			ps.setInt(4,submits);
			ps.setInt(5,release_id);
			ps.setInt(6,developer_id);
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
		
	}

	@Override
	public boolean updateReleaseInfo(Release release) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`releases` SET `id`=?, `name`=?,`codes`=?,`project_id`=?,`date`=?,`release_commits`=?,`document`=?,`test`=?,`commit_rate`=?,`issue_number`=?,`comprehensive` where `id`=? and `project_id`=?");
			ps.setInt(1,release.getId());
			ps.setString(2, release.getName());
			ps.setInt(3,release.getCodes());
			ps.setInt(4, release.getProject_id());
			ps.setString(5, release.getDate());
			ps.setInt(6, release.getRelease_commits());
			ps.setInt(7, release.getDocument());
			ps.setInt(8, release.getTest());
			ps.setDouble(9, release.getCommit_rate());
			ps.setInt(10, release.getIssue_number());
			ps.setInt(11, release.getComprehensive());
			ps.setInt(12,release.getId());
			ps.setInt(13,release.getProject_id());
			
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}
	
	@Override
	public boolean addReleaseInfo(Release release, int project_id) {
		Release r = getRelease(project_id,release.getName());
		if(r != null){
			return updateReleaseInfo(release);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`releases` (`id`, `name`,`codes`,`project_id`,`date`,`release_commits`,`document`,`test`,`commit_rate`,`issue_number`,`comprehensive`) VALUES (?,?,?,?,?,?,?,?,?,?,?)");
				
				ps.setInt(1,release.getId());
				ps.setString(2, release.getName());
				ps.setInt(3,release.getCodes());
				ps.setInt(4,release.getProject_id());
				ps.setString(5, release.getDate());
				ps.setInt(6, release.getRelease_commits());
				ps.setInt(7, release.getDocument());
				ps.setInt(8, release.getTest());
				ps.setDouble(9, release.getCommit_rate());
				ps.setInt(10, release.getIssue_number());
				ps.setInt(11, release.getComprehensive());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
		
	}

	@Override
	public boolean addReleaseContribution(int release_id,int developer_id,int project_id,int contributions) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `gitcrawler`.`release_contribution` (`release_id`, `developer_id`,`project_id`,`contributions`) VALUES (?,?,?,?)");
			ps.setInt(1,release_id);
			ps.setInt(2,developer_id);
			ps.setInt(3,project_id);
			ps.setInt(4,contributions);
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public List<Release> getAllRelease(int projectId) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		try{
			
			ps=con.prepareStatement("select * from gitcrawler.releases where project_id=?");
			ps.setInt(1, projectId);
			rs=ps.executeQuery();
			
			List<Release> results = new ArrayList<Release>();
			
			while(rs.next()){
				Release release = null;
				release = new Release();
				release.setId(rs.getInt("id"));
				release.setName(rs.getString("name"));	
				release.setCodes(rs.getInt("codes"));
				release.setProject_id(rs.getInt("project_id"));
				release.setDate(rs.getString("date"));
				release.setRelease_commits(rs.getInt("release_commits"));
				release.setDocument(rs.getInt("document"));
				release.setTest(rs.getInt("test"));
				release.setCommit_rate(rs.getDouble("commit_rate"));
				release.setIssue_number(rs.getInt("issue_number"));
				release.setComprehensive(rs.getInt("comprehensive"));
				results.add(release);
			}	
			
			return Dates.releaseSort(results);
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	
	/**
	 * this method also deals with the data
	 */
	public Map<String, Integer> getReleaseCommitNum(int projectId) {
		List<Release> tmp_releases = getAllRelease(projectId);
		Map<String, Integer> results = new HashMap<String, Integer>();
		
		Map<String, String> unSortedDates = new HashMap<String, String>();
		for(Release rel:tmp_releases){
			unSortedDates.put(rel.getName(), rel.getDate());
		}
		
		ArrayList<String> sorted_date = Dates.dateSort(unSortedDates);
		ArrayList<Integer> sorted_commit = new ArrayList<Integer>();
		
		for(int i = 0;i<sorted_date.size();i++){
			String tag_name = sorted_date.get(i);
			for(Release rel:tmp_releases){
				if(rel.getName().equals(tag_name)){
					sorted_commit.add(rel.getCodes());
					break;
				}
			}
		}
		
		for(int j =0;j<sorted_commit.size();j++){
			if(j == 0)
			results.put(sorted_date.get(j), sorted_commit.get(j));
			else
				results.put(sorted_date.get(j),Math.abs(sorted_commit.get(j) -sorted_commit.get(j-1)));
		}
		
		return results;
	}

	@Override
	public Release getRelease(int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.releases where id=?");
			ps.setInt(1, release_id);
			rs=ps.executeQuery();
			Release release = null;
			if(rs.next()){
				release = new Release();
				release.setId(rs.getInt("id"));
				release.setName(rs.getString("name"));	
				release.setCodes(rs.getInt("codes"));
				release.setProject_id(rs.getInt("project_id"));
				release.setDate(rs.getString("date"));
				release.setRelease_commits(rs.getInt("release_commits"));
				release.setDocument(rs.getInt("document"));
				release.setTest(rs.getInt("test"));
				release.setCommit_rate(rs.getDouble("commit_rate"));
				release.setIssue_number(rs.getInt("issue_number"));
				release.setComprehensive(rs.getInt("comprehensive"));
			}	
			
			return release;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean addRelease(Release r) {
		return addReleaseInfo(r,r.getProject_id());
	}

	@Override
	public boolean addReleases(List<Release> releases) {
		for(int i = 0;i<releases.size();i++)
			addRelease(releases.get(i));
		
		return true;
	}

//	@Override
//	public ArrayList<ReleaseContribution> getSortedContributions(int release_id) {
//		// TODO Auto-generated method stub
//		
//		return null;
//		
//	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\ReleaseEchartsDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import usefuldata.ReleaseEcharts;
import dao.ReleaseEchartsDao;

public class ReleaseEchartsDaoImpl implements ReleaseEchartsDao{

	private static ReleaseEchartsDaoImpl releaseEchartsDao = new ReleaseEchartsDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static ReleaseEchartsDaoImpl getInstance(){
		return releaseEchartsDao;
	}
	
	
	@Override
	public String getReleaseEcharts(int project_id, int release_id) {	
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.release_echarts where project_id =? and release_id =?");
			ps.setInt(1, project_id);
			ps.setInt(2, release_id);
			
			rs=ps.executeQuery();
			String json_string = null;
			if(rs.next()){
				json_string = rs.getString("json_string");
			}	
			
			return json_string;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addReleaseEcharts(ReleaseEcharts re) {
		ReleaseEcharts r = getReleaseEchartPO(re.getProject_id(),re.getRelease_id());
		if(r != null){
			return updateReleaseEcharts(re);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`release_echarts` (`project_id`,`release_id`,`json_string`) VALUES (?,?,?)");
				ps.setInt(1,re.getProject_id());
				ps.setInt(2, re.getRelease_id());
				ps.setString(3, re.getJson_string());
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
		
	}


	@Override
	public ReleaseEcharts getReleaseEchartPO(int project_id, int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.release_echarts where project_id =? and release_id =?");
			ps.setInt(1, project_id);
			ps.setInt(2, release_id);
			
			rs=ps.executeQuery();
			ReleaseEcharts re = null;
			if(rs.next()){
				re = new ReleaseEcharts(project_id,release_id,rs.getString("json_string"));
			}	
			
			return re;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addReleaseEcharts(List<ReleaseEcharts> res) {
		for(int i = 0;i<res.size();i++)
			addReleaseEcharts(res.get(i));
		
		return true;
	}


	@Override
	public boolean updateReleaseEcharts(ReleaseEcharts re) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`release_echarts` SET `project_id`=?,`release_id`=?,`json_string`=? where `project_id` =? and `release_id`=?");
						
			ps.setInt(1,re.getProject_id());
			ps.setInt(2,re.getRelease_id());
			ps.setString(3, re.getJson_string());
			
			ps.setInt(4,re.getProject_id());
			ps.setInt(5,re.getRelease_id());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\impl\VitalityDaoImpl.java
package dao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import usefuldata.Developer;
import usefuldata.Vitality;
import dao.VitalityDao;

public class VitalityDaoImpl implements VitalityDao{

	private static VitalityDaoImpl vitalityDaoImpl=new VitalityDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static VitalityDaoImpl getInstance(){
		return vitalityDaoImpl;
	}
	
	@Override
	public List<Vitality> getVitality(Developer developer) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.vitality where developer_id =?");
			ps.setInt(1, developer.getId());
			rs=ps.executeQuery();
			
			ArrayList<Vitality> a1 = new ArrayList<Vitality>();
			
			while(rs.next()){
				Vitality v = new Vitality();
				v.setId(rs.getInt("id"));
				v.setDate(rs.getString("date"));
				v.setVitality(rs.getInt("vitality"));
				a1.add(v);			
			}	
			return a1;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;	
	}

	@Override
	public boolean updateVitality(Vitality vitality) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `gitcrawler`.`vitality` SET `id`=?, `date`=?,`vitality`=?,`developer_id`=? where `id`=? and `developer_id`=?");
			ps.setInt(1,vitality.getId());
			ps.setString(2,vitality.getDate());
			ps.setInt(3,vitality.getVitality());
			ps.setInt(4,vitality.getDeveloper_id());
			ps.setInt(5,vitality.getId());
			ps.setInt(6,vitality.getDeveloper_id());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean addVitality(Vitality vitality) {
		Vitality v = getVitalityById(vitality.getId());
		if(v != null){
			return updateVitality(vitality);
		}
		else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			
			try{
				ps=con.prepareStatement("INSERT INTO `gitcrawler`.`vitality` (`id`,`date`,`vitality`,`developer_id`,`project_id`,`release_id`) VALUES (?,?,?,?,?,?)");
				ps.setInt(1,0);
				ps.setString(2,vitality.getDate());
				ps.setInt(3, vitality.getVitality());
				ps.setInt(4,vitality.getDeveloper_id());
				ps.setInt(5,vitality.getProject_id());
				ps.setInt(6,vitality.getRelease_id());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			
			return false;
		}
		
	}

	@Override
	public boolean deleteVitality(Vitality vitality) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("delete from gitcrawler.vitality where id=? and developer_id=?");
			ps.setInt(1,vitality.getId());
			ps.setInt(2, vitality.getDeveloper_id());
			ps.execute();
		
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		return false;
	}

	@Override
	public boolean deleteAllVitality(int id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("delete from gitcrawler.vitality where developer_id=?");
			ps.setInt(1, id);
			ps.execute();
		
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		return false;
	}

	@Override
	public List<Vitality> getVitality(int developer_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.vitality where developer_id =?");
			ps.setInt(1, developer_id);
			rs=ps.executeQuery();
			
			ArrayList<Vitality> a1 = new ArrayList<Vitality>();
			
			while(rs.next()){
				Vitality v = new Vitality();
				v.setId(rs.getInt("id"));
				v.setDate(rs.getString("date"));
				v.setVitality(rs.getInt("vitality"));
				a1.add(v);			
			}	
			return a1;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;	
	}

	@Override
	public List<Vitality> getVitality(int project_id, int release_id,
			int developer_id) {
				
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.vitality where developer_id =? and project_id =? and release_id=?");
			ps.setInt(1, developer_id);
			ps.setInt(2, project_id);
			ps.setInt(3, release_id);
			rs=ps.executeQuery();
			
			ArrayList<Vitality> a1 = new ArrayList<Vitality>();
			
			while(rs.next()){
				Vitality v = new Vitality();
				v.setId(rs.getInt("id"));
				v.setDate(rs.getString("date"));
				v.setVitality(rs.getInt("vitality"));
				a1.add(v);			
			}	
			
			return a1;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean addVitalities(List<Vitality> vs) {
		for(int i = 0;i<vs.size();i++)
			addVitality(vs.get(i));
		
		return true;
	}

	@Override
	public Vitality getVitalityById(int vitality_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.vitality where id=?");
			ps.setInt(1, vitality_id);
			rs=ps.executeQuery();
			
			Vitality v = null;
			
			if(rs.next()){
				v = new Vitality();
				v.setId(rs.getInt("id"));
				v.setDate(rs.getString("date"));
				v.setVitality(rs.getInt("vitality"));
						
			}	
			
			return v;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public Vitality checkVitality(Vitality v) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from gitcrawler.vitality where date=? and developer_id=? and project_id=? and release_id=?");
			ps.setString(1, v.getDate());
			ps.setInt(2, v.getDeveloper_id());
			ps.setInt(3, v.getProject_id());
			ps.setInt(4, v.getRelease_id());
			rs=ps.executeQuery();
			
			Vitality vs = null;
			
			if(rs.next()){
				vs = new Vitality();
				vs.setId(rs.getInt("id"));
				vs.setDate(rs.getString("date"));
				vs.setVitality(rs.getInt("vitality"));
				vs.setDeveloper_id(rs.getInt("developer_id"));
				vs.setProject_id(rs.getInt("project_id"));
				vs.setRelease_id(rs.getInt(rs.getInt("release_id")));
			}	
			
			return v;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\ProjectContributionDao.java
package dao;


import java.util.ArrayList;
import java.util.List;

import usefuldata.ProjectContribution;

public interface ProjectContributionDao {
	
	public boolean addProjectContributions(List<ProjectContribution> pct);
	
	
	/**
	 * try to add projectContribution to database
	 * @param projectContribution
	 * @return
	 */
	public boolean addProjectContribution(ProjectContribution projectContribution);
	
	
	/**
	 * try to find a ProjectContribution 
	 * @return
	 */
	public ProjectContribution findProjectContribution(int project_id,int developer_id);
	
	
	public List<ProjectContribution> findProjectContribution(int developer_id,List<usefuldata.Project> projects);
	
	public List<ProjectContribution> findProjectContributionByProjectID(int project_id);
	
	public List<ProjectContribution> findProjectContribution(int developer_id);
	
	
	/**
	 * try to update a ProjectContribution
	 * @param pct
	 * @return
	 */
	public boolean updateProjectContribution(ProjectContribution pct);
	
	/**
	 * try to delete a ProjectContribution
	 * @param pct
	 * @return
	 */
	public boolean deleteProjectContribution(ProjectContribution pct);
	
	
	public int getProjectContributions(int developer_id, int project_id);
	
	public ArrayList<Integer> getAllProjectContributors(int project_id);
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\ProjectDao.java
package dao;

import java.util.ArrayList;
import java.util.List;

import usefuldata.Developer;
import usefuldata.Project;
import usefuldata.Release;

public interface ProjectDao {
	
	/**
	 * try to find project for project's basic info
	 * @param owner
	 * @param projectName
	 * @return project with basic info
	 */
	public usefuldata.Project getProject(String owner,String projectName);
	
	public usefuldata.Project getProjectWithId(int project_id,String projectName);
	
	
	public usefuldata.Project getProjectById(int project_id);
	
	public ArrayList<Project> getAllProjects();
	
	/**
	 * 
	 * @param project_id
	 * @return developers with reference not initialized
	 */
	public List<Developer> getAllDevelopers(int project_id);
	
	/**
	 * get all sorted releases 
	 * @param projectName
	 * @return
	 */
	public List<Release> getAllReleases(String projectName,String owner);
	
	
	public void deleteProject(String owner,String projectName);
	public boolean updateProject(usefuldata.Project project);
	public boolean addProject(usefuldata.Project project);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\ReleaseContributionDao.java
package dao;

import java.util.ArrayList;
import java.util.List;

import usefuldata.ReleaseContribution;

public interface ReleaseContributionDao {
	
	/**
	 * get sorted ReleaseContributions
	 * @param projectName
	 * @param developer
	 * @return
	 */
	public ArrayList<ReleaseContribution> getReleaseContribution(int project_id, int developer_id);
	
	
	public int getReleaseContributions(int developer_id, int project_id,
			int release_id);
	
	public ReleaseContribution getContributions(int developer_id, int project_id,
			int release_id);
	
	

	public boolean addReleaseContribution(ReleaseContribution rc);
	
	public boolean addReleaseContributions(List<ReleaseContribution> rct);
	
	public boolean updateReleaseContribution(ReleaseContribution rc);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\ReleaseDao.java
package dao;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import usefuldata.Developer;
import usefuldata.Release;

public interface ReleaseDao {

	public boolean addReleases(List<Release> releases);
	
	
	public boolean addRelease(Release r);
	
	
	/**
	 * try to find release for release's basic info
	 * @param projectId
	 * @param releaseName
	 * @return
	 */
	public usefuldata.Release getRelease(int projectId,String releaseName);
	
	/**
	 * remember these releases are already sorted by date
	 * @param projectName
	 * @return 
	 */
	public List<usefuldata.Release> getAllRelease(int projectId);
	
	/**
	 * get a certain release
	 * @param release_id
	 * @return
	 */
	public usefuldata.Release getRelease(int release_id);
	
	
	/**
	 * try to find all developers involved in this release of the project
	 * @param projectId
	 * @param releaseName
	 * @return
	 */
	public List<Developer> getAllDeveloper(int projectId,String releaseName);
	
	
	/**
	 * try to find all contributions in certain release
	 * @param release_id
	 * @return developer_id and submits
	 */
	public HashMap<Integer,Integer> getContributions(int release_id);
	
	
	//public ArrayList<ReleaseContribution> getSortedContributions(int release_id);
	
	
	//not finished yet
	public void deleteRelease(String projectName,String releaseName);
	
	
	
	/**
	 * try to update developer contribution
	 * @param release_id
	 * @param developer_id
	 * @param project_id
	 * @param submits
	 * @return
	 */
	public boolean updateReleaseContributon(int release_id,int developer_id,int project_id,int submits);
	
	/**
	 * try to update release basic info
	 * @param release
	 * @return
	 */
	public boolean updateReleaseInfo(Release release);
	
	
	/**
	 * try to add basic release info 
	 * @param release
	 * @param project_id
	 * @return
	 */
	public boolean addReleaseInfo(usefuldata.Release release,int project_id);

	
	/**
	 * try to add developer contribution and 
	 * remember to first use addReleaseInfo then this method
	 * @param release_id
	 * @param developer_id
	 * @param project_id
	 * @param contributions
	 * @return
	 */
	public boolean addReleaseContribution(int release_id,int developer_id,int project_id,int contributions);
	
	
	public Map<String,Integer> getReleaseCommitNum(int projectId);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\ReleaseEchartsDao.java
package dao;

import java.util.List;

import usefuldata.ReleaseEcharts;

public interface ReleaseEchartsDao {
	public String getReleaseEcharts(int project_id, int release_id);
	
	public ReleaseEcharts getReleaseEchartPO(int project_id, int release_id);
	
	public boolean addReleaseEcharts(ReleaseEcharts re);
	
	public boolean addReleaseEcharts(List<ReleaseEcharts> res);
	
	public boolean updateReleaseEcharts(ReleaseEcharts re);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\dao\VitalityDao.java
package dao;

import java.util.List;

import usefuldata.Developer;
import usefuldata.Vitality;

public interface VitalityDao {

	/**
	 * try to find vitality list using developer's id
	 * @param developer
	 * @return list<vitality>
	 */
	public List<Vitality> getVitality(Developer developer);
	
	public List<Vitality> getVitality(int developer_id);
	
	public Vitality getVitalityById(int vitality_id);
	
	public List<Vitality> getVitality(int project_id, int release_id,
			int developer_id);
	
	/**
	 * try to update vitality
	 * @param vitality
	 * 
	 * @return
	 */
	public boolean updateVitality(Vitality vitality);

	/**
	 * try to add vitality
	 * @param vitality
	 * 
	 * 
	 * @return
	 */
	public boolean addVitality(Vitality vitality);
	
	public boolean addVitalities(List<Vitality> vs);
	
	
	
	/**
	 * //try to delete a vitality entry
	 * @param vitality
	 * 
	 * @return
	 */
	public boolean deleteVitality(Vitality vitality);
	
	/**
	 * try to delete all vitality entries using developer_id
	 * @param id
	 * @return
	 */
	public boolean deleteAllVitality(int id);
	
	public Vitality checkVitality(Vitality v);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Comment.java
package entity;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;

import com.google.gson.annotations.SerializedName;

@Entity("comment")
public class Comment extends GitHubEntity{

	@SerializedName("id")
	@Indexed(unique=true, dropDups=true)
	@Id private int id;
	
	@SerializedName("url")
	private String url;
	
	private String user;
	private int user_id;
	
	@SerializedName("position")
	private int position;
	
	@SerializedName("line")
	private int line;
	
	@SerializedName("path")
	private String path;
	
	@SerializedName("commit_id")
	private String commit_id;
	
	@SerializedName("created_at")
	private String created_at;
	
	@SerializedName("updated_at")
	private String updated_at;
	
	@SerializedName("body")
	private String body;

	public Comment(){
		super();
	}
	
	public Comment(int id, String url, String user, int user_id, int position,
			int line, String path, String commit_id, String created_at,
			String updated_at, String body) {
		super();
		this.id = id;
		this.url = url;
		this.user = user;
		this.user_id = user_id;
		this.position = position;
		this.line = line;
		this.path = path;
		this.commit_id = commit_id;
		this.created_at = created_at;
		this.updated_at = updated_at;
		this.body = body;
	}

	

	public int getId() {
		return id;
	}



	public void setId(int id) {
		this.id = id;
	}



	public String getUrl() {
		return url;
	}



	public void setUrl(String url) {
		this.url = url;
	}



	public String getUser() {
		return user;
	}



	public void setUser(String user) {
		this.user = user;
	}



	public int getUser_id() {
		return user_id;
	}



	public void setUser_id(int user_id) {
		this.user_id = user_id;
	}



	public int getPosition() {
		return position;
	}



	public void setPosition(int position) {
		this.position = position;
	}



	public int getLine() {
		return line;
	}



	public void setLine(int line) {
		this.line = line;
	}



	public String getPath() {
		return path;
	}



	public void setPath(String path) {
		this.path = path;
	}



	public String getCommit_id() {
		return commit_id;
	}



	public void setCommit_id(String commit_id) {
		this.commit_id = commit_id;
	}



	public String getCreated_at() {
		return created_at;
	}



	public void setCreated_at(String created_at) {
		this.created_at = created_at;
	}



	public String getUpdated_at() {
		return updated_at;
	}



	public void setUpdated_at(String updated_at) {
		this.updated_at = updated_at;
	}



	public String getBody() {
		return body;
	}



	public void setBody(String body) {
		this.body = body;
	}



	@Override
	public String getURL() {
		// TODO Auto-generated method stub
		return null;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Commit.java
package entity;

import java.util.Date;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;






import util.Dates;

import com.google.gson.annotations.SerializedName;

/**
 * Represents a Commit object
 * 
 */

@Entity("commits")
public class Commit extends GitHubEntity {
	@SerializedName("sha")
    @Indexed(unique=true, dropDups=true)
	@Id private String sha;
	
	@SerializedName("commiter")
	@Reference private User commiter;
	
	@SerializedName("message")
	private String message;
	
	@Reference private Project project;
	
	private Date commitDate;
	
	private int additionsCount;
	
	private int deletionsCount;
	
	public Commit(){
		super();
	}
	
	public Commit(String sha, Project project) {
		this.sha = sha;
		this.project = project;
	}
	
	
	/**
	 * Informs the SHA checksum of the commit
	 * @return
	 */
	public String getSha() {
		return this.sha;
	}

	public void setSha(String sha) {
		this.sha = sha;
	}

	/**
	 * Informs the User who authored the commit
	 * @return
	 */
	public User getCommiter() {
		return this.commiter;
	}

	public void setCommiter(User commiter) {
		this.commiter = commiter;
	}

	/**
	 * Informs the commit message
	 * @return
	 */
	public String getMessage() {
		return this.message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	/**
	 * Informs the project to which the commit belongs
	 * @return a {@link Project} object
	 */
	public Project getProject() {
		return this.project;
	}

	public void setProject(Project project) {
		this.project = project;
	}

	/**
	 * Informs the date when the commit was done 
	 * @return a {@link Date} object
	 */
	public Date getCommitDate() {
		return this.commitDate;
	}

	public void setCommitDate(String date){
		if(date.length() >10){
			Date createAtDate = new Dates("yyyy-MM-dd HH:mm:ss").format(date.replaceAll("T", " ").replace("Z", ""));
			this.commitDate = createAtDate;
		}
		else{
			Date createAtDate = new Dates("yyyy-MM-dd").format(date);
			this.commitDate = createAtDate;
		}
	}

	/**
	 * Informs the sum of added lines among the files committed
	 * @param deletionsCount
	 */
	public int getAdditionsCount() {
		return this.additionsCount;
	}

	public void setAdditionsCount(int additionsCount) {
		this.additionsCount = additionsCount;
	}

	/**
	 * Informs the sum of deleted lines among the files committed
	 * @param deletionsCount
	 */
	public int getDeletionsCount() {
		return this.deletionsCount;
	}

	public void setDeletionsCount(int deletionsCount) {
		this.deletionsCount = deletionsCount;
	}
	
	/**
	 * Gives the abbreviated SHA of the {@link Commit} object
	 * @return a {@link String} object
	 */
	public String getabbrevSHA() {
		return this.sha.substring(0, 7);
	}
	
	/**
	 * Two {@link Commit} objects are considered equal if and only if both have the same SHA hash
	 * @param commit
	 * @return
	 */
	public boolean equals(Commit commit) {
		return this.sha == commit.sha;
	}
	
	@Override
	public String toString() {
		return "Commit [" + (sha != null ? "sha=" + sha + ", " : "")
				+ (commiter != null ? "commiter=" + commiter + ", " : "")
				+ (message != null ? "message=" + message + ", " : "")
				+ (project != null ? "project=" + project + ", " : "")
				+ (commitDate != null ? "commitDate=" + commitDate : "") + "]";
	}

	@Override
	public String getURL() {
		return String.format("https://api.github.com/repos/%s/%s/commits/%s",
				this.getProject().getUser().getLogin(),
				this.getProject().getName(),
				this.sha);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\CommitFile.java
package entity;

public class CommitFile extends GitHubEntity{
	private String sha;
	private String filename;
	private String status;
	private int additions;
	private int deletions;
	private int changes;
	private String contents_url;
	private String commit_sha;
	
	public CommitFile(){
		super();
	}
	
	public CommitFile(String sha, String filename, String status,
			int additions, int deletions, int changes, String contents_url,
			String commit_sha) {
		super();
		this.sha = sha;
		this.filename = filename;
		this.status = status;
		this.additions = additions;
		this.deletions = deletions;
		this.changes = changes;
		this.contents_url = contents_url;
		this.commit_sha = commit_sha;
	}

	public String getSha() {
		return sha;
	}

	public void setSha(String sha) {
		this.sha = sha;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getAdditions() {
		return additions;
	}

	public void setAdditions(int additions) {
		this.additions = additions;
	}

	public int getDeletions() {
		return deletions;
	}

	public void setDeletions(int deletions) {
		this.deletions = deletions;
	}

	public int getChanges() {
		return changes;
	}

	public void setChanges(int changes) {
		this.changes = changes;
	}

	public String getContents_url() {
		return contents_url;
	}

	public void setContents_url(String contents_url) {
		this.contents_url = contents_url;
	}

	public String getCommit_sha() {
		return commit_sha;
	}

	public void setCommit_sha(String commit_sha) {
		this.commit_sha = commit_sha;
	}

	@Override
	public String getURL() {
		return commit_sha;
	}
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Contributor.java
package entity;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;



import com.google.gson.annotations.SerializedName;

/**
 * <h1>Contributor</h1>
 * <p>
		This class represents a <i>Contributor</i> from a {@link Project}. 
	Sometimes a  user want to extract  metrics
	about the Contributors list from a project, with <i>Github</i>
	API we can get this list and store all individual
	data from a Contributor in this class.
 * </p>
 *@see
 * <p>This class have a list of attributes whom <b> should be set </b> after the instantiation because they are not being required by the constructor. These attributes represent the data of a Project <i>Contributor</i> on the <i>GitHub</i>, see they below. </p>   
 * <p>The attributes are at form bellow: </p>
 * <p>Class/type attributeName: What he represent </p>  
 * <ul>
 * 		 <li> <b>int</b> <i>id</i>: The unique id of the Contributor in question. 
 *		 <li> <b>int</b> <i>contributions</i>: Probably the most important data stored by this Class, the number of contributions in the <i>Project</i> by this Contributor.
 *		 <li> <b>boolean</b> <i>site_admin</i>: A boolean that represent if the Contributor is a site admin.
 *		 <li> <b>String</b> <i>avatar_url</i>: A String that represent the avatar_url.
 *		 <li> <b>String</b> <i>gravatar_id</i>: A String that represent the gravatar_id.
 *		 <li> <b>String</b> <i>html_url</i>: A String that represent the html_url.
 * 		 <li> <b>String</b> <i>followers_url</i>: A String that contains a link for all {@link User}'s that are following the <i>Contributor</i> in question.
 * 		 <li> <b>String</b> <i>following_url</i>: A String that contains a link for all {@link User}'s that the <i>Contributor</i> in question are following.
 *		 <li> <b>String</b> <i>gists_url</i>: A String that represent the gists_url.
 *		 <li> <b>String</b> <i>starred_url</i>: A String that represent the starred_url.
 *		 <li> <b>String</b> <i>subscriptions_url</i>: A String that represent the subscriptions_url.
 *		 <li> <b>String</b> <i>repos_url</i>: A String that represent the repos_url.
 *		 <li> <b>String</b> <i>events_url</i>: A String that represent the events_url.
 *		 <li> <b>String</b> <i>received_events_url</i>: A String that represent the received_events_url.
 *		 <li> <b>String</b> <i>type</i>: A String that represent the type.
 *		 
 * </ul> 
 * 
 */
@Entity("contributor")
public class Contributor extends GitHubEntity {
    @SerializedName("id")
    @Indexed(unique=true, dropDups=true)
    @Id private int id;
   
    @SerializedName("login")
    private String login;
    
    @SerializedName("avatar_url")
    private String avatar_url;
    
    @SerializedName("gravatar_id")
    private String gravatar_id;
    
    @SerializedName("html_url")
    private String html_url;
    
    @SerializedName("followers_url")
    private String followers_url;
    
    @SerializedName("following_url")
    private String following_url;
    
    @SerializedName("gists_url")
    private String gists_url; 
    
    @SerializedName("starred_url")
    private String starred_url;
    
    @SerializedName("subscriptions_url")
    private String subscriptions_url;
    
    @SerializedName("repos_url")
    private String repos_url;
    
    @SerializedName("events_url") 
    private String events_url;
    
    @SerializedName("received_events_url")
    private String received_events_url;
    
    @SerializedName("type")
    private String type;
    
    @SerializedName("site_admin")
    private boolean site_admin;
    
    @SerializedName("contributions")
    private int contributions;
    
    public Contributor(){
    	super();
    }
    
    /**<p>This constructor that doesn't require all fields, but they <b>should</b> be setted after instantiation for a good use like we have described in
	 {@link Contributor} Class annotation <p>*/
    public Contributor(String login) {
    	this.login = login;
    }
    
    /**
     * <p>Informs the GitHub ID for the {@link Contributor} object in question
     * This ID is unique in GitHub, which means no two contributors can have the same ID on GitHub</p>
     * @return the integer ID
     */
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}
	
	/**
	 *<p> The String returned by this method informs the {@link Contributor} <i>login</i>. </p> 
	 *@return
	 *<p>Return a String that represent the <i>login</i></p>
	 **/
	public String getLogin() {
		return login;
	}

	public void setLogin(String login) {
		this.login = login;
	}

	/**
	 * @return
	 * <p>Return a String that represent the <i>avatar_url</i></p>
	 * */
	public String getAvatar_url() {
		return avatar_url;
	}

	public void setAvatar_url(String avatar_url) {
		this.avatar_url = avatar_url;
	}
	
	/**
	 * @return
	 * <p>Return a String that represent the <i>gravatar_id</i></p>
	 * */
	public String getGravatar_id() {
		return gravatar_id;
	}

	public void setGravatar_id(String gravatar_id) {
		this.gravatar_id = gravatar_id;
	}
	
	/**
	 * @return
	 * <p>Return a String that represent the <i>html_url</i></p>
	 * */
	public String getHtml_url() {
		return html_url;
	}

	public void setHtml_url(String html_url) {
		this.html_url = html_url;
	}
	
	/**
	 * <p>The String returned by this method contains a URL for a list of all {@link User}'s that are
	 * following this {@link Contributor}</p>
	 * @return
	 * <p>Reeturn a String that represent the <i>followers_url</i></p>
	 * */
	public String getFollowers_url() {
		return followers_url;
	}

	public void setFollowers_url(String followers_url) {
		this.followers_url = followers_url;
	}

	/**
	 * <p>The String returned by this method contains a URL for a list of {@link User}'s
	 *  that this {@link Contributor} are following</p>
	 * @return
	 * <p>Reeturn a String that represent the <i>following_url</i></p>
	 * */
	public String getFollowing_url() {
		return following_url;
	}

	public void setFollowing_url(String following_url) {
		this.following_url = following_url;
	}
	
	/**
	 * @return
	 * <p>Return a String that represent the <i>gists_url</i></p>
	 * */
	public String getGists_url() {
		return gists_url;
	}

	public void setGists_url(String gists_url) {
		this.gists_url = gists_url;
	}

	/**
	 * @return
	 * <p>Return a String that represent the <i>starred_url</i></p>
	 * */
	public String getStarred_url() {
		return starred_url;
	}

	public void setStarred_url(String starred_url) {
		this.starred_url = starred_url;
	}
	
	
	/**
	 * @return
	 * <p>Return a String that represent the <i>subscriptions_url</i></p>
	 * */
	public String getSubscriptions_url() {
		return subscriptions_url;
	}

	public void setSubscriptions_url(String subscriptions_url) {
		this.subscriptions_url = subscriptions_url;
	}
	
	/**
	 * @return
	 * <p>Return a String that represent the <i>repos_url</i></p>
	 * */
	public String getRepos_url() {
		return repos_url;
	}

	public void setRepos_url(String repos_url) {
		this.repos_url = repos_url;
	}

	/**
	 * @return
	 * <p>Return a String that represent the <i>events_url</i></p>
	 * */
	public String getEvents_url() {
		return events_url;
	}

	public void setEvents_url(String events_url) {
		this.events_url = events_url;
	}

	/**
	 * @return
	 * <p>Returns a String that represents the <i>receveid_events_url</i> </p>
	 * */
	public String getReceived_events_url() {
		return received_events_url;
	}
	
	
	public void setReceived_events_url(String received_events_url) {
		this.received_events_url = received_events_url;
	}
	
	/**
	 * @return
	 * <p>Return a String that represents the {@link Contributor} type</p>
	 * */
	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}
	
	/**
	 * Informs is this {@link Contributor} is the site admin
	 * @return
	 * <p>A boolean that represents if the user is the site admin</p>
	 * */
	public boolean isSite_admin() {
		return site_admin;
	}

	public void setSite_admin(boolean site_admin) {
		this.site_admin = site_admin;
	}

	/**
	 * Informs the <b> number of contributions </b> of this {@link Contributor} in the {@link Project}
	 * @return
	 * <p>A integer that represents the number of contributions</p>
	 * */
	public int getContributions() {
		return contributions;
	}

	public void setContributions(int contributions) {
		this.contributions = contributions;
	}
	
    
    /**
     * <p>Two {@link Contributor} objects X and Y are the same <i>if and only</i> if both X and Y have the <b>same login</b> attribute </p>
     * @param 
     <p>A <i>Contributor</i> object that will be compared with the <i>Contributor</i> object in question: </p>
     * @return
     * 	<p><b>true</b> <i>if and only if</i> they have the same loging.</p>
     *  <p><b>else</b> otherwise.</p> 
     */
    public boolean equals(Contributor contributor) {
    	return this.login.equalsIgnoreCase(contributor.login);
    }
	
	/**<p>A {@link Contributor} does not have a API URL so we redirect to his {@link User} URL defined by his <i>login</i>.</p>
	 * 
	 * @return
	 * <p>A String to the URL that contains all information about the <i>User</i> that represent this <i>Contributor</i></p>
	 * */
	public String getURL() {
		return String.format("https://api.github.com/users/%s", this.getLogin());
	}
	

	
 
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Crawlindex.java
package entity;

public class Crawlindex {
	private int project_id;
	
	private int commit_page;
	
	private int comment_page;
	
	private int issue_page;
	
	private int release_page;
	
	private int upbrelease_page;
	
	private int contributor_page;
	
	private int milestone_page;
	
	private int pullrequest_page;
	
	private int user_page;
	
	private int release_idx;
	
	private int closed_issue_page;
	
	public Crawlindex(){
		super();
	}
		

	public Crawlindex(int project_id, int commit_page, int comment_page,
			int issue_page, int release_page, int upbrelease_page,
			int contributor_page, int milestone_page, int pullrequest_page,
			int user_page, int release_idx,int closed_issue_page) {
		super();
		this.project_id = project_id;
		this.commit_page = commit_page;
		this.comment_page = comment_page;
		this.issue_page = issue_page;
		this.release_page = release_page;
		this.upbrelease_page = upbrelease_page;
		this.contributor_page = contributor_page;
		this.milestone_page = milestone_page;
		this.pullrequest_page = pullrequest_page;
		this.user_page = user_page;
		this.release_idx = release_idx;
		this.closed_issue_page = closed_issue_page;
	}


	public int getRelease_idx() {
		return release_idx;
	}


	public void setRelease_idx(int release_idx) {
		this.release_idx = release_idx;
	}




	public int getContributor_page() {
		return contributor_page;
	}




	public void setContributor_page(int contributor_page) {
		this.contributor_page = contributor_page;
	}




	public int getMilestone_page() {
		return milestone_page;
	}




	public void setMilestone_page(int milestone_page) {
		this.milestone_page = milestone_page;
	}




	public int getPullrequest_page() {
		return pullrequest_page;
	}




	public void setPullrequest_page(int pullrequest_page) {
		this.pullrequest_page = pullrequest_page;
	}




	public int getUser_page() {
		return user_page;
	}




	public void setUser_page(int user_page) {
		this.user_page = user_page;
	}




	public int getProject_id() {
		return project_id;
	}
	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	public int getCommit_page() {
		return commit_page;
	}
	public void setCommit_page(int commit_page) {
		this.commit_page = commit_page;
	}
	public int getComment_page() {
		return comment_page;
	}
	public void setComment_page(int comment_page) {
		this.comment_page = comment_page;
	}
	public int getIssue_page() {
		return issue_page;
	}
	public void setIssue_page(int issue_page) {
		this.issue_page = issue_page;
	}
	public int getRelease_page() {
		return release_page;
	}
	public void setRelease_page(int release_page) {
		this.release_page = release_page;
	}
	public int getUpbrelease_page() {
		return upbrelease_page;
	}
	public void setUpbrelease_page(int upbrelease_page) {
		this.upbrelease_page = upbrelease_page;
	}


	public int getClosed_issue_page() {
		return closed_issue_page;
	}


	public void setClosed_issue_page(int closed_issue_page) {
		this.closed_issue_page = closed_issue_page;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\GitHubEntity.java
package entity;

/**
 * Base interface for all GitHub API entities representations 
 * 
 *
 */
public abstract class GitHubEntity {
	
	/**
	 * Returns the Entity's API URL
	 * @return a String 
	 */
	public abstract String getURL();
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\GroundhogException.java
package entity;

/**
 * The base {@link Exception} type. All exceptions must
 * extend this class.
 * 
 * 
 */
public class GroundhogException extends RuntimeException {
	private static final long serialVersionUID = -3563928567447310893L;

	public GroundhogException() {
		super();
	}

	public GroundhogException(String msg) {
		super(msg);
	}

	public GroundhogException(Throwable cause) {
		super(cause);
	}

	public GroundhogException(String msg, Throwable cause) {
		super(msg, cause);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Issue.java
package entity;

import java.util.Date;
import java.util.List;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;



import com.google.gson.annotations.SerializedName;

/**
 * Represents an Issue object 
 * 
 */
@Entity("issues")
public class Issue extends GitHubEntity {
    @Indexed(unique=true, dropDups=true)
    @SerializedName("id")
	@Id private int id;

	@SerializedName("number")
	private int number;

	@SerializedName("comments")
	private int commentsCount;

	@Reference private Project project;

	@SerializedName("pull_request")
	private transient PullRequest pullRequest;

    private List<IssueLabel> labels;
    
	@Reference private Milestone milestone;

	@SerializedName("title")
	private String title;

	@SerializedName("body")
	private String body;

	@SerializedName("state")
	private String state;

	@SerializedName("assignee")
	private User assignee;

	@SerializedName("closed_by")
	private User closedBy;

	@SerializedName("created_at")
	private Date createdAt;

	@SerializedName("updated_at")
	private Date updatedAt;

	@SerializedName("closed_at")
	private Date closedAt;

	public Issue(){
		super();
	}
	
	public Issue(Project project, int number, String state) {
		this.number = number;
		this.project = project;
		this.state = state;
	}

	public Issue(Project project, int number, String state, String title) {
		this(project, number, state);
		this.title = title;
	}

	/**
	 * Returns the ID of the Issue on GitHub. This ID is unique for every Issue on GitHub, which means that
	 * no two (or more) Issues on GitHub may have the same ID
	 * @return
	 */
	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}

	/**
	 * Returns the number of the Issue on its Project. This number is unique within the project to which
	 * the Issues belong. Thus, the same project may not have two Issues with the same number but two (or more)
	 * different projects on GitHub may have Issues with the same number. 
	 * @return
	 */
	public int getNumber() {
		return this.number;
	}

	public void setNumber(int number) {
		this.number = number;
	}

	/**
	 * Informs the number of comments on the Issue
	 * @return
	 */
	public int getCommentsCount() {
		return this.commentsCount;
	}

	public void setCommentsCount(int commentsCount) {
		this.commentsCount = commentsCount;
	}

	/**
	 * Informs the Project object to which the Issue belongs
	 * No Issue exists without a project
	 * @return
	 */
	public Project getProject() {
		return this.project;
	}

	public void setProject(Project project) {
		this.project = project;
	}

	/**
	 * Informs the PullRequest related to the Issue. Not all Issues are Pull Request Issues.
	 * If this method return nulls then it means the Issue is not a PullRequest Issue
	 * @return
	 */
	public PullRequest getPullRequest() {
		return this.pullRequest;
	}

	public void setPullRequest(PullRequest pullRequest) {
		this.pullRequest = pullRequest;
	}

	public List<IssueLabel> getLabels() {
		return this.labels;
	}

	public void setLabels(List<IssueLabel> labels) {
		this.labels = labels;
	}

	public Milestone getMilestone() {
		return this.milestone;
	}

	public void setMilestone(Milestone milestone) {
		this.milestone = milestone;
	}

	/**
	 * Returns the title of the Issue
	 * @return
	 */
	public String getTitle() {
		return this.title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	/**
	 * Returns the Markdown-syntax-based description of the Issue
	 * @return
	 */
	public String getBody() {
		return this.body;
	}

	public void setBody(String body) {
		this.body = body;
	}

	/**
	 * Returns the current state of the Issue. Possible values are "open" and "closed"
	 * @return
	 */
	public String getState() {
		return this.state;
	}

	public void setState(String state) {
		this.state = state;
	}

	/**
	 * Returns the User assigned to that Issue.
	 * An Issue on GitHub may or may not have an assignee
	 * @return
	 */
	public User getAssignee() {
		return this.assignee;
	}

	public void setAssignee(User assignee) {
		this.assignee = assignee;
	}

	/**
	 * Informs the User who closed the Issue
	 * Every Issue gets closed by someone, so if this value is null
	 * then the Issue is currently open
	 * @return
	 */
	public User getClosedBy() {
		return this.closedBy;
	}

	public void setClosedBy(User closedBy) {
		this.closedBy = closedBy;
	}

	/**
	 * Informs the creation date of the Issue on GitHub
	 * @return
	 */
	public Date getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}

	/**
	 * Informs the date when the last modification was made upon the issue
	 * @return
	 */
	public Date getUpdatedAt() {
		return this.updatedAt;
	}

	public void setUpdatedAt(Date updatedAt) {
		this.updatedAt = updatedAt;
	}

	/**
	 * Informs the date when the Issue was closed
	 * If the value is null it means the issue is open
	 * @return
	 */
	public Date getClosedAt() {
		return this.closedAt;
	}

	public void setClosedAt(Date closedAt) {
		this.closedAt = closedAt;
	}

	/**
	 * Returns <code>true</code> if this Issue's state equals open, i.e., if
	 * <code>"open".equals(this.getState())</code> is <code>true</code>
	 * @return
	 */
	public boolean isOpen() {
		return "open".equals(this.getState());
	}

	/**
	 * Returns true if the Issue is a Pull Request Issue. Returns false otherwise
	 * @return
	 */
	public boolean isPullRequest() {
		return this.getPullRequest() != null ? true : false;
	}
	
	/**
	 * Two {@link Issue} objects are considered equal when they have the same GitHub API ID,
	 * the same number and the same {@link Project}. 
	 * @param issue
	 * @return
	 */
	public boolean equals(Issue issue) {
		return this.id == issue.id && this.number == issue.number && this.project.equals(issue.getProject());
	}
	
	public String getURL() {
		return String.format("https://api.github.com/repos/%s/%s/issues/%d",
				this.getProject().getOwner().getLogin(), this.getProject().getName(), this.getNumber());
	} 

	@Override
	public String toString() {
		String stringReturn = "Issue Number = "  + this.number;
		
		if (this.title != null) {
			stringReturn += ", title: " + this.title;
		}
		
		String url = this.getURL(); // This class doesn't contains a variable referring a URL, so we create one local
		
		if (url != null) {
			stringReturn += ", URL = " + url;   
		}
		
		return stringReturn;  
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\IssueLabel.java
package entity;

import org.mongodb.morphia.annotations.Entity;

import com.google.gson.annotations.SerializedName;

/**
 * This class does not represent a full-fledged GitHub entity.
 *  It is just for the Issue labels
 *  
 * 
 *
 */

@Entity("issue_labels")
public class IssueLabel {
	@SerializedName("url")
	private String url;
	
	@SerializedName("name")
	private String name;
	
	@SerializedName("color")
	private String color;
	
	public IssueLabel(String url, String name, String color) {
		this.url = url;
		this.name = name;
		this.color = color;
	}
	
	public String getUrl() {
		return this.url;
	}
	
	public void setUrl(String url) {
		this.url = url;
	}
	
	public String getName() {
		return this.name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getColor() {
		return this.color;
	}
	
	public void setColor(String color) {
		this.color = color;
	}

	@Override
	public String toString() {
		return "IssueLabel [" + (url != null ? "url=" + url + ", " : "")
				+ (name != null ? "name=" + name + ", " : "")
				+ (color != null ? "color=" + color : "") + "]";
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Language.java
package entity;

import org.mongodb.morphia.annotations.Entity;



/**
 * Represents languages - an important set of components of a {@link Project} -
 * . This class is only important/meaningful in the context of
 * Projects. As a representation of the programming language composition of such
 * objects.
 * 
 * 
 * 
 */
@Entity("languages")
public class Language implements Comparable<Language> {
	public static final String JAVA = "Java";
	
	private String name;
	private int byteCount;
	
	public Language(String name, int byteCount) {
		this.name = name;
		this.byteCount = byteCount;
	}

	/**
	 * Informs the language name
	 * @return a {@link String} object
	 */
	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Informs the byte count of the language in its project
	 *  @return a {@link String} object
	 */
	public int getByteCount() {
		return this.byteCount;
	}

	public void setByteCount(int byteCount) {
		this.byteCount = byteCount;
	}

	@Override
	public int compareTo(Language o) {
		if (this.getByteCount() < o.getByteCount()) return -1;
		if (this.getByteCount() > o.getByteCount()) return 1;
		
		return 0;
	}
	
	public String toString() {
		return this.name;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\License.java
package entity;

import org.mongodb.morphia.annotations.Entity;


/**
 * Represents the License used in the {@link Project}
 * 
 */
@Entity("licenses")
public class License {

	private String name;
	private String entireContent;
	private String version;

	public License(String name) {
		this.name = name;
	}

	public License(String name, String entireContent) {
		this.entireContent = entireContent;
	}

	public String getName() {
		return this.name;
	}

	public String getEntireContent() {
		return this.entireContent;
	}
	
	public String getVersion() {
		return this.version;
	}
	
	public String toString() {
		return this.name;
	}
	
	/**
	 * Two {@link License} objects are considered equal when they both have the same name and version
	 * @param lic
	 * @return
	 */
	public boolean equals(License lic) {
		return this.name == lic.getName() && this.version == lic.version;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Milestone.java
package entity;

import java.util.Date;
import java.util.List;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;


import com.google.gson.annotations.SerializedName;

/**
 * Represents a Milestone object 
 * 
 */
@Entity("milestones")
public class Milestone extends GitHubEntity {
    @Indexed(unique=true, dropDups=true)
	@SerializedName("id")
	@Id private int id;
	
	@SerializedName("number")
	private int number;
	
	@Reference private Project project;

	@SerializedName("state")
	private String state;
	
	@SerializedName("title")
	private String title;
	
	@SerializedName("description")
	private String description;
	
	@SerializedName("creator")
	@Reference private User creator;
	
    private List<IssueLabel> labels;
	
	@SerializedName("open_issues")
	private int openIssuesCount;
	
	@SerializedName("closed_issues")
	private int closedIssuesCount;
	
	@SerializedName("created_at")
	private Date createdAt;
	
	@SerializedName("updated_at")
	private Date updatedAt;
	
	@SerializedName("due_on")
	private Date dueOn;
	
	/**
	 * Default constructor for {@link Milestone} objects
	 * @param project the {@link Project} to which the {@link Milestone} belongs
	 * @param id the GitHub API ID of the {@link Milestone}
	 * @param number the number of the {@link Milestone}
	 * @param state the state of the {@link Milestone}
	 */
	public Milestone(Project project, int id, int number, String state) {
		this.project = project;
		this.id = id;
		this.number = number;
		this.state = state;
	}
	
	public Milestone(Project project, int id, int number, String state, String title) {
		this(project, id, number, state);
		this.title = title;
	}
	
	/**
	 * Informs the Milestone ID on GitHub. This id is unique to GitHub. No two Milestones can exist on GitHub
	 * with the same ID
	 * @return
	 */
	public int getId() {
		return this.id;
	}
	
	public void setId(int newId) {
		this.id = newId;
	}
	
	/**
	 * Informs the number of the Milestone. This attribute is unique in respect to the Milestone's {@link Project}.
	 * No two Milestones can exist with the same number in the same Project
	 * @return
	 */
	public int getNumber() {
		return this.number;
	}

	public void setNumber(int number) {
		this.number = number;
	}
	
	/**
	 * Informs the {@link Project} object to which the {@link Milestone} belongs
	 * @return a {@link Project} object
	 */
	public Project getProject() {
		return this.project;
	}

	public void setProject(Project project) {
		this.project = project;
	}

	/**
	 * Returns the state of the Milestone. Valid values are "open" and "closed"
	 * @return
	 */
	public String getState() {
		return this.state;
	}

	public void setState(String state) {
		this.state = state;
	}

	/**
	 * Informs the title of the Milestone
	 * @return a String
	 */
	public String getTitle() {
		return this.title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	/**
	 * Informs the description of the Milestone
	 * @return
	 */
	public String getDescription() {
		return this.description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	/**
	 * Informs the {@link User} who created the Milestone
	 * @return a {@link User} object
	 */
	public User getCreator() {
		return this.creator;
	}

	public void setCreator(User creator) {
		this.creator = creator;
	}
	
	public List<IssueLabel> getLabels() {
		return this.labels;
	}

	public void setLabels(List<IssueLabel> labels) {
		this.labels = labels;
	}

	/**
	 * Informs the number of open Issues currently in the {@link Milestone}
	 * @return an integer value
	 */
	public int getOpenIssuesCount() {
		return this.openIssuesCount;
	}

	public void setOpenIssuesCount(int openIssuesCount) {
		this.openIssuesCount = openIssuesCount;
	}

	/**
	 * Informs the number of closed Issues currently in the {@link Milestone}
	 * @return an integer value
	 */
	public int getClosedIssuesCount() {
		return this.closedIssuesCount;
	}

	public void setClosedIssuesCount(int closedIssuesCount) {
		this.closedIssuesCount = closedIssuesCount;
	}
	
	/**
	 * Informs the total number of Issues in the {@link Milestone}
	 * @return an integer value
	 */
	public int getIssuesCount() {
		return this.getOpenIssuesCount() + this.getClosedIssuesCount();
	}

	/**
	 * Informs the creation date of the Milestone
	 * @return a {@link Date} object
	 */
	public Date getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}
	
	/**
	 * Informs the update date of the Milestone
	 * @return a {@link Date} object
	 */
	public Date getUpdatedAt() {
		return this.updatedAt;
	}
	
	public void setUpdateAt(Date updatedAt) {
		this.updatedAt = updatedAt;
	}
	
	/**
	 * Informs the date when the Milestone is due to
	 * @return a {@link Date} object
	 */
	public Date getDueOn() {
		return this.dueOn;
	}

	public void setDueOn(Date dueOn) {
		this.dueOn = dueOn;
	}

	/**
	 * Two {@link Milestone} objects are considered equal when they have the same GitHub API ID,
	 * the same number and belong to the same {@link Project}. 
	 * @param issue
	 * @return
	 */
	public boolean equals(Milestone ms) {
		return this.id == ms.id && this.number == ms.number && this.project.equals(ms.getProject());
	}
	
	@Override
	public String getURL() {
		String result = String.format("https://api.github.com/repos/%s/%s/issues/%d",
				this.getProject().getOwner().getLogin(), this.getProject().getName(), this.getNumber());
		
		return result;
	}

	@Override
	public String toString() {
		return "Milestone number = " + number + ", "
				+ (this.state != null ? "state = " + this.state + ", " : "")
				+ (this.title != null ? "title = " + this.title + ", " : "")
				+ (this.getURL() != null ? "url= " + this.getURL() : " ");
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Project.java
package entity;

import java.util.Date;
import java.util.List;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;

import util.Dates;

import com.google.gson.annotations.SerializedName;



/**
 * <h1>Project -  <i>Represents a software project </i> </h1> 
 * <p>
 * 	This Class support the base and maybe the most important Class, because like
 *  we can found at <a href="http://en.wikipedia.org/wiki/GitHub"><i>Wikipedia</i></a> <i>"GitHub is a web-based hosting service for software development projects that use the Git revision control system."</i>. 
 *  A Project object contains all entities that in some way are connected. 
 *  A user want to extract metrics from projects hosted on <a href="https://github.com/"><i>Github</i></a>, so this Class can give support to all data that a project can have 
 *	and consequently extract metrics from these. 
 * </p>
 *  
 * 
 */

@Entity("projects")
public class Project extends GitHubEntity {
	@SerializedName("id")
	@Indexed(unique=true, dropDups=true)
	@Id private int id;
	
	@SerializedName("name")
	private String name;

	@SerializedName("description")
	private String description;

	@SerializedName("language")
	private String language;
	private List<Language> languages;
	
	@Reference private List<Issue> issues;
	@Reference private List<Milestone> milestones;
	@Reference private List<Commit> commits;
	@Reference private List<Contributor> contributors;

	@Reference private User user;

	@SerializedName("clone_url")
	private String checkoutURL;

	@SerializedName("html_url")
	private String sourceCodeURL;

	@SerializedName("created_at")
	private Date createdAt;

	@SerializedName("pushed_at")
	private Date lastPushedAt;

	@SerializedName("fork")
	private boolean isFork;

	@SerializedName("has_downloads")
	private boolean hasDownloads;

	@SerializedName("has_issues")
	private boolean hasIssues;

	@SerializedName("has_wiki")
	private boolean hasWiki;

	@SerializedName("watchers_count")
	private int watchersCount;

	@SerializedName("forks")
	private int forks_count;

	@SerializedName("open_issues_count")
	private int issuesCount;

	public Project(){
		super();
	}
	
	/**
	 * 2-parameter complimentary constructor
	 * @param user the {@link User} to who the project belongs
	 * @param name the name of the {@link Project}
	 */
	public Project(User user, String name) {
		this.user = user;
		this.name = name;
		this.checkoutURL = "https://github.com/" + user.getLogin() + "/" + name + ".git";
		this.sourceCodeURL = "https://github.com/" + user.getLogin() + "/" + name;
	}
	
	/**
	 * 3-parameter constructor
	 * @param name the project name
	 * @param description the project description
	 * @param checkoutURL the project's source code URL
	 */
	public Project(String name, String description, String checkoutURL) {
		this.name = name;
		this.description = description;
		this.checkoutURL = checkoutURL;
	}

	
	
	/**
	 * Informs the name of the project
	 * @return the name of the project
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Sets the name of the project
	 * @param name a {@link String} for the project's name
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Informs the description of the project
	 * @return the String description of the project
	 */
	public String getDescription() {
		return this.description;
	}

	/**
	 * Sets the description of the project
	 * @param description a String for setting the description
	 */
	public void setDescription(String description) {
		this.description = description;
	}

	/**
	 * Informs the project's author name
	 * @return a String correspondent to the name of the author of the project
	 */
	public User getOwner() {
		return this.user;
	}

	/**
	 * Informs the project's author name
	 * @param owner a {@link String} for the name of the project's author
	 */
	public void setOwner(User owner) {
		this.user = owner;
	}

	/**
	 * Informs the project's SCM
	 * @return
	 * @deprecated
	 */
	public SCM getSCM() {
		throw new UnsupportedOperationException("This method is not supported anymore.");
	}

	public void setSCM(SCM hg) {
		throw new UnsupportedOperationException("This method is not supported anymore.");
	}
	
	/**
	 * Informs the project's SCM URL
	 * @return
	 */
	public String getCheckoutURL() {
		return this.checkoutURL;
	}

	/**
	 * Sets the project's SCM URL
	 * @param scmURL
	 */
	public void setCheckoutURL(String scmURL) {
		this.checkoutURL = scmURL;
	}

	/**
	 * Informs the source code URL of the project
	 * @return a String correspondent to the source code URL of the project in question
	 */
//	public String getSourceCodeURL() {
//		return this.sourceCodeURL;
//	}

	/**
	 * Sets the source code URL for the project
	 * @param sourceCodeURL sets the URL String of the project's source code
	 */
//	public void setSourceCodeURL(String sourceCodeURL) {
//		this.sourceCodeURL = sourceCodeURL;
//	}

	/**
	 * Informs whether a project allow downloads or not
	 * @return true if the project allows source code download. Returns false otherwise.
	 */
	public boolean hasDownloads() {
		return this.hasDownloads;
	}

	/**
	 * Sets if a project allows downloads or not
	 * @param hasDownloads a {@link boolean} for setting whether the project enables downloads or not
	 */
	public void setHasDownloads(boolean hasDownloads) {
		this.hasDownloads = hasDownloads;
	}

	/**
	 * @return true if the project has issues. Returns false otherwise.
	 */
	public boolean hasIssues() {
		return this.hasIssues;
	}

	/**
	 * @param hasIssues a boolean value for setting if the project has Issues or not
	 */
	public void setHasIssues(boolean hasIssues) {
		this.hasIssues = hasIssues;
	}

	/**
	 * Informs whether the project has its own Wiki or not.
	 * @return true if the project has a Wiki. Returns false otherwise.
	 */
	public boolean hasWiki() {
		return this.hasWiki;
	}

	/**
	 * Sets whether a project has its own Wiki or not.
	 * @param hasWiki a {@link boolean} for setting whether the project has a Wiki or not.
	 */
	public void setHasWiki(boolean hasWiki) {
		this.hasWiki = hasWiki;
	}

	/**
	 * Informs how many people are watching the project or have "starred" it
	 * @return an {@link integer} informing how many people are currently watching the project on its forge
	 */
	public int getWatchersCount() {
		return this.watchersCount;
	}

	/**
	 * Sets how many people are watching the project
	 * @param watchersCount an integer for setting the number of people watching the project on its forge
	 */
	public void setWatchersCount(int watchersCount) {
		this.watchersCount = watchersCount;
	}

	/**
	 * Informs the number of forks the project has
	 * @return an integer correspondent to the number of forks
	 */
	public int getForksCount() {
		return this.forks_count;
	}

	/**
	 * An indicator of how many times the project has been forked.
	 * @param forksCount an integer for setting the number of forks the project has.
	 */
	public void setForksCount(int forksCount) {
		this.forks_count = forksCount;
	}

	/**
	 *
	 * Informs the number of open issues of the project
	 * @return an integer value correspondent to the amount of open issues
	 */
	public int getIssuesCount() {
		return this.issuesCount;
	}

	/**
	 * Sets the number of issues of a project
	 * @param issuesCount an integer for setting the number of Issues of the project
	 */
	public void setIssuesCount(int issuesCount) {
		this.issuesCount = issuesCount;
	}

	/**
	 * Tells whether a project is a fork of another or not
	 * @return a boolean value: true if it's a fork, false otherwise
	 */
	public boolean isFork() {
		return this.isFork;
	}

	/**
	 * Sets if the project is a fork of another or not
	 * @param value a boolean value for informing whether the project is a fork of another or not
	 */
	public void setIsFork(boolean value) {
		this.isFork = value;
	}

	/**
	 * Methods that deal with dates are below
	 * Notice that each setter method is overloaded to support Date and String parameters.
	 * When the parameter is provided as a String object, the setter method will perform the
	 * conversion to a date object
	 */

	/**
	 * Informs the creation date of the project
	 * @return a Date object correspondent to the project's creation date
	 */
	public Date getCreatedAt() {
		return this.createdAt;
	}

	/**
	 * Sets the creation date of the project
	 * @param createdAt a Date object for setting the creation date of the project
	 */
	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}

	/**
	 * @param createdAtParam the String correspondent to the creation date of the project in question. e.g: 2012-04-28T15:40:35Z
	 */
	public void setCreatedAt(String createdAtParam) {
		if(createdAtParam.length() >10){
			Date createAtDate = new Dates("yyyy-MM-dd HH:mm:ss").format(createdAtParam);
			this.createdAt = createAtDate;
		}
		else{
			Date createAtDate = new Dates("yyyy-MM-dd").format(createdAtParam);
			this.createdAt = createAtDate;
		}
	}

	/**
	 * Returns the date of the latest push to the project
	 * @return a Date object of the latest push
	 */
	public Date getLastPushedAt() {
		return this.lastPushedAt;
	}

	/**
	 * Sets the date on which the last push has been submitted to the project's source code
	 * @param lastPushedAtParam the Date object correspondent to the date of the last push to the project
	 * in question
	 */
	public void setLastPushedAt(Date lastPushedAtParam) {
		this.lastPushedAt = lastPushedAtParam;
	}

	/**
	 * @param lastPushedAtParam the String correspondent to the date of the last push to the project
	 * in question. e.g: 2012-04-28T15:40:35Z
	 */
	public void setLastPushedAt(String lastPushedAtParam){
		if(lastPushedAtParam.length() >10){
			Date createAtDate = new Dates("yyyy-MM-dd HH:mm:ss").format(lastPushedAtParam);
			this.lastPushedAt = createAtDate;
		}
		else{
			Date createAtDate = new Dates("yyyy-MM-dd").format(lastPushedAtParam);
			this.lastPushedAt = createAtDate;
		}
	}

	/**
	 * Informs the name of prevailing programming language in a project
	 * @return name of programming language
	 */
	public String getLanguage() {
		return this.language;
	}

	/**
	 * Sets the name of prevailing programming language in a project
	 */
	public void setLanguage(String language) {
		this.language = language;
	}

	/**
	 * Returns the list of languages that compose the Project
	 * @return a {@link List} of {@link Language} objects
	 */
	public List<Language> getLanguages() {
		return this.languages;
	}

	/**
	 * Sets the list of languages that compose the Project
	 * @param a {@link List} of {@link Language} objects
	 */
	public void setLanguages(List<Language> langs) {
		this.languages = langs;
	}
	
	/**
	 * Returns the list of milestones of the Project
	 * @return a {@link List} of {@link Milestone} objects
	 */
	public List<Milestone> getMilestones() {
		return this.milestones;
	}

	public void setMilestones(List<Milestone> milestones) {
		this.milestones = milestones;
	}
	
	/**
	 * Returns the list of issues of the project
	 * @return a {@link List} of {@link Issue} objects
	 */
	public List<Issue> getIssues() {
		return this.issues;
	}
	
	public void setIssues(List<Issue> issues) {
		this.issues = issues;
	}
	
	/**
	 * Returns the list of commits of the project
	 * @return a {@link List} of {@link Commit} objects
	 */
	public List<Commit> getCommits() {
		return this.commits;
	}
	
	public void setCommits(List<Commit> commits) {
		this.commits = commits;
	}
	
	/**
	 * Returns the list of contributors of the project as GitHub users
	 * @return
	 */
	public List<Contributor> getContributors() {
		return this.contributors;
	}
	
	public void setContributors(List<Contributor> contributors) {
		this.contributors = contributors;
	}

	/**
	 * Returns the {@link User} object who is the author of the Project
	 * @return
	 */
	public User getUser() {
		return this.user;
	}

	/**
	 * Sets the {@link User} object who is the author of the Project
	 * @param user
	 */
	public void setUser(User user) {
		this.user = user;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	/**
	 * Return true if the project is considered mature
	 * 
	 * A project is considered active if it has at least 1 {@link Commit} and more the
	 * 1 contributor
	 * 
	 * @return
	 */
	public boolean isActive() {
		if (commits == null && contributors == null) {
			return false;
		} else {
			return ((commits.size() > 1) && (contributors.size() > 2));			
		}
	}
	
	/**
	 * Returns true if the project is considered mature, and false otherwise.
	 * 
	 * A project is considered mature if it has at least three watchers, plus
	 * one fork, plus more than 100 commits in its own history, and more than
	 * five issues created in its own history.
	 * 
	 * @return
	 */
	public boolean isMature() {
		return ((watchersCount > 3) && (forks_count > 1) && (commits.size() > 100) && (issues.size() > 5));
	}
	
	/**
	 * Returns the well-formated github rest-api for this project
	 * @return 
	 */
	public String getURL() {
		return String.format("https://api.github.com/repos/%s/%s", this.getUser().getLogin(), this.getName());
	}

	/**
	 * If two projects have the same ID, then they are equals.
	 * */
	public boolean equals(Project project){
		if(this.id == project.getId()){
			return true;
		}
		else{
			return false;
		}
	}
	
	@Override
	public String toString() {
		return String.format("Project(%s, %s)", this.name, this.sourceCodeURL);
	}

	public String getSourceCodeURL() {
		return sourceCodeURL;
	}

	public void setSourceCodeURL(String sourceCodeURL) {
		this.sourceCodeURL = sourceCodeURL;
	}
	
	/**
	 * this method only used to transform to project used in gitcrawler database
	 * @param codes
	 * @return
	 */
	public usefuldata.Project ProjectTransform(int codes,String owner){
		usefuldata.Project p = new usefuldata.Project();
		p.setId(this.getId());
		p.setName(this.getName());
		p.setOwner(owner);
		p.setDescription(this.getDescription());
		p.setCodes(codes);
		
		return p;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\PullRequest.java
package entity;

import java.util.Date;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;

import com.google.gson.annotations.SerializedName;

/**
 * Represents a Pull Request object 
 * 
 */
@Entity("pull_requests")
public class PullRequest extends Issue  {
	@SerializedName("id")
	@Id private int id;

	@SerializedName("merged_at")
	private Date mergedAt;
	
	@SerializedName("merge_commit_sha")
    @Indexed(unique=true, dropDups=true)
	private String mergeCommitSha;
	
	@SerializedName("review_comments_url")
	private int reviewCommentsCount;
	
	@SerializedName("commits")
	private int commitsCount;
	
	@SerializedName("merged")
	private boolean merged;
	
	@SerializedName("mergeable")
	private boolean mergeable;
	
	@SerializedName("mergeable_state")
	private String mergeableState;
	
	@SerializedName("merged_by")
	private User mergedBy;
	
	// Code content
	@SerializedName("additions")
	private int additionsCount;
	
	@SerializedName("deletions")
	private int deletionsCount;
	
	@SerializedName("changed_files")
	private int changedFilesCount;
  	
	public PullRequest(int number, Project project, String state) {
		super(project, number, state);
	}

	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}
	
	/**
	 * Returns the merge date of the Pull Request
	 * @return
	 */
	public Date getMergedAt() {
		return this.mergedAt;
	}

	public void setMergedAt(Date mergedAt) {
		this.mergedAt = mergedAt;
	}

	/**
	 * Returns the SHA String of the merge commit
	 * @return
	 */
	public String getMergeCommitSha() {
		return this.mergeCommitSha;
	}

	public void setMergeCommitSha(String mergeCommitSha) {
		this.mergeCommitSha = mergeCommitSha;
	}

	/**
	 * Returns the sum of comments written in the code diffs of commits belonging to the Pull Request
	 * @return
	 */
	public int getReviewCommentsCount() {
		return this.reviewCommentsCount;
	}

	public void setReviewCommentsCount(int reviewCommentsCount) {
		this.reviewCommentsCount = reviewCommentsCount;
	}

	/**
	 * Returns the sum of all commits contained in the Pull Request
	 * @return
	 */
	public int getCommitsCount() {
		return this.commitsCount;
	}

	public void setCommitsCount(int commitsCount) {
		this.commitsCount = commitsCount;
	}

	/**
	 * Returns true if the PR has been merged. Returns false otherwise.
	 * @return
	 */
	public boolean isMerged() {
		return this.merged;
	}

	public void setMerged(boolean merged) {
		this.merged = merged;
	}

	/**
	 * Indicates whether a PR can be automatically merged by GitHub or the merge can only be done
	 * by a human (in case of conflict).
	 * @return
	 */
	public boolean isMergeable() {
		return this.mergeable;
	}

	public void setMergeable(boolean mergeable) {
		this.mergeable = mergeable;
	}

	/**
	 * Indicates the "mergeable" state of a Pull Request,
	 * Which determines whether GitHub itself can perform a merge of a PR (when the PR implies no conflicts)
	 * or only a human developer.
	 * 
	 * Possible returns are "clean" and "unknown"
	 * @return
	 */
	public String getMergeableState() {
		return this.mergeableState;
	}

	public void setMergeableState(String mergeableState) {
		this.mergeableState = mergeableState;
	}

	/**
	 * Returns the User who has merged a Pull Request
	 * @return
	 */
	public User getMergedBy() {
		return this.mergedBy;
	}

	public void setMergedBy(User mergedBy) {
		this.mergedBy = mergedBy;
	}

	/**
	 * Indicates the sum of additions in LoC that happened throught the commits of a Pull Request
	 * @return
	 */
	public int getAdditionsCount() {
		return this.additionsCount;
	}

	public void setAdditionsCount(int additionsCount) {
		this.additionsCount = additionsCount;
	}

	/**
	 * Indicates the sum of deletions in LoC that happened throught the commits of a Pull Request
	 * @return
	 */
	public int getDeletionsCount() {
		return this.deletionsCount;
	}

	public void setDeletionsCount(int deletionsCount) {
		this.deletionsCount = deletionsCount;
	}

	/**
	 * Indicates how many files were modified in a Pull Request in respect to the
	 * branch where the merge is supposed to happen
	 * @return
	 */
	public int getChangedFilesCount() {
		return this.changedFilesCount;
	}

	public void setChangedFilesCount(int changedFilesCount) {
		this.changedFilesCount = changedFilesCount;
	}
	
	public String getURL() {
		return String.format("https://api.github.com/repos/%s/%s/pulls/%d", this.getProject().getOwner().getLogin(),
				this.getProject().getName(), this.getNumber());
	}

	@Override
	public String toString() {
		return "PullRequest: number = " + this.getNumber() + ", "
				+ (this.getTitle() != null ? "title = " + this.getTitle() + ", " : "")
				+ (this.getURL() != null ? "URL = " + this.getURL() : "");
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\Release.java
package entity;

import java.util.Date;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;


import com.google.gson.annotations.SerializedName;

/** <h3>This class represents a Release</h3>
 * 
 * <p> <i>"Releases are first-class objects with changelogs and binary 
 * assets that present a full project history beyond Git artifacts.
 *  They're accessible from a repository's homepage" </i> 
 *  - Release description at GitHub oficial website, for more informations you can check at this <a href= https://github.com/blog/1547-release-your-software> link </a>.</p>
 *	 
 *@see
 * <p>This class have a list of attributes whom <b> should be set </b> after the instantiation. These attributes represent the entities of a Release on the GitHub, see they below. </p>
 * <p>The attributes are at form bellow:</p>
 * <p>Class/type attributeName: What he represent </p>  
 * <ul>
 * 		 <li> <b>String</b> tagName: Tag Name of the Release on GitHub. 
 *		 <li> <b>String</b> name: The name of the Release on GitHub.
 *		 <li> <b>String</b> targetCommitish: The Commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Defaults to the repository鈥檚 default branch (usually 鈥渕aster鈥�). Unused if the Git tag already exists.
 *		 <li> <b>String</b> body: The Markdown-syntax-based description of the Release.
 * 		 <li> <b>String</b> assetsUrl: That present a full project history beyond Git artifacts
 * 		 <li> <b>boolean</b> draft: If the Release is a draft (unpublished) or not.
 *		 <li> <b>booelan</b> preRelease: If the Release is or not a full release.
 *		 <li> <b>Date</b> createdAt: When the Release was created.
 *		 <li> <b>Date</b> publishedAt: When the Release was published.
 *		
 * </ul> 	
 * <p> These descriptions can also be seen in the Get methods. </p>
 * 
 * 

 *
 **/

@Entity("releases")
public class Release extends GitHubEntity {
    @Indexed(unique=true, dropDups=true)
	@SerializedName("id")
	@Id private int id;

	@SerializedName("tag_name")
	private String tagName;

	@SerializedName("target_commitish")
	private String targetCommitish;

	@SerializedName("name")
	private String name;

	@SerializedName("assets_url")
	private String assetsUrl;

	@SerializedName("body")
	private String body;

	@SerializedName("draft")
	private boolean draft;

	@SerializedName("preRelease")
	private boolean preRelease;

	@SerializedName("created_at")
	private Date createdAt;

	@SerializedName("published_at")
	private Date publishedAt;

	@Reference private Project project; 

	public Release(Project project, int id) {
		this.project = project;
		this.id = id;
	}

	public Release(Project project, int id, String tagName) {
		this.project = project;
		this.id = id;
		this.tagName = tagName;
	}

	/**
	 * Returns the ID of the Release on GitHub. This ID is unique for every Release on GitHub, which means that
	 * no two (or more) Issues on GitHub may have the same ID
	 * @return
	 */
	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}

	/**
	 * Returns the Tag Name of the Release on GitHub.
	 * @return the tag_name
	 */
	public String getTagName() {
		return this.tagName;
	}

	public void setTagName(String tagName) {
		this.tagName = tagName;
	}

	/**
	 * Returns the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Defaults to the repository鈥檚 default branch (usually 鈥渕aster鈥�). Unused if the Git tag already exists.
	 * @return the target_commitish
	 */
	public String getTargetCommitish() {
		return targetCommitish;
	}

	public void setTargetCommitish(String targetCommitish) {
		this.targetCommitish = targetCommitish;
	}


	/**
	 * Informs the Project object to which the Release belongs
	 * No Release exists without a project
	 * @return the project
	 */
	public Project getProject() {
		return project;
	}

	public void setProject(Project project) {
		this.project = project;
	}


	/**
	 * Returns the name of the Release on GitHub.
	 * @return the name
	 */
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	/**Return the String to Assets url, that present a full project history beyond Git artifacts*/
	public String getAssetsUrl() {
		return this.assetsUrl;
	}

	public void setAssetsUrl(String assetsUrl) {
		this.assetsUrl = assetsUrl;
	}

	/**
	 * Returns the Markdown-syntax-based description of the Release
	 * @return the body
	 */
	public String getBody() {
		return this.body;
	}

	public void setBody(String body) {
		this.body = body;
	}

	/**
	 * Returns true if the Release is a draft (unpublished) or false if it's published
	 * @return the draft
	 */
	public boolean isDraft() {
		return this.draft;
	}

	public void setDraft(boolean draft) {
		this.draft = draft;
	}

	/**
	 * Returns true if the Release is a preRelease or false if the Release is a full release
	 * @return the preRelease
	 */
	public boolean isPreRelease() {
		return this.preRelease;
	}

	public void setPreRelease(boolean preRelease) {
		this.preRelease = preRelease;
	}

	/**
	 * Returns the date when the Release was created
	 * @return the createdAt
	 */
	public Date getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}

	/**
	 * Returns the date when the Release was published
	 * @return the published_at
	 */
	public Date getPublishedAt() {
		return this.publishedAt;
	}

	public void setPublishedAt(Date publishedAt) {
		this.publishedAt = publishedAt;
	}
	
	/**
	 * Two {@link Release} objects are considered equal if and only if they share the same
	 * GitHub API ID and belong to the same {@link Project}
	 * @param rel
	 * @return
	 */
	public boolean equals(Release rel) {
		return this.id == rel.id && this.project.equals(rel.getProject());
	}

	/**Return a String representation of the Release, this String contains (if they are not null):
	 * <ul>
	 * 		<li> The Release id
	 * 		<li> The Target Commitish
	 * 	    <li> A URL representation of the Release	
	 * </ul>
	 * 
	 * */
	@Override
	public String toString() {
		String stringReturn = "Release id = " + this.id;// we always have a Issue number, the programmer must read the doc to contribute
		
		if (this.name != null) stringReturn += ", Name = " + this.name;
		if (this.targetCommitish != null) stringReturn += ", Target Commitish = " + this.targetCommitish;
		
		String url = this.getURL(); // This class doesn't contain a variable referring to a URL, so we create one locally
		if (url != null) stringReturn += ", URL = " + url;
		
		return stringReturn;
	}

	
	/**This method return the URL of the release*/
	@Override
	public String getURL() {
		return String.format("https://api.github.com/repos/%s/%s/releases/%d",
				this.getProject().getOwner().getLogin(),
				this.getProject().getName(), this.id
			  );
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\SCM.java
package entity;

/**
 * Enumerator for the supported source code manager 
 * 
 */
public enum SCM {
	SOURCE_FORGE, GIT, SVN, HG, UNKNOWN, NONE;

	public String toString() {
		return name();
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\UnPublishedRelease.java
package entity;

import org.mongodb.morphia.annotations.Entity;

import com.google.gson.annotations.SerializedName;


@Entity("UnPublishedRelease")
public class UnPublishedRelease extends GitHubEntity{

	private int id;
	
	@SerializedName("name")
	private String name;
	
	@SerializedName("zipball_url")
	private String zipball_url;
	
	@SerializedName("tarball_url")
	private String tarball_url;
	
	
	private String commit_url;
	
	private String date;

	public UnPublishedRelease(){
		super();
	}
	
	public UnPublishedRelease(String name, String zipball_url,
			String tarball_url, String commit_url,String date) {
		super();
		this.name = name;
		this.zipball_url = zipball_url;
		this.tarball_url = tarball_url;
		this.commit_url = commit_url;
		this.date = date;
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getZipball_url() {
		return zipball_url;
	}
	public void setZipball_url(String zipball_url) {
		this.zipball_url = zipball_url;
	}
	public String getTarball_url() {
		return tarball_url;
	}
	public void setTarball_url(String tarball_url) {
		this.tarball_url = tarball_url;
	}
	public String getCommit_url() {
		return commit_url;
	}
	public void setCommit_url(String commit_url) {
		this.commit_url = commit_url;
	}

	public String getDate() {
		return date;
	}

	public void setDate(String date) {
		this.date = date;
	}

	@Override
	public String getURL() {
		return commit_url;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\entity\User.java
package entity;

import java.util.Date;
import java.util.List;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;

import com.google.gson.annotations.SerializedName;

/**
 * Represents a GitHub User 
 * 
 */
@Entity("users")
public class User extends GitHubEntity {
    @SerializedName("id")
    @Indexed(unique=true, dropDups=true)
    @Id private int id;
  
    @SerializedName("name")
    private String name;
  
    @SerializedName("login")
    private String login;
  
    @SerializedName("email")
    private String email;
  
    @SerializedName("company")
    private String company;
  
    @SerializedName("location")
    private String location;
  
    @SerializedName("blog")
    private String blog;
  
    @SerializedName("hireable")
    private boolean hireable;
  
    @SerializedName("followers")
    private int followers;
  
    @SerializedName("following")
    private int following;
  
    @SerializedName("public_repos")
    public int public_repos;
  
    @SerializedName("public_gists")
    public int public_gists;
  
    @SerializedName("created_at")
    private String created_at;
  
    @SerializedName("updated_at")
    private String updated_at;
    
	@Reference private List<Commit> commits;
    private List<String> emailAddresses;
  
    public User(String login) {
    	this.login = login;
    }
  
    public User(String login, String name) {
        this(login);
        this.name = name;
    }
  
    /**
     * Informs the GitHub ID for the {@link User} object in question
     * This ID is unique in GitHub, which means no two users can have the same ID on GitHub
     * @return the integer ID
     */
    public int getId() {
        return this.id;
    }
  
    public void setId(int id) {
        this.id = id;
    }
  
    /**
     * Informs the User name. Useful for measuring commit authorship
     * @return a {@link String} object
     */
    public String getName() {
        return this.name;
    }
  
    /**
     * Sets the name of the User
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }
  
    /**
     * Informs the login (username) of the {@link User}
     * @return
     */
    public String getLogin() {
        return this.login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

   /**
    * Informs the {@link User}'s company name
    * @return
    */
    public String getCompany() {
        return this.company;
    }

    public void setCompany(String company) {
        this.company = company;
    }

   /**
    * Informs the {@link User}'s blog URL
    * @return
    */
    public String getBlog() {
        return this.blog;
    }

    public void setBlog(String blog) {
        this.blog = blog;
    }

   /**
    * Informs whether a {@link User} is available for hire (hireable) or not.
    * @return true if the {@link User} is hireable. Returns false otherwise.
    */
    public boolean isHireable() {
        return this.hireable;
    }

    public void setHireable(boolean hireable) {
        this.hireable = hireable;
    }

   /**
    * Informs the sum of followers the User has
    * @return
    */
    public int getFollowers() {
        return this.followers;
    }

    public void setFollowers(int followers) {
        this.followers = followers;
    }

   /**
    * Informs how many other GitHub Users the User follows
    * @return
    */
    public int getFollowing() {
        return this.following;
    }

    public void setFollowing(int following) {
        this.following = following;
    }

   /**
    * Informs the date when the {@link User} signed up for GitHub
    * @return a {@link String} object
    */
    public String getCreated_at() {
        return this.created_at;
    }

    public void setCreated_at(String created_at) {
        this.created_at = created_at;
    }

   /**
    * Informs the last date when the {@link User} performed activity on GitHub
    * @return a {@link Date} object
    */
    public String getUpdatedAt() {
        return this.updated_at;
    }

    public void setUpdatedAt(String updated_at) {
        this.updated_at = updated_at;
    }
  
   /**
    * Returns the sum of public repositories that the User has
    * @return
    */
    public int getPublic_repos() {
        return this.public_repos;
    }

    public void setPublic_repos(int public_repos) {
        this.public_repos = public_repos;
    }
  
   /**
    * Returns the sum of public gists that the User has
    * @return
    */
    public int getPublic_gists() {
        return this.public_gists;
    }

    public void setPublic_gists(int public_gists) {
        this.public_gists = public_gists;
    }

   /**
    * Informs the email address of the {@link User}
    * @return a String representing an email address
    */
    public String getEmail() {
        return this.email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

   /**
    * The location String of the {@link User}
    * @return
    */
    public String getLocation() {
        return this.location;
    }

   public void setLocation(String location) {
       this.location = location;
   }
   
   public List<Commit> getCommits() {
		return this.commits;
	}

	public void setCommits(List<Commit> commits) {
		this.commits = commits;
	}
  
   /**
    * Informs the list of email addresses that belongs to the user.
    * This is useful for matching critical {@link Commit} authorship data
    * @return
    */
    public List<String> getEmailAddresses() {
        return this.emailAddresses;
    }
  
    public void setEmailAddresses(List<String> emails) {
        this.emailAddresses = emails;
    }
  
    public String getURL() {
        return String.format("https://api.github.com/users/%s", this.getLogin());
    }
    
    /**
     * Two {@link User} objects X and Y are the same if both X and Y have the same login attribute
     * @param user
     * @return
     */
    public boolean equals(User user) {
    	return this.login.equals(user.getLogin());
    }

    @Override
    public String toString() {
        return "id=" + id + ", "
            + (name != null ? "Name = " + name + ", " : "")
            + (login != null ? "Login = " + login + ", " : "")
            + "Public repos = " + public_repos + ", "
            + (created_at != null ? "Created at = " + created_at : "") + ", Url: " + this.getURL();
    }
    
	public usefuldata.Developer DeveloperTransform(){
		usefuldata.Developer developer = new usefuldata.Developer();
		developer.setId(this.getId());
		developer.setLogin(this.getLogin());
		developer.setUrl("https://github.com/" + this.getLogin());
		developer.setEmail(this.getEmail());
		
		return developer;
	}
    
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\factory\DaoFactory.java
package factory;

import dao.DeveloperDao;
import dao.DeveloperEchartsDao;
import dao.EvolveEchartsDao;
import dao.ForceChartDao;
import dao.ProjectContributionDao;
import dao.ProjectDao;
import dao.ReleaseContributionDao;
import dao.ReleaseDao;
import dao.ReleaseEchartsDao;
import dao.VitalityDao;
import dao.impl.DeveloperDaoImpl;
import dao.impl.DeveloperEchartsDaoImpl;
import dao.impl.EvolveEchartsDaoImpl;
import dao.impl.ForceChartDaoImpl;
import dao.impl.ProjectContributionDaoImpl;
import dao.impl.ProjectDaoImpl;
import dao.impl.ReleaseContributionDaoImpl;
import dao.impl.ReleaseDaoImpl;
import dao.impl.ReleaseEchartsDaoImpl;
import dao.impl.VitalityDaoImpl;

/**
 * used to get DaoImpl instances
 * @author guanjun
 *
 */
public class DaoFactory {
	
	public static DeveloperDao getDeveloperDao(){
		return DeveloperDaoImpl.getInstance();
	}
	
	public static VitalityDao getVitalityDao(){
		return VitalityDaoImpl.getInstance();
	}
	
	public static ReleaseDao getReleaseDao(){
		return ReleaseDaoImpl.getInstance();
	}
	
	public static ProjectDao getProjectDao(){
		return ProjectDaoImpl.getInstance();
	}
	
	public static ProjectContributionDao getProjectContribution(){
		return ProjectContributionDaoImpl.getInstance();
	}
	
	
	public static ReleaseContributionDao getReleaseContribution(){
		return ReleaseContributionDaoImpl.getInstance();
	}
	
	public static ReleaseEchartsDao getReleaseEchartsDao(){
		return ReleaseEchartsDaoImpl.getInstance();
	}
	
	
	public static ForceChartDao getForceChartDao(){
		return ForceChartDaoImpl.getInstance();
	}
	
	public static DeveloperEchartsDao getDeveloperEchartsDao(){
		return DeveloperEchartsDaoImpl.getInstance();
	}
	
	public static EvolveEchartsDao getEvolveEchartsDao(){
		return EvolveEchartsDaoImpl.getInstance();
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\factory\DataFactory.java
package factory;

import java.util.ArrayList;

public interface DataFactory {
	
	public String getRelationsDestination(ArrayList<String> developers,
			String projectName, String releaseName);

	public ArrayList<String> getPakageDependency(ArrayList<String> files,
			ArrayList<String> languages);

	public int getCodeLines(String file,ArrayList<String> languages);
	
	public String getDevelopDigramByVersion( ArrayList<String> filenames);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\factory\DataFactoryImpl.java
package factory;



import java.util.ArrayList;

import analysis.CodeLinesCount;
import analysis.CodeLinesCountImpl;
import analysis.DevelopDigram;
import analysis.DevelopDigramImpl;
import analysis.PackageDependency;
import analysis.PackageDependencyImpl;

public class DataFactoryImpl implements DataFactory{
	@Override
	public ArrayList<String> getPakageDependency(ArrayList<String> files,
			ArrayList<String> languages) {
		PackageDependency pd=new PackageDependencyImpl();
		return pd.getPakageDependency(files,languages);
	}

	@Override
	public int getCodeLines(String file,ArrayList<String> languages) {
		CodeLinesCount cl=new CodeLinesCountImpl();
		return cl.getCodeLines(file);
	}

	@Override
	public String getDevelopDigramByVersion(ArrayList<String> filenames) {
		DevelopDigram dd=new DevelopDigramImpl();
		return dd.getDevelopDigramByVersion(filenames);
	}

	@Override
	public String getRelationsDestination(ArrayList<String> developers,
			String projectName, String releaseName) {
		// TODO Auto-generated method stub
		
		
		return null;
	}

//	@Override
//	public String getRelationsDestination(ArrayList<String> developers,String projectName, String releaseName) {
//		// TODO Auto-generated method stub
//		Relation relations=new RelationImpl();
//		return relations.getRelations(developers, projectName, releaseName);
//	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\factory\MetaDaoFactory.java
package factory;

import metadao.CommentDao;
import metadao.CommitDao;
import metadao.CommitFileDao;
import metadao.ContributorDao;
import metadao.CrawlindexDao;
import metadao.GitURLDao;
import metadao.IssueDao;
import metadao.ProjectDao;
import metadao.PublishedReleaseDao;
import metadao.UnPublishedReleaseDao;
import metadao.UserDao;
import metadao.impl.CommentDaoImpl;
import metadao.impl.CommitDaoImpl;
import metadao.impl.CommitFileDaoImpl;
import metadao.impl.ContributorDaoImpl;
import metadao.impl.CrawlindexDaoImpl;
import metadao.impl.GitURLDaoImpl;
import metadao.impl.IssueDaoImpl;
import metadao.impl.PublishedReleaseDaoImpl;
import metadao.impl.UnPublishedReleaseDaoImpl;
import metadao.impl.UserDaoImpl;



public class MetaDaoFactory {
	
	public static ContributorDao getContributorDao(){
		return ContributorDaoImpl.getInstance();
	}
	
	public static CommitDao getCommitDao(){
		return CommitDaoImpl.getInstance();
	}
	
	public static ProjectDao getProjectDao(){
		return metadao.impl.ProjectDaoImpl.getInstance();
	}
	
	public static UnPublishedReleaseDao getUnPublishedReleaseDao(){
		return UnPublishedReleaseDaoImpl.getInstance();
	}
	
	public static CommitFileDao getCommitFileDao(){
		return CommitFileDaoImpl.getInstance();
	}
	
	public static UserDao getUserDao(){
		return UserDaoImpl.getInstance();
	}
	
	public static IssueDao getIssueDao(){
		return IssueDaoImpl.getInstance();
	}
	
	public static CommentDao getCommentDao(){
		return CommentDaoImpl.getInstance();
	}
	
	public static PublishedReleaseDao getPublishedReleaseDao(){
		return PublishedReleaseDaoImpl.getInstance();
	}
	
	public static CrawlindexDao getCrawlindexDao(){
		return CrawlindexDaoImpl.getInstance();
	}
	
	public static GitURLDao getGitURLDao(){
		return GitURLDaoImpl.getInstance();
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\helper\DBHelper.java
package helper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

import util.XMLHelper;

public abstract class DBHelper {
	
	private static DBHelper baseDao;
	private Connection connection = null;
	
	private String driver;
	private String url;
	private String user;
	private String password;
	
	public DBHelper(){
        XMLHelper xmlhelper = new XMLHelper();
        ArrayList<String> params = xmlhelper.DBInputXML("DBConfigure.xml");       
        driver = params.get(0);
        url = params.get(1);
        user = params.get(2);
        password = params.get(3);        
        try{
        	Class.forName(driver);
        	
        }catch(Exception e){
        	e.printStackTrace();
        }		
	}
	
	public static DBHelper getBaseDaoInstance(){
		return baseDao;
	}
	
	
	public Connection getConnection() {
		try{
			connection = DriverManager.getConnection(url, user, password);
		}catch(SQLException e){
			e.printStackTrace();
		}
		return connection;
	}
	
	public void closeConnection(Connection connection) {
		
		if(connection!=null){
		try{
			connection.close();
		}catch(SQLException e){
			e.printStackTrace();
		}
		
		}	
	}
	
	public void closePreparedStatement(PreparedStatement stmt) {
		
		if(stmt!=null){
			try{
				stmt.close();
			}catch(SQLException e){
				e.printStackTrace();
				
			}
			
		}	
	}
	
	public void closeResult(ResultSet result) {
		
		if(result!=null){
			try{
				result.close();
				
			}catch(SQLException e){
				e.printStackTrace();
			}
			
		}
		
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\helper\QuickSort.java
package helper;

public class QuickSort {
//	public static int getMiddle(String[] list, int low, int high) {  
//        String tmp = list[low];    //数组的第一个作为中轴  (pivlot)
//        while (low < high) {  
//            while (low < high && compareDate(list[high],tmp) > 0) {  
//                high--;  
//            }  
//            list[low] = list[high];   //比中轴小的记录移到低端  
//            while (low < high && compareDate(list[low],tmp) < 0) {  
//                low++;  
//            }  
//            list[high] = list[low];   //比中轴大的记录移到高端  
//        }  
//        list[low] = tmp;              //中轴记录到尾  
//        return low;                   //返回中轴的位置  
//    }  
//	
//	public static void _quickSort(String[] list, int low, int high) {  
//        if (low < high) {  
//            int middle = getMiddle(list, low, high);  //将list数组进行一分为二  
//            _quickSort(list, low, middle - 1);        //对低字表进行递归排序  
//            _quickSort(list, middle + 1, high);       //对高字表进行递归排序  
//        }  
//    }  
//	
//	public static void quick(String[] str) {  
//        if (str.length > 0) {    //查看数组是否为空  
//            _quickSort(str, 0, str.length - 1);  
//        }  
//    } 
	
	/**
	 * date1 < date2 return -1
	 * @param date1
	 * @param date2
	 * @return
	 */
	private static int compareDate(String date1,String date2){
		if(date1.equals(date2))
    		return 0;
    	else{
    		int year1 = Integer.parseInt(date1.substring(0, 4));
    		int year2 = Integer.parseInt(date2.substring(0, 4));
    		int month1 = Integer.parseInt(date1.substring(5, 7));
    		int month2 = Integer.parseInt(date2.substring(5, 7));
    		int day1 = Integer.parseInt(date1.substring(8, 10));
    		int day2 = Integer.parseInt(date2.substring(8, 10));
    		
    		if(year1 < year2)
    			return -1;
    		else if(year1 > year2)
    			return 1;
    		else{
    			//year is the same
    			if(month1 < month2)
    				return -1;
    			else if(month1 > month2)
    				return 1;
    			else{
    				//year and month is the same
    				if(day1 < day2)
    					return -1;
    				else if(day1 > day2)
    					return 1;
    				else
    					return 0;
    			}
    		}
    	}	
	}
	
	
	public static String [ ] qsort(String items[])
	{
	qs(items, 0, items.length - 1);
	return items;
	}

	private static void qs(String items[], int left, int right)
	{
	int i, j;
	String pivot, temp;
	i = left;
	j = right;
	pivot = items [(left + right) / 2];
	
	do
		{
		
		while ((compareDate(items [i] ,pivot) == -1) && (i < right))
			{
			i++;
			}
		
		while ((compareDate(pivot ,items [j]) == -1) && (j > left))
			{
			j--;
			}
			
		if (i <= j)
			{
			temp = items [i];
			items [i] = items [j];
			items [j] = temp;
			i++;
			j--;
			}
		}
	while (i <= j);
	
	if (left < j)
		{
		qs (items, left, j);
		}
	
	if (i < right)
		{
		qs (items, i, right);
		}
	}
	
	
	
//	public static void main(String[] args) {  
//        // TODO Auto-generated method stub  
//         String[] list={"2014-02-21",
//        		"2014-02-21",
//        		 "2013-07-10",
//        		 "2011-09-12",
//        		 "2011-08-24",
//        		 "2009-09-16",
//        		 "2009-08-14",
//        		 "2009-08-13",
//        		 "2009-03-11",
//        		"2009-03-10",
//        		 "2008-05-08"};  
//         QuickSort qs=new QuickSort();  
//         qs.qsort(list);  
//         for(int i=0;i<list.length;i++){  
//             System.out.print(list[i]+" ");  
//         }  
//         System.out.println();  
//    }  
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\http\HttpException.java
package http;

import entity.GroundhogException;


public class HttpException extends GroundhogException {
	private static final long serialVersionUID = 5824357504573919990L;

	public HttpException(String msg) {
		super(msg);
	}

	public HttpException(Throwable cause) {
		super(cause);
	}

	public HttpException(String msg, Throwable cause) {
		super(msg, cause);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\http\HttpModule.java
package http;


import com.google.inject.AbstractModule;
import com.google.inject.Singleton;
import com.google.inject.name.Names;

/**
 * 
 * 
 */
public class HttpModule extends AbstractModule {

	@Override
	protected void configure() {
		bind(Requests.class).in(Singleton.class);
		bind(String.class)
				.annotatedWith(Names.named("githubOauthToken"))
				.toInstance("access_token=b0244ac0d27f7e0c227cedbd557d875869a59111");
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\http\Requests.java
package http;

import java.io.IOException;
import java.io.InputStream;

import com.ning.http.client.AsyncCompletionHandler;
import com.ning.http.client.AsyncHttpClient;
import com.ning.http.client.ListenableFuture;
import com.ning.http.client.Request;
import com.ning.http.client.RequestBuilder;


/**
 * Utility class to perform asynchronous http requests
 * 
 * 
 * 
 */
public class Requests {
	private final AsyncHttpClient httpClient;
	
	public Requests() {
		this.httpClient = new AsyncHttpClient();
		
	}
	
	/**
	 * Gets the response body of the given URL
	 * @param urlStr
	 * @return the entire html content
	 */
	public String get(String urlStr) {
		try {
			return this.httpClient.prepareGet(urlStr).execute().get().getResponseBody();
		} catch (Exception e) {
			e.printStackTrace();
			throw new HttpException(e);
		}
	}
	
	/**
	 * Gets the response body of the given URL using the preview flag in the request header
	 * This is for new API's that are still in preview mode
	 * @param urlStr
	 * @return the entire html content
	 */
	public String getWithPreviewHeader(String urlStr) {
		try {
			RequestBuilder builder = new RequestBuilder("GET");
		    Request request = builder.setUrl(urlStr)
		     .addHeader("Accept", "application/vnd.github.manifold-preview")
		     .build();
		    
			return this.httpClient.prepareRequest(request).execute().get().getResponseBody();
		} catch (Exception e) {
			e.printStackTrace();
			throw new HttpException(e);
		}
	}
	
	/**
	 * Downloads the response body of the given URL
	 * 
	 * @param urlStr an URL of a page whose body will be downloaded
	 * @return the entire html content as an InputStream
	 */
	public InputStream download(String urlStr) {
		try {
			return this.httpClient.prepareGet(urlStr).setFollowRedirects(true).execute().get().getResponseBodyAsStream();
		} catch (Exception e) {
			e.printStackTrace();
			throw new HttpException(e);
		}
	}
	
	public <T> ListenableFuture<T> getAsync(String urlStr, AsyncCompletionHandler<T> callback) throws IOException {
		return httpClient.prepareGet(urlStr).execute(callback);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\http\URLsDecoder.java
package http;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;


/**
 * 
 * 
 * 
 */
public class URLsDecoder {

	/**
	 * 
	 * @param s a String representing an URL
	 * @return encoded URL
	 */
	public static String encodeURL(String s) {
		try {
			return URLEncoder.encode(s, "UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			throw new HttpException(e);
		}
	}
	
	/**
	 * 
	 * @param s a String representing an URL
	 * @return an UTF-8 decoded URL
	 */
	public static String decodeURL(String s) {
		try {
			return URLDecoder.decode(s, "UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			throw new HttpException(e);
		}
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\CommentDao.java
package metadao;

import java.util.ArrayList;
import java.util.List;

public interface CommentDao {
	public boolean addComment(entity.Comment comment,int project_id);
	
	public boolean addComments(List<entity.Comment> comments,int project_id);
	
	public boolean CheckaddComments(List<entity.Comment> comments,int project_id);
		
	public ArrayList<usefuldata.Comment> getUsefulComments(String projectName,int project_id);
	
	public entity.Comment getComment(int id,int project_id);
	
	public boolean updateComment(entity.Comment comment,int project_id);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\CommitDao.java
package metadao;

import java.util.List;

import entity.Commit;

public interface CommitDao {
	/**
	 *  after crawling call this method
	 *  inside the method use Dates to format the date
	 * @param commit
	 * @param project_id
	 * @return
	 */
	public boolean addCommit(Commit commit,int project_id);
	
	public int CheckaddCommit(Commit commit,int project_id,int contributor_id);
	
	
	public List<Commit> getCommits(int projectId);
	
	public List<Commit> getCommits(int projectId,int contributor_id);
	
	public Commit getCommit(String sha,int projectId,int contributor_id);
	
	
	public boolean updateCommit(Commit commit,int project_id);
	
	public int Contributions(int projectId,int contributor_id);
	
	public int releaseCommits(int project_id,String start_time,String end_time);
	
	public int releaseCommits(int project_id,String start_time);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\CommitFileDao.java
package metadao;

import java.util.List;

import entity.CommitFile;

public interface CommitFileDao {
	public boolean addCommitFile(CommitFile cmf);
	
	public boolean addCommitFiles(List<CommitFile> cmfs);
	
	public CommitFile getCommitFile(String commit_sha);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\ContributorDao.java
package metadao;

import java.util.List;

import entity.Contributor;

public interface ContributorDao {
	
	public boolean CheckaddContributor(Contributor contributor,int project_id);
	
	public boolean addContributor(Contributor contributor,int project_id);
	
	public boolean addContributors(List<Contributor> contributor,int project_id);
	
	public boolean CheckaddContributors(List<Contributor> contributor,int project_id);
	
	public List<entity.Contributor> getAllContributors(int project_id);
	
	public Contributor getContributor(String login);
	
	public boolean updateContributor(Contributor contributor,int project_id);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\CrawlindexDao.java
package metadao;

import entity.Crawlindex;

public interface CrawlindexDao {
	public Crawlindex getCrawlindex(int project_id);

	public boolean addCrawlindex(Crawlindex crawlindex);
	
	public boolean updateContributor(Crawlindex crawlindex);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\GitURLDao.java
package metadao;

import java.util.ArrayList;
/**
 * giturl dao has 3 states
 * uncrawled,unupdated 
 * @author guanjun
 *
 */
public interface GitURLDao {
	public void addURL(String url,String state);
	
	public void deleteCrawledURL(String state);
	
	public boolean findURL(String URL);
	
	public ArrayList<String> getURLNotCrawled(String state);
	
	public void changeState(String url,String state);
	
	public String getState(String url);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\CommentDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import entity.Comment;
import metadao.CommentDao;

public class CommentDaoImpl implements CommentDao{

	private static CommentDaoImpl commentDao=new CommentDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static CommentDaoImpl getInstance(){
		return commentDao;
	}
	
	
	@Override
	public boolean addComment(Comment comment, int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`comments` (`id`,`url`,`user`,`user_id`,`position`,`line`,`path`,`commit_id`,`created_at`,`updated_at`,`body`,`project_id`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1,comment.getId());
			ps.setString(2, comment.getUrl());
			ps.setString(3, comment.getUser());
			ps.setInt(4,comment.getUser_id());
			ps.setInt(5,comment.getPosition());
			ps.setInt(6,comment.getLine());
			ps.setString(7, comment.getPath());
			ps.setString(8, comment.getCommit_id());
			ps.setString(9, comment.getCreated_at());
			ps.setString(10, comment.getUpdated_at());
			ps.setString(11, comment.getBody());
			ps.setInt(12,project_id);
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public ArrayList<usefuldata.Comment> getUsefulComments(String projectName,int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.comments where project_id =?");
			ps.setInt(1, project_id);
			
			rs=ps.executeQuery();
			
			ArrayList<usefuldata.Comment> result = new ArrayList<usefuldata.Comment>();
			while(rs.next()){
				usefuldata.Comment comment = new usefuldata.Comment();
				comment.setCommentId(rs.getInt("id"));
				comment.setCommentator(rs.getString("user"));
				comment.setContent(rs.getString("body"));
				comment.setCommitId(rs.getString("commit_id"));
				comment.setDate(rs.getString("created_at"));
				comment.setProjectName(projectName);
				
				result.add(comment);
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean addComments(List<Comment> comments, int project_id) {
		for(Comment c:comments){
			addComment(c,project_id);
		}
		return true;
	}

	@Override
	public boolean CheckaddComments(List<Comment> comments, int project_id) {
		for(Comment c:comments){
			Comment as = getComment(c.getId(),project_id);
			if(as == null)
				addComment(c,project_id);
			else
				updateComment(c,project_id);
		}
		return true;
	}

	@Override
	public Comment getComment(int id, int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.comments where id = ? and project_id =?");
			ps.setInt(1, id);
			ps.setInt(2, project_id);
			
			rs=ps.executeQuery();
			
			Comment result = null;
			if(rs.next()){
				result = new Comment();
				result.setId(rs.getInt("id"));
				result.setUrl(rs.getString("url"));
				result.setUser(rs.getString("user"));
				result.setUser_id(rs.getInt("user_id"));
				result.setPosition(rs.getInt("position"));
				result.setLine(rs.getInt("line"));
				result.setPath(rs.getString("path"));
				result.setCommit_id(rs.getString("commit_id"));
				result.setCreated_at(rs.getString("created_at"));
				result.setUpdated_at(rs.getString("updated_at"));
				result.setBody(rs.getString("body"));
				
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean updateComment(Comment comment, int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`comment` SET `id`=?,`url`=?,`user`=?,`user_id`=?,`position`=?,`line`=?,`path`=?,`commit_id`=?,`created_at`=?,`updated_at`=?,`body`=?,`project_id`=? where `id` =? and `project_id`=? ");
			
			ps.setInt(1, comment.getId());
			ps.setString(2,comment.getURL());
			ps.setString(3, comment.getUser());
			ps.setInt(4, comment.getUser_id());
			ps.setInt(5, comment.getPosition());
			ps.setInt(6, comment.getLine());
			ps.setString(7, comment.getPath());
			
			ps.setString(8,comment.getCommit_id());
			ps.setString(9, comment.getCreated_at());
			ps.setString(10, comment.getUpdated_at());
			
			ps.setString(11, comment.getBody());
			ps.setInt(12, project_id);
			
			ps.setInt(13, comment.getId());
			ps.setInt(14, project_id);
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\CommitDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import util.Dates;
import entity.Commit;
import entity.User;
import factory.MetaDaoFactory;
import metadao.CommitDao;

public class CommitDaoImpl implements CommitDao{

	private static CommitDaoImpl commitDao=new CommitDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static CommitDaoImpl getInstance(){
		return commitDao;
	}
	
	@Override
	public boolean addCommit(Commit commit,int project_id) {
		Commit c = MetaDaoFactory.getCommitDao().getCommit(commit.getSha(), project_id, commit.getCommiter().getId());
		if(c==null){
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `metadata`.`commits` (`sha`,`message`,`commitdate`,`additionscount`,`deletionscount`,`project_id`,`contributor_id`) VALUES (?,?,?,?,?,?,?)");
				
				ps.setString(1,commit.getSha());
				ps.setString(2,commit.getMessage());
				ps.setString(3, Dates.metaDateFormat(commit.getCommitDate().toString()));
				ps.setInt(4, commit.getAdditionsCount());
				ps.setInt(5, commit.getDeletionsCount());
				ps.setInt(6, project_id);
				ps.setInt(7, commit.getCommiter().getId());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;
		}
		
		return true;
	}

	@Override
	public List<Commit> getCommits(int projectId) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		ResultSet rs2=null;
		PreparedStatement ps2=null;
		try{
			ps=con.prepareStatement("select * from metadata.commits where project_id =?");
			ps.setInt(1, projectId);
			
			rs=ps.executeQuery();
			
			List<Commit> result = new ArrayList<Commit>();
			while(rs.next()){
				Commit commit = new Commit();
				commit.setSha(rs.getString("sha"));
				commit.setMessage(rs.getString("message"));
				commit.setCommitDate(rs.getString("commitdate"));;
				commit.setAdditionsCount(rs.getInt("additionscount"));
				commit.setDeletionsCount(rs.getInt("deletionscount"));
				
				User u = new User("");
				int id = rs.getInt("contributor_id");
				ps2=con.prepareStatement("select * from metadata.contributor where id =?");
				ps2.setInt(1, id);
				rs2=ps2.executeQuery();
				String login = "";
				if(rs2.next()){
					login = rs2.getString("login");
				}
				u.setId(id);
				u.setLogin(login);
				
				commit.setCommiter(u);
				
				result.add(commit);
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs2);
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps2);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean updateCommit(Commit commit,int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`commits` SET `sha`=?,`message`=?,`commitdate`=?,`additionscount`=?,`deletionscount`=?,`project_id`=?,`contributor_id`=? where `sha`=? and `project_id`=? and `contributor_id`=?");
			
			ps.setString(1,commit.getSha());
			ps.setString(2,commit.getMessage());
			ps.setString(3, Dates.metaDateFormat(commit.getCommitDate().toString()));
			ps.setInt(4, commit.getAdditionsCount());
			ps.setInt(5, commit.getDeletionsCount());
			ps.setInt(6, project_id);
			ps.setInt(7, commit.getCommiter().getId());
			
			ps.setString(8,commit.getSha());
			ps.setInt(9, project_id);
			ps.setInt(10, commit.getCommiter().getId());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public List<Commit> getCommits(int projectId, int contributor_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.commits where project_id =? and contributor_id =?");
			ps.setInt(1, projectId);
			ps.setInt(2, contributor_id);
			
			rs=ps.executeQuery();
			
			List<Commit> result = new ArrayList<Commit>();
			while(rs.next()){
				Commit commit = new Commit();
				commit.setSha(rs.getString("sha"));
				commit.setMessage(rs.getString("message"));
				commit.setCommitDate(rs.getString("commitdate"));;
				commit.setAdditionsCount(rs.getInt("additionscount"));
				commit.setDeletionsCount(rs.getInt("deletionscount"));
				
				User u = new User("");
				u.setId(rs.getInt("contributor_id"));
				commit.setCommiter(u);
				
				result.add(commit);
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public int Contributions(int projectId, int contributor_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		int contributions = 0;
		try{
			ps=con.prepareStatement("select * from metadata.commits where project_id =? and contributor_id =?");
			ps.setInt(1, projectId);
			ps.setInt(2, contributor_id);
			
			rs=ps.executeQuery();
			while(rs.next()){
				int add = rs.getInt("additionscount");
				int del = rs.getInt("deletionscount");
				
				contributions += add + del;
			}	
			
			return contributions;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
	
		return 0;
	}

	@Override
	public int releaseCommits(int project_id, String start_time, String end_time) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		int commit_nums = 0;
		try{
			ps=con.prepareStatement("select * from metadata.commits where project_id =? and commitdate >=? and commitdate <=?");
			ps.setInt(1, project_id);
			ps.setString(2,start_time);
			ps.setString(3,end_time);
			
			rs=ps.executeQuery();
			while(rs.next()){
				commit_nums +=1;
			}	
			
			return commit_nums;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
	
		return 0;
	}

	@Override
	public int releaseCommits(int project_id, String start_time) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		int commit_nums = 0;
		try{
			ps=con.prepareStatement("select * from metadata.commits where project_id =? and commitdate >=?");
			ps.setInt(1, project_id);
			ps.setString(2,start_time);
			
			rs=ps.executeQuery();
			while(rs.next()){
				commit_nums +=1;
			}	
			
			return commit_nums;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
	
		return 0;
	}

	@Override
	public int CheckaddCommit(Commit commit, int project_id,int contributor_id) {
		Commit c = getCommit(commit.getSha(),project_id,contributor_id);
		if(c == null){
			//not in the database yet
			addCommit(commit,project_id);
			return 1;
		}else
			return 0;
		
	}

	@Override
	public Commit getCommit(String sha, int projectId,int contributor_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		ResultSet rs2=null;
		PreparedStatement ps2=null;
		try{
			ps=con.prepareStatement("select * from metadata.commits where sha = ? and project_id =? and contributor_id=?");
			ps.setString(1, sha);
			ps.setInt(2, projectId);
			ps.setInt(3, contributor_id);
			
			
			rs=ps.executeQuery();
			
			Commit result = null;
			if(rs.next()){
				result = new Commit();
				result.setSha(rs.getString("sha"));
				result.setMessage(rs.getString("message"));
				result.setCommitDate(rs.getString("commitdate"));;
				result.setAdditionsCount(rs.getInt("additionscount"));
				result.setDeletionsCount(rs.getInt("deletionscount"));
				
				User u = new User("");
				int id = rs.getInt("contributor_id");
				ps2=con.prepareStatement("select * from metadata.contributor where id =?");
				ps2.setInt(1, id);
				rs2=ps2.executeQuery();
				String login = "";
				if(rs2.next()){
					login = rs2.getString("login");
				}
				u.setId(id);
				u.setLogin(login);
				
				result.setCommiter(u);
				
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs2);
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps2);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}



}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\CommitFileDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import entity.CommitFile;
import metadao.CommitFileDao;

public class CommitFileDaoImpl implements CommitFileDao{

	private static CommitFileDaoImpl commitFileDaoImpl=new CommitFileDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static CommitFileDaoImpl getInstance(){
		return commitFileDaoImpl;
	}
	
	@Override
	public boolean addCommitFile(CommitFile cmf) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`commit_files` (`file_sha`,`filename`,`status`,`additions`,`deletions`,`changes`,`contents_url`,`commit_sha`,`id`) VALUES (?,?,?,?,?,?,?,?,?)");
			
			ps.setString(1,cmf.getSha());
			ps.setString(2,cmf.getFilename());
			ps.setString(3, cmf.getStatus());
			ps.setInt(4, cmf.getAdditions());
			ps.setInt(5, cmf.getDeletions());
			ps.setInt(6, cmf.getChanges());
			ps.setString(7,cmf.getContents_url());
			ps.setString(8,cmf.getCommit_sha());
			ps.setInt(9, 0);
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public CommitFile getCommitFile(String commit_sha) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.commit_files where commit_sha =?");
			ps.setString(1,commit_sha);
			
			rs=ps.executeQuery();
			
			CommitFile commitFile = null;
			if(rs.next()){
				commitFile = new CommitFile();
				commitFile.setSha(rs.getString("file_sha"));
				commitFile.setFilename(rs.getString("filename"));
				commitFile.setStatus(rs.getString("status"));
				commitFile.setAdditions(rs.getInt("additions"));
				commitFile.setDeletions(rs.getInt("deletions"));
				commitFile.setChanges(rs.getInt("changes"));
				commitFile.setContents_url(rs.getString("contents_url"));
				commitFile.setCommit_sha(rs.getString("commit_sha"));
			}	
			
			return commitFile;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean addCommitFiles(List<CommitFile> cmfs) {
		for(CommitFile cmf:cmfs){
			addCommitFile(cmf);
		}

		return true;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\ContributorDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import entity.Contributor;
import metadao.ContributorDao;

public class ContributorDaoImpl implements ContributorDao{

	private static ContributorDaoImpl contributorDao=new ContributorDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static ContributorDaoImpl getInstance(){
		return contributorDao;
	}
	
	
	@Override
	public boolean addContributor(Contributor contributor,int project_id) {
		Contributor duplicate = getContributor(contributor.getLogin());
		if(duplicate!=null)
			return updateContributor(contributor,project_id);
		
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`contributor` (`id`,`login`,`avatar_url`,`gravatar_id`,`html_url`,`followers_url`,`following_url`,`gists_url`,`starred_url`,`subscriptions_url`,`repos_url`,`events_url`,`received_events_url`,`type`,`site_admin`,`contributions`,`project_id`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1,contributor.getId());
			ps.setString(2,contributor.getLogin());
			ps.setString(3, contributor.getAvatar_url());
			ps.setString(4, contributor.getGravatar_id());
			ps.setString(5,contributor.getHtml_url());
			ps.setString(6,contributor.getFollowers_url());
			ps.setString(7, contributor.getFollowing_url());
			ps.setString(8, contributor.getGists_url());
			ps.setString(9, contributor.getStarred_url());
			ps.setString(10, contributor.getSubscriptions_url());
			ps.setString(11, contributor.getRepos_url());
			ps.setString(12, contributor.getEvents_url());
			ps.setString(13, contributor.getReceived_events_url());
			ps.setString(14, contributor.getType());
			ps.setInt(15,contributor.isSite_admin()?1:0);
			ps.setInt(16,contributor.getContributions());
			ps.setInt(17,project_id);
			
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}


	@Override
	public List<Contributor> getAllContributors(int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.contributor where project_id =?");
			ps.setInt(1,project_id);
			
			rs=ps.executeQuery();
			
			List<Contributor> contributors = new ArrayList<Contributor>();
			
			while(rs.next()){
				Contributor ctb = new Contributor();
				ctb.setId(rs.getInt("id"));
				ctb.setLogin(rs.getString("login"));
				ctb.setAvatar_url(rs.getString("avatar_url"));
				ctb.setGravatar_id(rs.getString("gravatar_id"));
				ctb.setHtml_url(rs.getString("html_url"));
				ctb.setFollowers_url(rs.getString("followers_url"));
				ctb.setFollowing_url(rs.getString("following_url"));
				ctb.setGists_url(rs.getString("gists_url"));
				ctb.setStarred_url(rs.getString("starred_url"));
				ctb.setSubscriptions_url(rs.getString("subscriptions_url"));
				ctb.setRepos_url(rs.getString("repos_url"));
				ctb.setEvents_url(rs.getString("events_url"));
				ctb.setReceived_events_url(rs.getString("received_events_url"));
				ctb.setType(rs.getString("type"));
				int admin = rs.getInt("site_admin");
				boolean site_admin = (admin == 1)?true:false;
				ctb.setSite_admin(site_admin);
				ctb.setContributions(rs.getInt("contributions"));
				contributors.add(ctb);
			}	
			
			return contributors;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public Contributor getContributor(String login) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.contributor where login =?");
			ps.setString(1,login);
			rs=ps.executeQuery();
			Contributor ctb = null;
			if(rs.next()){
				ctb = new Contributor();
				ctb.setId(rs.getInt("id"));
				ctb.setLogin(rs.getString("login"));
				ctb.setAvatar_url(rs.getString("avatar_url"));
				ctb.setGravatar_id(rs.getString("gravatar_id"));
				ctb.setHtml_url(rs.getString("html_url"));
				ctb.setFollowers_url(rs.getString("followers_url"));
				ctb.setFollowing_url(rs.getString("following_url"));
				ctb.setGists_url(rs.getString("gists_url"));
				ctb.setStarred_url(rs.getString("starred_url"));
				ctb.setSubscriptions_url(rs.getString("subscriptions_url"));
				ctb.setRepos_url(rs.getString("repos_url"));
				ctb.setEvents_url(rs.getString("events_url"));
				ctb.setReceived_events_url(rs.getString("received_events_url"));
				ctb.setType(rs.getString("type"));
				int admin = rs.getInt("site_admin");
				boolean site_admin = (admin == 1)?true:false;
				ctb.setSite_admin(site_admin);
				ctb.setContributions(rs.getInt("contributions"));
			}	
			
			return ctb;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addContributors(List<Contributor> contributor, int project_id) {
		for(Contributor ctb:contributor){
			addContributor(ctb,project_id);
		}		
		return true;
	}


	@Override
	public boolean updateContributor(Contributor contributor, int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`contributor` SET `id`=?,`login`=?,`avatar_url`=?,`gravatar_id`=?,`html_url`=?,`followers_url`=?,`following_url`=?,`gists_url`=?,`starred_url`=?,`subscriptions_url`=?,`repos_url`=?,`events_url`=?,`received_events_url`=?,`type`=?,`site_admin`=?,`contributions`=?,`project_id`=? where `id`=? and `project_id`=?");
			
			ps.setInt(1,contributor.getId());
			ps.setString(2,contributor.getLogin());
			ps.setString(3, contributor.getAvatar_url());
			ps.setString(4, contributor.getGravatar_id());
			ps.setString(5,contributor.getHtml_url());
			ps.setString(6,contributor.getFollowers_url());
			ps.setString(7, contributor.getFollowing_url());
			ps.setString(8, contributor.getGists_url());
			ps.setString(9, contributor.getStarred_url());
			ps.setString(10, contributor.getSubscriptions_url());
			ps.setString(11, contributor.getRepos_url());
			ps.setString(12, contributor.getEvents_url());
			ps.setString(13, contributor.getReceived_events_url());
			ps.setString(14, contributor.getType());
			ps.setInt(15,contributor.isSite_admin()?1:0);
			ps.setInt(16,contributor.getContributions());
			ps.setInt(17,project_id);
			
			ps.setInt(18,contributor.getId());
			ps.setInt(19,project_id);
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}


	@Override
	public boolean CheckaddContributor(Contributor contributor, int project_id) {
		Contributor c = getContributor(contributor.getLogin());
		if(c == null){
			return addContributor(contributor,project_id);
		}
		else
			return updateContributor(contributor,project_id);
		
	}


	@Override
	public boolean CheckaddContributors(List<Contributor> contributor,
			int project_id) {
		
		for(Contributor ctb:contributor){
			CheckaddContributor(ctb,project_id);
		}		
		return true;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\CrawlindexDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import entity.Crawlindex;
import metadao.CrawlindexDao;

public class CrawlindexDaoImpl implements CrawlindexDao{

	private static CrawlindexDaoImpl CrawlindexDao=new CrawlindexDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static CrawlindexDaoImpl getInstance(){
		return CrawlindexDao;
	}
	
	@Override
	public Crawlindex getCrawlindex(int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.crawl_index where project_id =?");
			ps.setInt(1, project_id);
			
			rs=ps.executeQuery();
			
			Crawlindex result = null;
			
			if(rs.next()){
				result = new Crawlindex();
				result.setProject_id(rs.getInt("project_id"));
				result.setCommit_page(rs.getInt("commit_page"));
				result.setComment_page(rs.getInt("comment_page"));
				result.setIssue_page(rs.getInt("issue_page"));
				result.setRelease_page(rs.getInt("release_page"));
				result.setUpbrelease_page(rs.getInt("upbrelease_page"));
				result.setContributor_page(rs.getInt("contributor_page"));
				result.setMilestone_page(rs.getInt("milestone_page"));
				result.setPullrequest_page(rs.getInt("pullrequest_page"));
				result.setUser_page(rs.getInt("user_page"));
				result.setRelease_idx(rs.getInt("release_idx"));
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean addCrawlindex(Crawlindex crawlindex) {
		Crawlindex duplicate = getCrawlindex(crawlindex.getProject_id());
		if(duplicate!=null)
			return updateContributor(duplicate);
				
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`crawl_index` (`project_id`,`commit_page`,`comment_page`,`issue_page`,`release_page`,`upbrelease_page`,`contributor_page`,`milestone_page`,`pullrequest_page`,`user_page`,`release_idx`) VALUES (?,?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1, crawlindex.getProject_id());
			ps.setInt(2, crawlindex.getCommit_page());
			ps.setInt(3, crawlindex.getComment_page());
			ps.setInt(4, crawlindex.getIssue_page());
			ps.setInt(5, crawlindex.getRelease_page());
			ps.setInt(6, crawlindex.getUpbrelease_page());
			ps.setInt(7, crawlindex.getContributor_page());
			ps.setInt(8, crawlindex.getMilestone_page());
			ps.setInt(9, crawlindex.getPullrequest_page());
			ps.setInt(10, crawlindex.getUser_page());
			ps.setInt(11, crawlindex.getRelease_idx());
									
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean updateContributor(Crawlindex crawlindex) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`crawl_index` SET `project_id`=?,`commit_page`=?,`comment_page`=?,`issue_page`=?,`release_page`=?,`upbrelease_page`=?,`contributor_page`=?,`milestone_page`=?,`pullrequest_page`=?,`user_page`=?,`release_idx`=? where `project_id`=?");
			
			ps.setInt(1, crawlindex.getProject_id());
			ps.setInt(2, crawlindex.getCommit_page());
			ps.setInt(3, crawlindex.getComment_page());
			ps.setInt(4, crawlindex.getIssue_page());
			ps.setInt(5, crawlindex.getRelease_page());
			ps.setInt(6, crawlindex.getUpbrelease_page());
			ps.setInt(7, crawlindex.getContributor_page());
			ps.setInt(8, crawlindex.getMilestone_page());
			ps.setInt(9, crawlindex.getPullrequest_page());
			ps.setInt(10, crawlindex.getUser_page());
			ps.setInt(11, crawlindex.getRelease_idx());
			
			ps.setInt(12, crawlindex.getProject_id());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\GitURLDaoImpl.java
package metadao.impl;

import dao.impl.DaoHelperImpl;
import metadao.GitURLDao;
import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;


public class GitURLDaoImpl implements GitURLDao {
	private static GitURLDaoImpl gitURLDao = new GitURLDaoImpl();
	private static DBHelper daoHelper=DaoHelperImpl.getBaseDaoInstance();
	
	public static GitURLDaoImpl getInstance(){
		return gitURLDao;
	}

	@Override
	public void addURL(String url, String state) {
		// TODO Auto-generated method stub
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`giturl` (`url`,`state`) VALUES (?,?)");
			ps.setString(1,url);
			ps.setString(2,state);
			ps.execute();			
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
	}

	@Override
	public void deleteCrawledURL(String state) {
		// TODO Auto-generated method stub
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("delete from metadata.giturl where state=?");
			ps.setString(1,state);
			ps.execute();			
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
	}

	@Override
	public boolean findURL(String URL) {
		// TODO Auto-generated method stub
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.giturl where url =?");
			ps.setString(1, URL);
			rs=ps.executeQuery();
						
			if(rs.next()){
				return true;
			}	
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public ArrayList<String> getURLNotCrawled(String state) {
		// TODO Auto-generated method stub
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.giturl where state =?");
			ps.setString(1, state);
			rs=ps.executeQuery();
			ArrayList<String> urls = new ArrayList<String>();
						
			while(rs.next()){
				urls.add(rs.getString("url"));
			}	
			
			return urls;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public void changeState(String url,String state) {
		// TODO Auto-generated method stub
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("update metadata.giturl set state=? where url=?");
			ps.setString(1, state);
			ps.setString(2, url);
			ps.executeUpdate();
						
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
	}

	@Override
	public String getState(String url) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.giturl where url =?");
			ps.setString(1, url);
			rs=ps.executeQuery();
			
			String state = null;
			if(rs.next()){
				state = rs.getString("state");
			}	
			
			return state;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

}

C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\IssueDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import entity.Issue;
import util.Dates;
import metadao.IssueDao;

public class IssueDaoImpl implements IssueDao{

	private static IssueDaoImpl issueDaoImpl=new IssueDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static IssueDaoImpl getInstance(){
		return issueDaoImpl;
	}
	
	
	@Override
	public ArrayList<usefuldata.Issue> getAllIssues(int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.issue where project_id =?");
			ps.setInt(1, project_id);
			
			rs=ps.executeQuery();
			
			ArrayList<usefuldata.Issue> result = new ArrayList<usefuldata.Issue>();
			while(rs.next()){
				usefuldata.Issue issue = new usefuldata.Issue();
				issue.setIssueId(rs.getInt("id"));
				issue.setInjectedDate(rs.getString("createdat"));
				issue.setState(rs.getString("state"));
				ArrayList<String> dates = new ArrayList<String>();
				dates.add(rs.getString("updatedat"));
				issue.setUpdateDate(dates);
				result.add(issue);
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean addIssue(entity.Issue issue,int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`issue` (`id`,`number`,`comments`,`title`,`body`,`state`,`createdat`,`updatedat`,`closedat`,`project_id`) VALUES (?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1,issue.getId());
			ps.setInt(2,issue.getNumber());
			ps.setInt(3,issue.getCommentsCount());
			ps.setString(4,issue.getTitle());
			ps.setString(5,issue.getBody());
			ps.setString(6,issue.getState());
			ps.setString(7,Dates.dateToString(issue.getCreatedAt()) );
			ps.setString(8,Dates.dateToString(issue.getUpdatedAt()) );
			if(issue.getClosedAt()!=null){
				ps.setString(9,Dates.dateToString(issue.getClosedAt()) );
			}
			else{
				ps.setString(9,"");
			}
			ps.setInt(10, project_id);
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}


	@Override
	public boolean updateIssue(Issue issue,int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`issue` SET `id`=?,`number`=?,`comments`=?,`title`=?,`body`=?,`state`=?,`createdat`=?,`updatedat`=?,`closedat`=?,`project_id`=? where `id`=?");
			
			ps.setInt(1,issue.getId());
			ps.setInt(2,issue.getNumber());
			ps.setInt(3,issue.getCommentsCount());
			ps.setString(4,issue.getTitle());
			ps.setString(5,issue.getBody());
			ps.setString(6,issue.getState());
			ps.setString(7,Dates.dateToString(issue.getCreatedAt()) );
			ps.setString(8,Dates.dateToString(issue.getUpdatedAt()) );
			if(issue.getClosedAt()!=null){
				ps.setString(9,Dates.dateToString(issue.getClosedAt()) );
			}
			else{
				ps.setString(9,"");
			}
			ps.setInt(10, project_id);
			ps.setInt(11,issue.getId());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}


	@Override
	public List<Issue> getAllMetaIssues(int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.issue  where project_id =?");
			ps.setInt(1, project_id);
			
			rs=ps.executeQuery();
			
			ArrayList<entity.Issue> result = new ArrayList<entity.Issue>();
			
			while(rs.next()){
				entity.Issue issue = new entity.Issue();
				issue.setId(rs.getInt("id"));
				issue.setNumber(rs.getInt("number"));
				issue.setCommentsCount(rs.getInt("comments"));
				issue.setTitle(rs.getString("title"));
				issue.setBody(rs.getString("body"));
				issue.setState(rs.getString("state"));
				issue.setCreatedAt(Dates.stringToDate(rs.getString("createdat")));
				issue.setUpdatedAt(Dates.stringToDate(rs.getString("updatedat")));
				issue.setClosedAt(Dates.stringToDate(rs.getString("closedat")));
				result.add(issue);
			}	
			
			return result;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addIssues(List<Issue> issues, int project_id) {
		for(Issue i:issues){
			addIssue(i,project_id);
		}
		
		return true;
	}


	@Override
	public int IssueNum(int project_id, String start_time, String end_time) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		int num = 0;
		
		try{
			ps=con.prepareStatement("select * from metadata.issue  where project_id =? and createdat >=? and createdat <=?");
			ps.setInt(1, project_id);
			ps.setString(2, start_time);
			ps.setString(3, end_time);
			
			
			rs=ps.executeQuery();
			
			while(rs.next()){
				num += 1;
			}	
			
			return num;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return 0;
	}


	@Override
	public int IssueNum(int project_id, String start_time) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		int num = 0;
		
		try{
			ps=con.prepareStatement("select * from metadata.issue  where project_id =? and createdat >=?");
			ps.setInt(1, project_id);
			ps.setString(2, start_time);
			
			rs=ps.executeQuery();
			
			while(rs.next()){
				num += 1;
			}	
			
			return num;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return 0;
	}


	@Override
	public boolean CheckaddIssue(Issue issue, int project_id) {
		Issue is = getIssue(issue.getId(),project_id);
		if(is == null){
			return addIssue(issue,project_id);
		}else
			return updateIssue(issue,project_id);
		
	}


	@Override
	public boolean CheckaddIssues(List<Issue> issues, int project_id) {
		for(Issue i:issues){
			CheckaddIssue(i,project_id);
		}
		
		return true;
	}


	@Override
	public Issue getIssue(int issue_id, int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.issue where id =? and project_id = ?");
			ps.setInt(1,issue_id);
			ps.setInt(2, project_id);
			
			rs=ps.executeQuery();
			Issue issue = null;
			
			if(rs.next()){
				issue = new Issue();
				issue.setId(rs.getInt("id"));
				issue.setNumber(rs.getInt("number"));
				issue.setCommentsCount(rs.getInt("comments"));
				issue.setTitle(rs.getString("title"));
				issue.setBody(rs.getString("body"));
				issue.setState(rs.getString("state"));
				issue.setCreatedAt(Dates.stringToDate(rs.getString("createdat")));
				issue.setUpdatedAt(Dates.stringToDate(rs.getString("updatedat")));
				issue.setClosedAt(Dates.stringToDate(rs.getString("closedat")));
				
			}	
			
			return issue;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\MetaDaoHelperImpl.java
package metadao.impl;

import helper.DBHelper;

public class MetaDaoHelperImpl extends DBHelper{
	
	private static DBHelper baseDao = new MetaDaoHelperImpl();
	
	private MetaDaoHelperImpl(){
      super();
	}
	
	public static DBHelper getBaseDaoInstance(){
		return baseDao;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\ProjectDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import util.Dates;
import entity.Project;
import entity.User;
import metadao.ProjectDao;

public class ProjectDaoImpl implements ProjectDao{

	private static ProjectDaoImpl projectDao=new ProjectDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static ProjectDaoImpl getInstance(){
		return projectDao;
	}
	
	
	@Override
	public boolean addProject(Project project) {
		Project duplicate = getProject(project.getOwner().getLogin(),project.getName());
		
		if(duplicate!=null)
			return updateProject(project);
			
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`project` (`id`,`name`,`description`,`language`,`checkouturl`,`sourcecodeurl`,`createdat`,`lastpushedat`,`isfork`,`hasdownloads`,`hasissues`,`haswiki`,`watcherscount`,`forkscount`,`issuescount`,`owner`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1, project.getId());
			ps.setString(2,project.getName());
			ps.setString(3, project.getDescription());
			ps.setString(4, project.getLanguage());
			ps.setString(5, project.getCheckoutURL());
			ps.setString(6, project.getSourceCodeURL());
			ps.setString(7, Dates.metaDateFormat(project.getCreatedAt().toString()));
			ps.setString(8, Dates.metaDateFormat(project.getLastPushedAt().toString()));
			
			
			ps.setInt(9, project.isFork()?1:0);
			ps.setInt(10, project.hasDownloads()?1:0);
			ps.setInt(11, project.hasIssues()?1:0);
			ps.setInt(12, project.hasWiki()?1:0);
			
			ps.setInt(13, project.getWatchersCount());
			ps.setInt(14, project.getForksCount());
			ps.setInt(15, project.getIssuesCount());
			
			ps.setString(16, project.getOwner().getLogin());
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}


	@Override
	public Project getProject(String owner, String projectName) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.project where name =? and owner=?");
			ps.setString(1, projectName);
			ps.setString(2, owner);
			
			
			rs=ps.executeQuery();
			
			Project project = null;
			if(rs.next()){
				project = new Project();
				project.setId(rs.getInt("id"));
				project.setName(rs.getString("name"));
				project.setDescription(rs.getString("description"));
				project.setLanguage(rs.getString("language"));
				project.setCheckoutURL(rs.getString("checkouturl"));
				project.setSourceCodeURL(rs.getString("sourcecodeurl"));
				project.setCreatedAt(rs.getString("createdat"));
				project.setLastPushedAt(rs.getString("lastpushedat"));
				project.setIsFork((rs.getInt("isfork") == 0)?false:true);
				project.setHasDownloads((rs.getInt("hasdownloads") == 0)?false:true);
				project.setHasIssues((rs.getInt("hasissues") == 0)?false:true);
				project.setHasWiki((rs.getInt("haswiki") == 0)?false:true);
				project.setWatchersCount(rs.getInt("watcherscount"));
				project.setForksCount(rs.getInt("forkscount"));
				project.setIssuesCount(rs.getInt("issuescount"));
				project.setUser(new User(rs.getString("owner")));
			}	
			
			return project;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}



	@Override
	public boolean updateProject(Project project) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`project` SET `id`=?,`name`=?,`description`=?,`language`=?,`checkouturl`=?,`sourcecodeurl`=?,`createdat`=?,`lastpushedat`=?,`isfork`=?,`hasdownloads`=?,`hasissues`=?,`haswiki`=?,`watcherscount`=?,`forkscount`=?,`issuescount`=?,`owner`=? where `id`=?");
			
			ps.setInt(1, project.getId());
			ps.setString(2,project.getName());
			ps.setString(3, project.getDescription());
			ps.setString(4, project.getLanguage());
			ps.setString(5, project.getCheckoutURL());
			ps.setString(6, project.getSourceCodeURL());
			ps.setString(7, Dates.metaDateFormat(project.getCreatedAt().toString()));
			ps.setString(8, Dates.metaDateFormat(project.getLastPushedAt().toString()));
			
			
			ps.setInt(9, project.isFork()?1:0);
			ps.setInt(10, project.hasDownloads()?1:0);
			ps.setInt(11, project.hasIssues()?1:0);
			ps.setInt(12, project.hasWiki()?1:0);
			
			ps.setInt(13, project.getWatchersCount());
			ps.setInt(14, project.getForksCount());
			ps.setInt(15, project.getIssuesCount());
			
			ps.setString(16, project.getOwner().getLogin());
			ps.setInt(17, project.getId());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\PublishedReleaseDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

import util.Dates;
import entity.Release;
import metadao.PublishedReleaseDao;

public class PublishedReleaseDaoImpl implements PublishedReleaseDao{

	private static PublishedReleaseDaoImpl publishedReleaseDaoImpl=new PublishedReleaseDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static PublishedReleaseDaoImpl getInstance(){
		return publishedReleaseDaoImpl;
	}
	
	@Override
	public boolean addPublishedRelease(Release publishedRelease, int projectId) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`releases` (`id`,`tagname`,`targetcommitish`,`name`,`assetsurl`,`body`,`draft`,`prerelease`,`createdat`,`publishedat`,`project_id`) VALUES (?,?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1,publishedRelease.getId());
			ps.setString(2,publishedRelease.getTagName());
			ps.setString(3,publishedRelease.getTargetCommitish());
			ps.setString(4,publishedRelease.getName());
			ps.setString(5,publishedRelease.getAssetsUrl());
			ps.setString(6,publishedRelease.getBody());
			ps.setInt(7,publishedRelease.isDraft()?1:0);
			ps.setInt(8,publishedRelease.isPreRelease()?1:0);
			ps.setString(9,Dates.dateToString(publishedRelease.getCreatedAt()));
			ps.setString(10,Dates.dateToString(publishedRelease.getPublishedAt()));
			ps.setInt(11, projectId);
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean addPublishedReleases(List<Release> publishedRelease,
			int projectId) {
		for(Release upsr:publishedRelease){
			addPublishedRelease(upsr,projectId);
		}

		return true;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\UnPublishedReleaseDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import util.Dates;
import entity.UnPublishedRelease;
import metadao.UnPublishedReleaseDao;

public class UnPublishedReleaseDaoImpl implements UnPublishedReleaseDao{
	
	private static UnPublishedReleaseDaoImpl unPublishedReleaseDaoImpl=new UnPublishedReleaseDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static UnPublishedReleaseDaoImpl getInstance(){
		return unPublishedReleaseDaoImpl;
	}
	
	
	@Override
	public boolean addUnPublishedRelease(UnPublishedRelease unPublishedRelease,int projectId) {
		UnPublishedRelease up = getUnPublishedRelease(unPublishedRelease.getName(),projectId);
		if(up!=null){
			return UpdateRelease(unPublishedRelease,projectId);
		}else{
			Connection con=daoHelper.getConnection();
			PreparedStatement ps=null;
			
			try{
				ps=con.prepareStatement("INSERT INTO `metadata`.`unpublish_releases` (`id`,`name`,`zipball_url`,`tarball_url`,`commit_url`,`project_id`,`date`) VALUES (?,?,?,?,?,?,?)");
				
				ps.setInt(1,0);
				ps.setString(2,unPublishedRelease.getName());
				ps.setString(3,unPublishedRelease.getZipball_url());
				ps.setString(4,unPublishedRelease.getTarball_url());
				ps.setString(5,unPublishedRelease.getCommit_url());
				ps.setInt(6,projectId);
				ps.setString(7,unPublishedRelease.getDate());
				
				ps.execute();			
				return true;
				
			}catch(SQLException e){
				e.printStackTrace();
			}finally{
				daoHelper.closePreparedStatement(ps);
				daoHelper.closeConnection(con);
			}
			
			return false;			
		}
		
		
	}


	@Override
	public UnPublishedRelease getUnPublishedRelease(String releaseName,
			int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.unpublish_releases where name =? and project_id =?");
			ps.setString(1, releaseName);
			ps.setInt(2, project_id);
			
			rs=ps.executeQuery();
			
			UnPublishedRelease upr = null;
			if(rs.next()){
				upr = new UnPublishedRelease();
				upr.setId(rs.getInt("id"));
				upr.setName(rs.getString("name"));
				upr.setZipball_url(rs.getString("zipball_url"));
				upr.setTarball_url(rs.getString("tarball_url"));
				upr.setCommit_url(rs.getString("commit_url"));
				upr.setDate(rs.getString("date"));
				
			}	
			
			return upr;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public List<UnPublishedRelease> getAllUnPublishedReleases(int project_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.unpublish_releases where project_id =?");
			ps.setInt(1, project_id);
			
			rs=ps.executeQuery();
			
			List<UnPublishedRelease> results = new ArrayList<UnPublishedRelease>();
			while(rs.next()){
				UnPublishedRelease upr = new UnPublishedRelease();
				upr.setId(rs.getInt("id"));
				upr.setName(rs.getString("name"));
				upr.setZipball_url(rs.getString("zipball_url"));
				upr.setTarball_url(rs.getString("tarball_url"));
				upr.setCommit_url(rs.getString("commit_url"));
				upr.setDate(rs.getString("date"));
				
				results.add(upr);
			}	
			
			
			return Dates.unPublishedReleaseSort(results);
			
			//return results;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean addUnPublishedReleases(
		List<UnPublishedRelease> unPublishedRelease, int projectId) {
		for(UnPublishedRelease upsr:unPublishedRelease){
			addUnPublishedRelease(upsr,projectId);
		}

		return true;
	}


	@Override
	public UnPublishedRelease getUnPublishedRelease(int release_id) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.unpublish_releases where id=?");
			ps.setInt(1, release_id);
			
			
			rs=ps.executeQuery();
			
			UnPublishedRelease upr = null;
			if(rs.next()){
				upr = new UnPublishedRelease();
				upr.setId(rs.getInt("id"));
				upr.setName(rs.getString("name"));
				upr.setZipball_url(rs.getString("zipball_url"));
				upr.setTarball_url(rs.getString("tarball_url"));
				upr.setCommit_url(rs.getString("commit_url"));
				upr.setDate(rs.getString("date"));
				
			}	
			
			return upr;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}


	@Override
	public boolean CheckaddUnPublishedRelease(
			UnPublishedRelease unPublishedRelease, int projectId) {
		UnPublishedRelease upr = getUnPublishedRelease(unPublishedRelease.getName(),projectId);
		if(upr == null)
			return addUnPublishedRelease(unPublishedRelease,projectId);
		else
			return UpdateRelease(unPublishedRelease,projectId);		
	}


	@Override
	public boolean CheckaddUnPublishedReleases(
			List<UnPublishedRelease> unPublishedRelease, int projectId) {
		
		for(UnPublishedRelease upsr:unPublishedRelease){
			CheckaddUnPublishedRelease(upsr,projectId);
		}

		return true;
	}


	@Override
	public boolean UpdateRelease(UnPublishedRelease unPublishedRelease,
			int projectId) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`unpublish_releases` SET `id`=?,`name`=?,`zipball_url`=?,`tarball_url`=?,`commit_url`=?,`project_id`=?,`date`=? where `id`=? and `project_id`=?");
			
			ps.setInt(1,unPublishedRelease.getId());
			ps.setString(2,unPublishedRelease.getName());
			ps.setString(3,unPublishedRelease.getZipball_url());
			ps.setString(4,unPublishedRelease.getTarball_url());
			ps.setString(5,unPublishedRelease.getCommit_url());
			ps.setInt(6,projectId);
			ps.setString(7,unPublishedRelease.getDate());
			
			ps.setInt(8,unPublishedRelease.getId());
			ps.setInt(9,projectId);
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\impl\UserDaoImpl.java
package metadao.impl;

import helper.DBHelper;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import entity.Contributor;
import entity.User;
import metadao.UserDao;

public class UserDaoImpl implements UserDao{

	private static UserDaoImpl userDaoImpl=new UserDaoImpl();
	private static DBHelper daoHelper=MetaDaoHelperImpl.getBaseDaoInstance();
	
	public static UserDaoImpl getInstance(){
		return userDaoImpl;
	}
	
	@Override
	public boolean addUser(User user) {
		User duplicate = getUser(user.getLogin());
		if(duplicate!=null)
			return updateUser(user);
		
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		
		try{
			ps=con.prepareStatement("INSERT INTO `metadata`.`user` (`id`,`name`,`login`,`email`,`company`,`location`,`blog`,`hireable`,`followers`,`following`,`publicrepos`,`publicgists`,`createdat`,`updatedat`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
			
			ps.setInt(1,user.getId());
			ps.setString(2,user.getName());
			ps.setString(3, user.getLogin());
			ps.setString(4, user.getEmail());
			ps.setString(5,user.getCompany());
			ps.setString(6,user.getLocation());
			ps.setString(7, user.getBlog());
			ps.setInt(8, user.isHireable()?1:0);
			ps.setInt(9, user.getFollowers());
			ps.setInt(10, user.getFollowing());
			ps.setInt(11, user.getPublic_repos());
			ps.setInt(12, user.getPublic_gists());
			ps.setString(13, user.getCreated_at());
			ps.setString(14, user.getUpdatedAt());
			
			ps.execute();			
			return true;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean addUsers(List<User> users) {
		for(User u:users){
			addUser(u);
		}
		return true;
	}

	@Override
	public User getUser(String login) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		ResultSet rs=null;
		
		try{
			ps=con.prepareStatement("select * from metadata.user where login =?");
			ps.setString(1, login);
			
			rs=ps.executeQuery();
			
			User u = null;
			if(rs.next()){
				String name = rs.getString("name");
				String login_ = rs.getString("login");
				String email = rs.getString("email");
				String company = rs.getString("company");
				String location = rs.getString("location");
				String blog = rs.getString("blog");
				String createdat = rs.getString("createdat");
				String updatedat = rs.getString("updatedat");
				
				int id = rs.getInt("id");
				int hireable = rs.getInt("hireable");
				int followers = rs.getInt("followers");
				int following = rs.getInt("following");
				int publicrepos = rs.getInt("publicrepos");
				int publicgists = rs.getInt("publicgists");
				
				u = new User(login_,name);
				u.setBlog(blog);
				u.setEmail(email);
				u.setCompany(company);
				u.setLocation(location);
				u.setCreated_at(createdat);
				u.setUpdatedAt(updatedat);
				u.setId(id);
				u.setFollowers(followers);
				u.setFollowing(following);
				u.setPublic_gists(publicgists);
				u.setPublic_repos(publicrepos);
				u.setHireable((hireable==1));
			}	
			
			return u;
			
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closeResult(rs);
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return null;
	}

	@Override
	public boolean updateUser(User user) {
		Connection con=daoHelper.getConnection();
		PreparedStatement ps=null;
		try{
			ps=con.prepareStatement("UPDATE `metadata`.`user` SET `id`=?,`name`=?,`login`=?,`email`=?,`company`=?,`location`=?,`blog`=?,`hireable`=?,`followers`=?,`following`=?,`publicrepos`=?,`publicgists`=?,`createdat`=?,`updatedat`=? where `id`=?");
			
			ps.setInt(1,user.getId());
			ps.setString(2,user.getName());
			ps.setString(3, user.getLogin());
			ps.setString(4, user.getEmail());
			ps.setString(5,user.getCompany());
			ps.setString(6,user.getLocation());
			ps.setString(7, user.getBlog());
			ps.setInt(8, user.isHireable()?1:0);
			ps.setInt(9, user.getFollowers());
			ps.setInt(10, user.getFollowing());
			ps.setInt(11, user.getPublic_repos());
			ps.setInt(12, user.getPublic_gists());
			ps.setString(13, user.getCreated_at());
			ps.setString(14, user.getUpdatedAt());
			ps.setInt(15, user.getId());
			
			ps.execute();
			return true;
		}catch(SQLException e){
			e.printStackTrace();
		}finally{
			daoHelper.closePreparedStatement(ps);
			daoHelper.closeConnection(con);
		}
		
		return false;
	}

	@Override
	public boolean CheckaddUser(User user) {
		User u = getUser(user.getLogin());
		if(u == null)
			return addUser(user);
		else
			return updateUser(user);
		
	}

	@Override
	public boolean CheckaddUsers(List<User> users) {
		for(User u:users){
			CheckaddUser(u);
		}
		return true;
	}

	@Override
	public ArrayList<User> getAllUsers(List<Contributor> contributors) {
		ArrayList<User> users = new ArrayList<User>();
		for(Contributor c:contributors){
			User u = getUser(c.getLogin());
			if(u!=null)
				users.add(u);			
		}
		
		return users;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\IssueDao.java
package metadao;

import java.util.ArrayList;
import java.util.List;

public interface IssueDao {
	
	/**
	 * get useful issue
	 * @param project_id
	 * @return
	 */
	public ArrayList<usefuldata.Issue> getAllIssues(int project_id);
	
	public boolean addIssue(entity.Issue issue,int project_id);
	
	public boolean CheckaddIssue(entity.Issue issue,int project_id);
	
	public boolean addIssues(List<entity.Issue> issues,int project_id);
	
	public boolean CheckaddIssues(List<entity.Issue> issues,int project_id);
	
	public boolean updateIssue(entity.Issue issue,int project_id);
	
	/**
	 * get meta issue
	 * @param project_id
	 * @return
	 */
	public List<entity.Issue> getAllMetaIssues(int project_id);
	
	public int IssueNum(int project_id,String start_time,String end_time);
	
	public int IssueNum(int project_id,String start_time);
	
	public entity.Issue getIssue(int issue_id,int project_id);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\MetaDaoController.java
package metadao;
import crawler.DataSource;

public abstract class MetaDaoController {
	protected DataSource dataSource;
	
	public MetaDaoController(DataSource dataSource){
		this.dataSource = dataSource;
	}
	
	public abstract void IntoDataBase();

	public DataSource getDataSource() {
		return dataSource;
	}

	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\MySQLController.java
package metadao;

import java.util.List;

import crawler.DataSource;
import entity.Comment;
import entity.Contributor;
import entity.Issue;
import entity.Project;
import entity.UnPublishedRelease;
import entity.User;
import factory.MetaDaoFactory;

public class MySQLController extends MetaDaoController{

	public MySQLController(DataSource dataSource) {
		super(dataSource);
	}

	@Override
	public void IntoDataBase() {
		if(this.dataSource.getInIndex() == null){
			Project project = this.dataSource.getProject();
			project.getOwner().setLogin(this.dataSource.getOwner());
			MetaDaoFactory.getProjectDao().addProject(project);
			
			List<Comment> comments = this.dataSource.getComments();
			int project_id = project.getId();
			if(comments != null)
				MetaDaoFactory.getCommentDao().addComments(comments,project_id);
			
			List<Contributor> contributors = this.dataSource.getContributors();
			MetaDaoFactory.getContributorDao().addContributors(contributors, project_id);
			
			List<Issue> issues = this.dataSource.getIssues();
			if(issues != null)
				MetaDaoFactory.getIssueDao().addIssues(issues, project_id);
			
			//IssueLabel issuelabel = this.dataSource.getIssuelabel();
			//not finished yet
			
			//Language language = this.dataSource.getLanguage();
			//not finished yet
			
			//License license = this.dataSource.getLicense();
			//not finished yet
			
			//Milestone milestone = this.dataSource.getMilestone();
			//not finished yet
			
			//PullRequest pullrequest = this.dataSource.getPullrequest();
			//not finished yet
			
			//List<Release> releases = this.dataSource.getReleases();
			//not finished yet
			
			List<UnPublishedRelease> unpublish_releases = this.dataSource.getUnpublish_releases();
			if(unpublish_releases != null)
				MetaDaoFactory.getUnPublishedReleaseDao().addUnPublishedReleases(unpublish_releases, project_id);
			
			List<User> users = this.dataSource.getUsers();
			MetaDaoFactory.getUserDao().addUsers(users);
			
			MetaDaoFactory.getCrawlindexDao().addCrawlindex(this.dataSource.getOutIndex());
			
			
		}else{
			//if already exist then update it
			
			Project project = this.dataSource.getProject();
			project.getOwner().setLogin(this.dataSource.getOwner());
			MetaDaoFactory.getProjectDao().addProject(project);
			
			List<Comment> comments = this.dataSource.getComments();
			int project_id = project.getId();
			if(comments != null)
				MetaDaoFactory.getCommentDao().CheckaddComments(comments,project_id);
			
			List<Contributor> contributors = this.dataSource.getContributors();
			MetaDaoFactory.getContributorDao().CheckaddContributors(contributors, project_id);
			
			List<Issue> issues = this.dataSource.getIssues();
			if(issues != null)
				MetaDaoFactory.getIssueDao().CheckaddIssues(issues, project_id);
			
			List<UnPublishedRelease> unpublish_releases = this.dataSource.getUnpublish_releases();
			if(unpublish_releases != null)
				MetaDaoFactory.getUnPublishedReleaseDao().CheckaddUnPublishedReleases(unpublish_releases, project_id);
			
			List<User> users = this.dataSource.getUsers();
			MetaDaoFactory.getUserDao().CheckaddUsers(users);
			
			MetaDaoFactory.getCrawlindexDao().addCrawlindex(this.dataSource.getOutIndex());
		}
				
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\ProjectDao.java
package metadao;

import entity.Project;

public interface ProjectDao {
	/**
	 * after crawling call this method
	 * inside the method use Dates to format the date
	 * @param project
	 * @return
	 */
	public boolean addProject(Project project);

	public Project getProject(String owner,String projectName);
	
	
	public boolean updateProject(Project project);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\PublishedReleaseDao.java
package metadao;

import java.util.List;

import entity.Release;

public interface PublishedReleaseDao {
	public boolean addPublishedRelease(Release publishedRelease,int projectId);
	
	public boolean addPublishedReleases(List<Release> publishedRelease,int projectId);
		
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\UnPublishedReleaseDao.java
package metadao;

import java.util.List;

import entity.UnPublishedRelease;

public interface UnPublishedReleaseDao {
	public boolean addUnPublishedRelease(UnPublishedRelease unPublishedRelease,int projectId);
	
	public boolean CheckaddUnPublishedRelease(UnPublishedRelease unPublishedRelease,int projectId);
		
	public boolean addUnPublishedReleases(List<UnPublishedRelease> unPublishedRelease,int projectId);
	
	public boolean CheckaddUnPublishedReleases(List<UnPublishedRelease> unPublishedRelease,int projectId);
	
	public UnPublishedRelease getUnPublishedRelease(String releaseName,int project_id);
	
	public UnPublishedRelease getUnPublishedRelease(int release_id);
	
	public boolean UpdateRelease(UnPublishedRelease unPublishedRelease,int projectId);
	
	
	/**
	 * 
	 * @param project_id
	 * @return releases already sorted
	 */
	public List<UnPublishedRelease> getAllUnPublishedReleases(int project_id);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\metadao\UserDao.java
package metadao;

import java.util.ArrayList;
import java.util.List;

import entity.User;

public interface UserDao {
	public boolean addUser(entity.User user);
	
	public boolean addUsers(List<entity.User> users);
	
	public entity.User getUser(String login);
	
	public boolean updateUser(entity.User user);
	
	public boolean CheckaddUser(entity.User user);
	
	public boolean CheckaddUsers(List<entity.User> users);
	
	public ArrayList<User> getAllUsers(List<entity.Contributor> contributors);
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\scmclient\EmptyProjectAtDateException.java
package scmclient;

import entity.GroundhogException;



/**
 * Thrown when a checkout operation is attempted for a date that corresponds
 * to phase when the project has zero commits.
 * 
 *
 */
public class EmptyProjectAtDateException extends GroundhogException {	
	private static final long serialVersionUID = 1L;
	
	public EmptyProjectAtDateException(String msg) {
		super("No source code was found to this date: " + msg);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\scmclient\GitClient.java
package scmclient;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.CheckoutConflictException;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.InvalidRefNameException;
import org.eclipse.jgit.api.errors.InvalidRemoteException;
import org.eclipse.jgit.api.errors.RefAlreadyExistsException;
import org.eclipse.jgit.api.errors.TransportException;
import org.eclipse.jgit.errors.StopWalkException;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.filter.RevFilter;
import org.gitective.core.CommitFinder;
import org.gitective.core.filter.commit.AllCommitFilter;
import org.gitective.core.filter.commit.AndCommitFilter;
import org.gitective.core.filter.commit.CommitCountFilter;
import org.gitective.core.filter.commit.CommitFilter;
import org.gitective.core.filter.commit.CommitterDateFilter;

import util.Dates;



/**
 * 
 * 
 * 
 */
public class GitClient {

	/**
	 * Performs a clone operation for the given project URL and places the
	 * fetched code into the destination directory.
	 * 
	 * @param url
	 *            the project's URL
	 * @param destination
	 */
	public void clone(final String url, final File destination) {
		ExecutorService executor = Executors.newSingleThreadExecutor();
		executor.execute(new Runnable() {
			public void run() {
				try {
					Git git = Git.cloneRepository().setURI(url).setDirectory(destination).call();
					git.getRepository().close();
				} catch (InvalidRemoteException e) {
					e.printStackTrace();
				} catch (TransportException e) {
					e.printStackTrace();
				} catch (GitAPIException e) {
					e.printStackTrace();
				}
			}
		});
		executor.shutdown();
		
		try {
			executor.awaitTermination(10, TimeUnit.MINUTES);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Points to head commit on master branch
	 * 
	 * @param repositoryFolder
	 */
	public void checkout(File repositoryFolder) {
		try {
			Git git = Git.open(repositoryFolder);
			Repository repo = git.getRepository();

			CommitFinder finder = new CommitFinder(repo);
			CommitCountFilter count = new CommitCountFilter();
			finder.setFilter(new AndCommitFilter(new CommitFilter() {

				public boolean include(RevWalk walker, RevCommit cmit)
						throws IOException {
					throw StopWalkException.INSTANCE;
				}

				public RevFilter clone() {
					return this;
				}
			}, count));
			finder.find();

			System.out.println(count.getCount());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Performs a checkout to the given Git repository
	 * 
	 * @param repositoryFolder
	 *            the repository where the checkout will be performed
	 * @param date
	 * @throws IOException
	 * @throws RefAlreadyExistsException
	 * @throws InvalidRefNameException
	 * @throws CheckoutConflictException
	 * @throws GitAPIException
	 * @throws EmptyProjectAtDateException
	 */
	public void checkout(File repositoryFolder, Date date) throws IOException,
			RefAlreadyExistsException, InvalidRefNameException,
			CheckoutConflictException, GitAPIException,
			EmptyProjectAtDateException {

		Git git = Git.open(repositoryFolder);
		Repository rep = git.getRepository();
		CommitFinder finder = new CommitFinder(rep);
		final List<RevCommit> commits = new ArrayList<RevCommit>();

		finder.setFilter(new CommitterDateFilter(date).negate());
		AllCommitFilter filter = new AllCommitFilter() {
			@Override
			public boolean include(RevWalk walker, RevCommit commit)
					throws IOException {
				boolean include = super.include(walker, commit);
				if (include) {
					commits.add(commit);
				}
				return include;
			}
		};
		finder.setMatcher(filter);
		finder.find();

		if (commits.size() == 0) {
			rep.close();
			throw new EmptyProjectAtDateException(
					new Dates("yyyy-MM-dd").format(date));
		}

		RevCommit closest = Collections.max(commits,
				new Comparator<RevCommit>() {
					public int compare(RevCommit c1, RevCommit c2) {
						return c1.getCommitterIdent().getWhen()
								.compareTo(c2.getCommitterIdent().getWhen());
					}
				});

		/*
		 * Workaround ahead, since JGit in Windows automatically adds ^M
		 * (Carriage Returns) to some files after, leaving the working tree
		 * dirty. Neither JGit stash nor reset will work. So we need to commit!
		 * This commit doesn't affects metrics, since we do a checkout after it.
		 * To reproduce this bug, try to checkout
		 * https://github.com/playframework/ to 2012-05-01 12:00 TODO: report
		 * this bug to JGit team.
		 */
		Set<String> mods = git.status().call().getModified();
		if (!mods.isEmpty()) {
			AddCommand addCmd = git.add();
			for (String m : mods) {
				addCmd.addFilepattern(m);
			}
			addCmd.call();
			git.commit().setMessage("Groundhog commit").call();
		}
		/* workaround end. */

		git.checkout().setName("groundhog-analyze").setStartPoint(closest)
				.setCreateBranch(true).call();
		rep.close();
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\scmclient\ScmModule.java
package scmclient;


import com.google.inject.AbstractModule;
import com.google.inject.Singleton;

public class ScmModule extends AbstractModule {

	@Override
	protected void configure() {
		bind(GitClient.class).in(Singleton.class);
		bind(SVNClient.class).in(Singleton.class);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\scmclient\SVNClient.java
package scmclient;

import java.io.File;

import org.tmatesoft.svn.core.SVNDepth;
import org.tmatesoft.svn.core.SVNException;
import org.tmatesoft.svn.core.SVNURL;
import org.tmatesoft.svn.core.wc.SVNClientManager;
import org.tmatesoft.svn.core.wc.SVNRevision;
import org.tmatesoft.svn.core.wc.SVNUpdateClient;



public class SVNClient {
	private SVNClientManager svn;
	
	public SVNClient() {
		this.svn = SVNClientManager.newInstance();
	}
	
	/**
	 * Performs a checkout for a project with the given URL on the given destination directory
	 * @param url the project URL
	 * @param destination the destination directory
	 * @throws SVNException
	 */
	public void checkout(String url, File destination) throws SVNException {
		SVNUpdateClient client = svn.getUpdateClient();
		client.doCheckout(SVNURL.parseURIDecoded(url),
				destination,
				SVNRevision.HEAD,
				SVNRevision.HEAD,
				SVNDepth.INFINITY,
				false);
	}
	
	/**
	 * Performs a checkout for a project with the given URL on the given destination directory with a
	 * specified SVN revision
	 * @param url the project URL
	 * @param destination the destination directory
	 * @param revision the SVN revision
	 * @throws SVNException
	 */
	public void checkout(String url, File destination, SVNRevision revision) throws SVNException {
		SVNUpdateClient client = svn.getUpdateClient();
		client.doCheckout(SVNURL.parseURIDecoded(url),
				destination,
				revision,
				revision,
				SVNDepth.INFINITY,
				false);
	}
	
	public void close() {
		svn.dispose();
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\CrawlCommits.java
package search;

import http.HttpModule;
import http.Requests;

import java.util.ArrayList;
import java.util.List;

import search.UrlBuilder.GithubAPI;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.inject.Guice;
import com.google.inject.Inject;

import entity.Commit;
import entity.GroundhogException;
import entity.Project;
import entity.User;

public class CrawlCommits{

	public static int INFINITY = -1;

	private final Gson gson;
	private final Requests requests;
	private final UrlBuilder builder;
	
	
	@Inject
	public CrawlCommits(Requests requests) {
		this.requests = requests;
		this.gson = new Gson();
		this.builder = Guice.createInjector(new HttpModule()).getInstance(UrlBuilder.class);
	}
	
	
	/**
	 * get a contributor's all commits about a certain project
	 * @param project
	 * @param commiter
	 * @return List<Commit>
	 */
		public List<Commit> getProjectCommitsByCommiter(Project project, String commiter){
			System.out.println("Searching " +commiter + "'s commits metadata");
					
			int page = 1;
			
			String searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/commits?author=" + commiter + "&page=" +page +"&per_page=80")
					  .build();
			
			System.out.println(searchUrl);
			
			try{
				String jsonLegacy = getWithProtection(searchUrl);
				
				//could be requests.get(searchUrl)
				JsonElement jsonElement = gson.fromJson(jsonLegacy, JsonElement.class);
				
				JsonArray jsonArray = jsonElement.getAsJsonArray();

				List<Commit> commits = new ArrayList<>();
				
				while(jsonArray.size()!=0){
				
				for (JsonElement element : jsonArray) {
					Commit commit = gson.fromJson(element, Commit.class);
					commit.setProject(project);
					
					User user = gson.fromJson(element.getAsJsonObject().get("committer"), User.class);
					commit.setCommiter(user);
					
					commit.setMessage(element.getAsJsonObject().get("commit").getAsJsonObject().get("message").getAsString());

					String date = element.getAsJsonObject().get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
					commit.setCommitDate(date);
					
					//System.out.println(commit.getCommitDate());
					
					
					String sha = element.getAsJsonObject().get("sha").getAsString();
					commit.setSha(sha);
					
					String anotherUrl = builder.uses(GithubAPI.ROOT)
							  .withParam("repos")
							  .withSimpleParam("/", project.getOwner().getLogin())
							  .withSimpleParam("/", project.getName())
							  .withParam("/commits")
							  .withParam("/" + sha)
							  .build();
					
					int add = 0;
					int del = 0;
					JsonElement ano_jsonElement = gson.fromJson(requests.get(anotherUrl), JsonElement.class);
					JsonArray ano_jsonArray = ano_jsonElement.getAsJsonObject().get("files").getAsJsonArray();
					for(JsonElement e:ano_jsonArray){
						int adi = e.getAsJsonObject().get("additions").getAsInt();
						int dei = e.getAsJsonObject().get("deletions").getAsInt();
						add += adi;
						del += dei;
					}
					commit.setAdditionsCount(add);
					commit.setDeletionsCount(del);
								
					commits.add(commit);
				}
				
				page++;
				searchUrl = builder.uses(GithubAPI.ROOT)
						  .withParam("repos")
						  .withSimpleParam("/", project.getOwner().getLogin())
						  .withSimpleParam("/", project.getName())
						  .withParam("/commits?author=" + commiter + "&page=" +page +"&per_page=80")
						  .build();
				
				System.out.println(searchUrl);
				
				jsonElement = gson.fromJson(requests.get(searchUrl), JsonElement.class);
				jsonArray = jsonElement.getAsJsonArray();
				}

				return commits;
				
				
			}catch (GroundhogException e) {
				e.printStackTrace();
				throw new SearchException(e);
			}
						
		}
		
		private String getWithProtection(String url){
			String data = requests.get(url);

			if (data.contains("API rate limit exceeded for")) {
				try {
					Thread.sleep(1000 * 60 * 60);
					data = requests.get(url);

				} catch (InterruptedException ex) {
					ex.printStackTrace();
				}
			}

			return data;
		}
		
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\ForgeSearch.java
package search;

import java.io.IOException;
import java.util.List;

import entity.Issue;
import entity.Project;


/**
 * An interface that defines the forge search functionality.
 * A forge search must receive a search term and a page number (1-indexed) and
 * return a list of ForgeProjects objects. These projects can be used by a ForgeCrawler
 * to download source code.
 * 
 * 
 */
public interface ForgeSearch {
  
	/**
	 * Uses search functionality of the forge to get projects.
	 * 
	 * @param term term to be searched (ex: a project name, like h2database). 
	 * If the term is a null String then the method will return all the forge projects. 
	 * @param page 1-indexed page to get results (ie: starts with 1).
	 * @param limit Maximum number of projects to be returned. Negative values 
	 * for this parameter will result in an unbounded search.
	 * 
	 * @return list of ForgeProject entities with projects info
	 * @throws SearchException when something nasty happens
	 */
	public List<Project> getProjects(String term, int page, int limit) throws SearchException;
	
	/**
	 * Uses search functionality of the forge to get projects.
	 * 
	 * @param term term to be searched (ex: a project name, like h2database)
	 * @parm username the user that should have the aforementioned project
	 * @param page 1-indexed page to get results (ie: starts with 1)
	 * 
	 * @return list of ForgeProject entities with projects info
	 * @throws SearchException when something nasty happens
	 */
	public List<Project> getProjects(String term, String username, int page) throws SearchException;
	
	/**
	 * Provides a dump of every projects in the forge.
	 * 
	 * @param since The search will start from the projects 
	 * with the specified integer ID.
	 * @param limit Maximum number of projects to be returned. Negative values 
	 * for this parameter will result in an unbounded search.
	 * 
	 * @return list of ForgeProject entities with projects info
	 * @throws Exception when something nasty happens
	 */
	public List<Project> getAllForgeProjects(int since , int limit) throws SearchException;

	public List<Issue> getAllProjectIssues(Project gr) throws IOException;
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\MetaSearchGitHub.java
package search;

import http.HttpModule;
import http.Requests;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import search.UrlBuilder.GithubAPI;
import util.Dates;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.inject.Guice;
import com.google.inject.Inject;

import entity.Comment;
import entity.Commit;
import entity.CommitFile;
import entity.Contributor;
import entity.Crawlindex;
import entity.GroundhogException;
import entity.Issue;
import entity.IssueLabel;
import entity.Project;
import entity.Release;
import entity.UnPublishedRelease;
import entity.User;

public class MetaSearchGitHub implements ForgeSearch{

	final static Logger logger = LoggerFactory.getLogger(MetaSearchGitHub.class);
	public static int INFINITY = -1;

	private final Gson gson;
	private final Requests requests;
	private final UrlBuilder builder;
	
	private Crawlindex crawlIndex;
		

	@Inject
	public MetaSearchGitHub(Requests requests) {
		this.requests = requests;
		this.gson = new Gson();
		this.builder = Guice.createInjector(new HttpModule()).getInstance(UrlBuilder.class);
		crawlIndex = new Crawlindex();
	}
		
	@Override
	public List<Project> getProjects(String term, int page, int limit)
			throws SearchException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Project> getProjects(String term, String username, int page)
			throws SearchException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Project> getAllForgeProjects(int since, int limit)
			throws SearchException {
		// TODO Auto-generated method stub
		return null;
	}

	/**
	 * Fetches all the Issues of the given {@link Project} from the GitHub API
	 * 
	 * @param project the @{link Project} of which the Issues are about
	 * @return a {@link List} of {@link Issues} objects
	 */
	
	public List<Issue> getAllProjectIssues(Project project) {

		logger.info(("Searching project all issues metadata"));
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/issues")
				  .withParam("?page=" +page +"&per_page=80")
				  .build();
				
		String  jsonString = getWithProtection(searchUrl);
				
		JsonElement jsonElement = gson.fromJson(jsonString, JsonElement.class);
		JsonArray jsonArray = jsonElement.getAsJsonArray();
		
		List<Issue> issues = new ArrayList<Issue>();
		List<IssueLabel> labels = new ArrayList<IssueLabel>();
				
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Issue issue = gson.fromJson(element, Issue.class);
				issue.setProject(project);
				
				for (JsonElement lab : element.getAsJsonObject().get("labels").getAsJsonArray()) {
					IssueLabel label = gson.fromJson(lab, IssueLabel.class);				
					labels.add(label);
				}
				
				issue.setLabels(labels);				
				issues.add(issue);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/issues")
					  .withParam("?page=" +page +"&per_page=80")
					  .build();
			
			jsonString = getWithProtection(searchUrl);
			jsonElement = gson.fromJson(jsonString, JsonElement.class);
			
			jsonArray = jsonElement.getAsJsonArray();
		}
		
		if(page == 1){
			this.crawlIndex.setIssue_page(page);
		}else
			this.crawlIndex.setIssue_page(page-1);
		
		return issues;
	}

	public List<Issue> getAllClosedProjectIssues(Project project){
		logger.info(("Searching project closed issues metadata"));		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/issues")
				  .withParam("?state=closed")
				  .withParam("&page=" +page +"&per_page=80")
				  .build();
				
		String  jsonString = getWithProtection(searchUrl);
				
		JsonElement jsonElement = gson.fromJson(jsonString, JsonElement.class);
		JsonArray jsonArray = jsonElement.getAsJsonArray();
		
		List<Issue> issues = new ArrayList<Issue>();
		List<IssueLabel> labels = new ArrayList<IssueLabel>();
				
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Issue issue = gson.fromJson(element, Issue.class);
				issue.setProject(project);
				
				for (JsonElement lab : element.getAsJsonObject().get("labels").getAsJsonArray()) {
					IssueLabel label = gson.fromJson(lab, IssueLabel.class);				
					labels.add(label);
				}
				
				issue.setLabels(labels);				
				issues.add(issue);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/issues")
					  .withParam("?state=closed")
					  .withParam("&page=" +page +"&per_page=80")
					  .build();
			
			jsonString = getWithProtection(searchUrl);
			jsonElement = gson.fromJson(jsonString, JsonElement.class);
			
			jsonArray = jsonElement.getAsJsonArray();
		}
		
		if(page == 1){
			this.crawlIndex.setClosed_issue_page(page);
		}else
			this.crawlIndex.setClosed_issue_page(page-1);
		
		return issues;
	}

	public List<Issue> getAllClosedProjectIssues(Project project,int page){
		logger.info(("Searching project closed issues metadata"));		
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/issues")
				  .withParam("?state=closed")
				  .withParam("&page=" +page +"&per_page=80")
				  .build();
				
		String  jsonString = getWithProtection(searchUrl);
				
		JsonElement jsonElement = gson.fromJson(jsonString, JsonElement.class);
		JsonArray jsonArray = jsonElement.getAsJsonArray();
		
		List<Issue> issues = new ArrayList<Issue>();
		List<IssueLabel> labels = new ArrayList<IssueLabel>();
				
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Issue issue = gson.fromJson(element, Issue.class);
				issue.setProject(project);
				
				for (JsonElement lab : element.getAsJsonObject().get("labels").getAsJsonArray()) {
					IssueLabel label = gson.fromJson(lab, IssueLabel.class);				
					labels.add(label);
				}
				
				issue.setLabels(labels);				
				issues.add(issue);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/issues")
					  .withParam("?state=closed")
					  .withParam("&page=" +page +"&per_page=80")
					  .build();
			
			jsonString = getWithProtection(searchUrl);
			jsonElement = gson.fromJson(jsonString, JsonElement.class);
			
			jsonArray = jsonElement.getAsJsonArray();
		}
		
		if(page == 1){
			this.crawlIndex.setClosed_issue_page(page);
		}else
			this.crawlIndex.setClosed_issue_page(page-1);
				
		return issues;
	}
	
	public List<Issue> getAllProjectIssues(Project project,int page){
		logger.info(("Searching project all issues metadata"));
		
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/issues")
				  .withParam("?page=" +page +"&per_page=80")
				  .build();
				
		
		String  jsonString = getWithProtection(searchUrl);
		
		//System.out.println(jsonString);
		
		JsonElement jsonElement = gson.fromJson(jsonString, JsonElement.class);
		JsonArray jsonArray = jsonElement.getAsJsonArray();
		
		
		List<Issue> issues = new ArrayList<Issue>();
		List<IssueLabel> labels = new ArrayList<IssueLabel>();
		
		
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Issue issue = gson.fromJson(element, Issue.class);
				issue.setProject(project);
				
				for (JsonElement lab : element.getAsJsonObject().get("labels").getAsJsonArray()) {
					IssueLabel label = gson.fromJson(lab, IssueLabel.class);				
					labels.add(label);
				}
				
				issue.setLabels(labels);
			
				issues.add(issue);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/issues")
					  .withParam("?page=" +page +"&per_page=80")
					  .build();
			
			jsonString = getWithProtection(searchUrl);
			jsonElement = gson.fromJson(jsonString, JsonElement.class);
			jsonArray = jsonElement.getAsJsonArray();
		}
		if(page == 1)
			this.crawlIndex.setIssue_page(page);
		else
			this.crawlIndex.setIssue_page(page-1);
		
		return issues;
	}
/**
 * get a contributor's all commits about a certain project
 * @param project
 * @param commiter
 * @return List<Commit>
 */
	public List<Commit> getProjectCommitsByCommiter(Project project, String commiter){
		//System.out.println("Searching " +commiter + "'s commits metadata");
				
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/commits?author=" + commiter + "&page=" +page +"&per_page=80")
				  .build();
		
		
		
		try{
			String jsonLegacy = getWithProtection(searchUrl);
			
			//could be requests.get(searchUrl)
			JsonElement jsonElement = gson.fromJson(jsonLegacy, JsonElement.class);
			
			JsonArray jsonArray = jsonElement.getAsJsonArray();

			List<Commit> commits = new ArrayList<>();
			
			while(jsonArray.size()!=0){
			
			for (JsonElement element : jsonArray) {
				Commit commit = gson.fromJson(element, Commit.class);
				commit.setProject(project);
				
				User user = gson.fromJson(element.getAsJsonObject().get("committer"), User.class);
				commit.setCommiter(user);
				
				commit.setMessage(element.getAsJsonObject().get("commit").getAsJsonObject().get("message").getAsString());

				String date = element.getAsJsonObject().get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
				commit.setCommitDate(date);
				
				//System.out.println(commit.getCommitDate());
				
				
				String sha = element.getAsJsonObject().get("sha").getAsString();
				commit.setSha(sha);
				
				String anotherUrl = builder.uses(GithubAPI.ROOT)
						  .withParam("repos")
						  .withSimpleParam("/", project.getOwner().getLogin())
						  .withSimpleParam("/", project.getName())
						  .withParam("/commits")
						  .withParam("/" + sha)
						  .build();
				
				int add = 0;
				int del = 0;
				JsonElement ano_jsonElement = gson.fromJson(requests.get(anotherUrl), JsonElement.class);
				JsonArray ano_jsonArray = ano_jsonElement.getAsJsonObject().get("files").getAsJsonArray();
				for(JsonElement e:ano_jsonArray){
					int adi = e.getAsJsonObject().get("additions").getAsInt();
					int dei = e.getAsJsonObject().get("deletions").getAsInt();
					add += adi;
					del += dei;
				}
				commit.setAdditionsCount(add);
				commit.setDeletionsCount(del);
							
				commits.add(commit);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/commits?author=" + commiter + "&page=" +page +"&per_page=80")
					  .build();
			
			
			
			jsonElement = gson.fromJson(requests.get(searchUrl), JsonElement.class);
			jsonArray = jsonElement.getAsJsonArray();
			}

			return commits;
			
			
		}catch (GroundhogException e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
		
		
		
		
	}
	
	public List<Commit> getProjectCommits(Project project,int page){
		logger.info(("Searching " + "updated commits metadata"));
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/commits?"  + "&page=" +page +"&per_page=80")
				  .build();
		
		
		try{
			String jsonLegacy = getWithProtection(searchUrl);
			
			//could be requests.get(searchUrl)
			JsonElement jsonElement = gson.fromJson(jsonLegacy, JsonElement.class);
			
			JsonArray jsonArray = jsonElement.getAsJsonArray();

			List<Commit> commits = new ArrayList<>();
			
			while(jsonArray.size()!=0){
			
			for (JsonElement element : jsonArray) {
				Commit commit = gson.fromJson(element, Commit.class);
				commit.setProject(project);
				
				User user = gson.fromJson(element.getAsJsonObject().get("committer"), User.class);
				commit.setCommiter(user);
				
				commit.setMessage(element.getAsJsonObject().get("commit").getAsJsonObject().get("message").getAsString());

				String date = element.getAsJsonObject().get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
				commit.setCommitDate(date);
				
				//System.out.println(commit.getCommitDate());
				
				
				String sha = element.getAsJsonObject().get("sha").getAsString();
				commit.setSha(sha);
				
				String anotherUrl = builder.uses(GithubAPI.ROOT)
						  .withParam("repos")
						  .withSimpleParam("/", project.getOwner().getLogin())
						  .withSimpleParam("/", project.getName())
						  .withParam("/commits")
						  .withParam("/" + sha)
						  .build();
				
				int add = 0;
				int del = 0;
				JsonElement ano_jsonElement = gson.fromJson(requests.get(anotherUrl), JsonElement.class);
				JsonArray ano_jsonArray = ano_jsonElement.getAsJsonObject().get("files").getAsJsonArray();
				for(JsonElement e:ano_jsonArray){
					int adi = e.getAsJsonObject().get("additions").getAsInt();
					int dei = e.getAsJsonObject().get("deletions").getAsInt();
					add += adi;
					del += dei;
				}
				commit.setAdditionsCount(add);
				commit.setDeletionsCount(del);
							
				commits.add(commit);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/commits?"  + "&page=" +page +"&per_page=80")
					  .build();
			
			
			jsonElement = gson.fromJson(requests.get(searchUrl), JsonElement.class);
			jsonArray = jsonElement.getAsJsonArray();
			}

			if(page == 1)
				this.crawlIndex.setCommit_page(page);
			else
				this.crawlIndex.setCommit_page(page-1);
			
			return commits;
			
			
		}catch (GroundhogException e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
		
	}
	
	
	/**
	 * try to find a certain project 
	 * if not return null
	 * @param projectName
	 * @param owner
	 * @return Project or null
	 */
	public Project getProject(String projectName,String ownerName){
		String searchUrl = builder.uses(GithubAPI.SEARCH)
				  .withParam(projectName + "+user:" + ownerName)
				  .withParam("sort", "stars")
				  .withParam("order", "desc")
				  .build();
		
		logger.info(("trying to get " + ownerName +"'s " + projectName + " project"));
		//System.out.println(searchUrl);
		try{
			String json = getWithProtection(searchUrl);
			
			JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();
			JsonArray jsonArray= jsonObject.get("items").getAsJsonArray();

			Project p = null;
			
			for (JsonElement element : jsonArray) {

				p = gson.fromJson(element, Project.class);

				String owner = element.getAsJsonObject().get("owner").getAsJsonObject().get("login").getAsString();
				p.setCheckoutURL(String.format("https://github.com/%s/%s.git", owner, p.getName()));

				String userUrl = builder.uses(GithubAPI.USERS).withParam(owner).build();
				String userJson = requests.get(userUrl);
				User user = gson.fromJson(userJson, User.class);

				p.setOwner(user);
				
			}
			
			return p;
		}catch (GroundhogException e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
		
		
	}
	
	/**
	 * 
	 * <p>Fetches all the contributors of the given {@link Project} from the GitHub API</p>
	 * <p>modified by guanjun</p>
	 * @see <p>We can map all {@link Contributor} into a {@link User} by {@link Contributor#getUrl} method that return is the same for a Contributor and his correspondent User ({@link User#getUrl})</p>
	 * @param project the @{link Project} to get the contributors from
	 * @return a {@link List} of {@link Contributor} objects
	 */
	public List<Contributor> getAllProjectContributors(Project project) {
		
		logger.info(("Searching project all contributors metadata"));
		
		List<Contributor> contributors = new ArrayList<>();
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/contributors")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        
        while(jsonArray.size()!=0){
        	
        	for (JsonElement element: jsonArray) {
            	Contributor contributor = gson.fromJson(element, Contributor.class);
            	contributors.add(contributor);
            }
        	
        	page++;
        	
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", project.getUser().getLogin())
  				  .withSimpleParam("/", project.getName())
  				  .withParam("/contributors")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
        if(page == 1)
        	this.crawlIndex.setContributor_page(page);
        else
        	this.crawlIndex.setContributor_page(page-1);
        return contributors;
	}
	
	public List<Contributor> getAllProjectContributors(Project project,int page){
		logger.info(("Searching project all contributors metadata"));
		
		List<Contributor> contributors = new ArrayList<>();
				
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/contributors")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        
        while(jsonArray.size()!=0){
        	
        	for (JsonElement element: jsonArray) {
            	Contributor contributor = gson.fromJson(element, Contributor.class);
            	contributors.add(contributor);
            }
        	
        	page++;
        	
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", project.getUser().getLogin())
  				  .withSimpleParam("/", project.getName())
  				  .withParam("/contributors")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
        if(page == 1)
        	this.crawlIndex.setContributor_page(page);
        else
        	this.crawlIndex.setContributor_page(page-1);
        return contributors;
	}
	
	
	/**
	 * get all UnPublished Releases 
	 * @param owner
	 * @param projectName
	 * @return List<UnPublishedRelease> or null
	 */
	public List<UnPublishedRelease> getAllUnPublishedRelease(String owner,String projectName){
		
		logger.info(("getting " + projectName + " project UnPublishedRelease metadata..."));
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withParam("/tags")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        List<UnPublishedRelease> results = null;
        
        while(jsonArray.size()!=0){
        	results = new ArrayList<UnPublishedRelease>();
        	for (JsonElement element: jsonArray) {
        		UnPublishedRelease upbRelease = gson.fromJson(element, UnPublishedRelease.class);
        		String sha = (element.getAsJsonObject().get("commit").getAsJsonObject().get("sha").getAsString());
        		
        		String commit_url = builder.uses(GithubAPI.ROOT)
      				  .withParam("repos")
    				  .withSimpleParam("/", owner)
    				  .withSimpleParam("/", projectName)
    				  .withParam("/commits")
    				  .withParam("/" + sha)
    				  .build();
        		
        		String date = getCommitDate(commit_url);
        		upbRelease.setCommit_url(commit_url);
        		upbRelease.setDate(date);
        		results.add(upbRelease);
        	}
        	
        	page++;
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", owner)
  				  .withSimpleParam("/", projectName)
  				  .withParam("/tags")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
		if(page == 1)
			this.crawlIndex.setUpbrelease_page(page);
		else
			this.crawlIndex.setUpbrelease_page(page-1);
		return results;
	}
	
	public List<UnPublishedRelease> getAllUnPublishedRelease(String owner,String projectName,int page){
		logger.info(("getting " + projectName + " project UnPublishedRelease metadata..."));
				
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withParam("/tags")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        List<UnPublishedRelease> results = null;
        
        while(jsonArray.size()!=0){
        	results = new ArrayList<UnPublishedRelease>();
        	for (JsonElement element: jsonArray) {
        		UnPublishedRelease upbRelease = gson.fromJson(element, UnPublishedRelease.class);
        		String sha = (element.getAsJsonObject().get("commit").getAsJsonObject().get("sha").getAsString());
        		
        		String commit_url = builder.uses(GithubAPI.ROOT)
      				  .withParam("repos")
    				  .withSimpleParam("/", owner)
    				  .withSimpleParam("/", projectName)
    				  .withParam("/commits")
    				  .withParam("/" + sha)
    				  .build();
        		
        		String date = getCommitDate(commit_url);
        		upbRelease.setCommit_url(commit_url);
        		upbRelease.setDate(date);
        		results.add(upbRelease);
        	}
        	
        	page++;
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", owner)
  				  .withSimpleParam("/", projectName)
  				  .withParam("/tags")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
		if(page == 1)
			this.crawlIndex.setUpbrelease_page(page);
		else
			this.crawlIndex.setUpbrelease_page(page-1);
		return results;
	}
	
	/**
	 * try to get a commit date using URL
	 * @param url
	 * @return String date
	 */
	private String getCommitDate(String url){
		//System.out.println("Getting date for a certain commit...");
		
		String searchUrl = url;
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		
		String date = jsonobject.get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
		date = Dates.dateFormat(date);
		return date;
	}
	
	
	/**
	 * try to get all files of a certain commit
	 * @param owner
	 * @param projectName
	 * @param sha
	 * @return List<CommitFile>
	 */
	public List<CommitFile> getCommitFiles(String owner,String projectName,String sha){
		try{
			//System.out.println("Getting commit files for a certain commit...");
			
			String searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", owner)
					  .withSimpleParam("/", projectName)
					  .withSimpleParam("/", "commits")
					  .withSimpleParam("/",sha)
					  .build();
			
			String jsonLegacy = getWithProtection(searchUrl);
			JsonObject jsonobject = new JsonParser().parse(jsonLegacy).getAsJsonObject();
			JsonArray jsonArray = jsonobject.get("files").getAsJsonArray();
			
			
			
			
			if(jsonArray.size()==0){
				return null;
			}
			
			List<CommitFile> results = new ArrayList<CommitFile>();
			
			for (JsonElement element : jsonArray) {
				CommitFile cmf = new CommitFile();
				
				/**
				 * sometimes the sha is null
				 */
				JsonElement tmpElement= element.getAsJsonObject().get("sha");
				String file_sha = "";
				if(!tmpElement.isJsonNull())
				file_sha = element.getAsJsonObject().get("sha").getAsString();
				
				String filename = element.getAsJsonObject().get("filename").getAsString();
				String status = element.getAsJsonObject().get("status").getAsString();
				int additions = element.getAsJsonObject().get("additions").getAsInt();
				int deletions = element.getAsJsonObject().get("deletions").getAsInt();
				int changes = element.getAsJsonObject().get("changes").getAsInt();
				String contents_url = element.getAsJsonObject().get("contents_url").getAsString();
				
				cmf.setSha(file_sha);
				cmf.setFilename(filename);
				cmf.setStatus(status);
				cmf.setAdditions(additions);
				cmf.setDeletions(deletions);
				cmf.setChanges(changes);
				cmf.setContents_url(contents_url);
				cmf.setCommit_sha(sha);
				
				results.add(cmf);
			}
			
			return results;
			
			
		}catch (Throwable e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
		
	}
	
	public entity.User getUser(String login){
		//System.out.println("Searching " + login + "user's specific metadata");
		
		String searchUrl = builder.uses(GithubAPI.USERS)
				  .withParam(login)
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		entity.User user = gson.fromJson(jsonString, entity.User.class);
		user.setCreated_at(Dates.dateFormat(user.getCreated_at()));
		user.setUpdatedAt(Dates.dateFormat(user.getUpdatedAt()));
		return user;
	}
	
	public List<entity.Comment> getIssueComments(String projectName,String owner,entity.Issue issue){
		logger.info(("Searching " + projectName + " project's comment metadata"));
		
		List<entity.Comment> comments = new ArrayList<entity.Comment>();
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withParam("/issues/" + issue.getNumber())
				  .withParam("/comments")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        
        while(jsonArray.size()!=0){
        	
        	for (JsonElement element: jsonArray) {
        		Comment comment = new Comment();
        		
        		comment.setId(element.getAsJsonObject().get("id").getAsInt());
        		comment.setUrl(element.getAsJsonObject().get("url").getAsString());
        		
        		comment.setUser(element.getAsJsonObject().get("user").getAsJsonObject().get("login").getAsString()
        		);
        		comment.setUser_id(element.getAsJsonObject().get("user").getAsJsonObject().get("id").getAsInt()
                );
        		
        		if(element.getAsJsonObject().get("position").isJsonNull()){
        			comment.setPosition(0);
        		}
        		else{
        			comment.setPosition(element.getAsJsonObject().get("position").getAsInt());
        		}
        		
        		if(element.getAsJsonObject().get("line").isJsonNull()){
        			comment.setLine(0);
        		}
        		else{
        			comment.setLine(element.getAsJsonObject().get("line").getAsInt());
        		}
        		
        		if(element.getAsJsonObject().get("path").isJsonNull()){
        			comment.setPath("");
        		}
        		else{
        			comment.setPath(element.getAsJsonObject().get("path").getAsString());
        		}
     
        		comment.setCommit_id(element.getAsJsonObject().get("commit_id").getAsString());
        		comment.setCreated_at(Dates.dateFormat(element.getAsJsonObject().get("created_at").getAsString()));
        		comment.setUpdated_at(Dates.dateFormat(element.getAsJsonObject().get("updated_at").getAsString()));
        		comment.setBody(element.getAsJsonObject().get("body").getAsString());
        		
            	comments.add(comment);
            }
        	
        	page++;
        	
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", owner)
  				  .withSimpleParam("/", projectName)
  				  .withParam("/issues/" + issue.getNumber())
  				  .withParam("/comments")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
        if(page == 1)
        	this.crawlIndex.setComment_page(page);
        else
        	this.crawlIndex.setComment_page(page-1);
        return comments;
			
	}
	
	public List<entity.Comment> getComments(String projectName,String owner){
		logger.info(("Searching " + projectName + " project's comment metadata"));
		
		List<entity.Comment> comments = new ArrayList<entity.Comment>();
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withParam("/comments")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        
        while(jsonArray.size()!=0){
        	
        	for (JsonElement element: jsonArray) {
        		Comment comment = new Comment();
        		
        		comment.setId(element.getAsJsonObject().get("id").getAsInt());
        		comment.setUrl(element.getAsJsonObject().get("url").getAsString());
        		
        		comment.setUser(element.getAsJsonObject().get("user").getAsJsonObject().get("login").getAsString()
        		);
        		comment.setUser_id(element.getAsJsonObject().get("user").getAsJsonObject().get("id").getAsInt()
                );
        		
        		if(element.getAsJsonObject().get("position").isJsonNull()){
        			comment.setPosition(0);
        		}
        		else{
        			comment.setPosition(element.getAsJsonObject().get("position").getAsInt());
        		}
        		
        		if(element.getAsJsonObject().get("line").isJsonNull()){
        			comment.setLine(0);
        		}
        		else{
        			comment.setLine(element.getAsJsonObject().get("line").getAsInt());
        		}
        		
        		if(element.getAsJsonObject().get("path").isJsonNull()){
        			comment.setPath("");
        		}
        		else{
        			comment.setPath(element.getAsJsonObject().get("path").getAsString());
        		}
     
        		comment.setCommit_id(element.getAsJsonObject().get("commit_id").getAsString());
        		comment.setCreated_at(Dates.dateFormat(element.getAsJsonObject().get("created_at").getAsString()));
        		comment.setUpdated_at(Dates.dateFormat(element.getAsJsonObject().get("updated_at").getAsString()));
        		comment.setBody(element.getAsJsonObject().get("body").getAsString());
        		
            	comments.add(comment);
            }
        	
        	page++;
        	
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", owner)
  				  .withSimpleParam("/", projectName)
  				  .withParam("/comments")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
        if(page == 1)
        	this.crawlIndex.setComment_page(page);
        else
        	this.crawlIndex.setComment_page(page-1);
        return comments;
		
	}
	
	public List<entity.Comment> getComments(String projectName,String owner,int page){
		logger.info(("Searching " + projectName + " project's comment metadata"));
		
		List<entity.Comment> comments = new ArrayList<entity.Comment>();
				
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withParam("/comments")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        
        while(jsonArray.size()!=0){
        	
        	for (JsonElement element: jsonArray) {
        		Comment comment = new Comment();
        		
        		comment.setId(element.getAsJsonObject().get("id").getAsInt());
        		comment.setUrl(element.getAsJsonObject().get("url").getAsString());
        		
        		comment.setUser(element.getAsJsonObject().get("user").getAsJsonObject().get("login").getAsString()
        		);
        		comment.setUser_id(element.getAsJsonObject().get("user").getAsJsonObject().get("id").getAsInt()
                );
        		
        		if(element.getAsJsonObject().get("position").isJsonNull()){
        			comment.setPosition(0);
        		}
        		else{
        			comment.setPosition(element.getAsJsonObject().get("position").getAsInt());
        		}
        		
        		if(element.getAsJsonObject().get("line").isJsonNull()){
        			comment.setLine(0);
        		}
        		else{
        			comment.setLine(element.getAsJsonObject().get("line").getAsInt());
        		}
        		
        		if(element.getAsJsonObject().get("path").isJsonNull()){
        			comment.setPath("");
        		}
        		else{
        			comment.setPath(element.getAsJsonObject().get("path").getAsString());
        		}
     
        		comment.setCommit_id(element.getAsJsonObject().get("commit_id").getAsString());
        		comment.setCreated_at(Dates.dateFormat(element.getAsJsonObject().get("created_at").getAsString()));
        		comment.setUpdated_at(Dates.dateFormat(element.getAsJsonObject().get("updated_at").getAsString()));
        		comment.setBody(element.getAsJsonObject().get("body").getAsString());
        		
            	comments.add(comment);
            }
        	
        	page++;
        	
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", owner)
  				  .withSimpleParam("/", projectName)
  				  .withParam("/comments")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
        if(page == 1)
        	this.crawlIndex.setComment_page(page);
        else
        	this.crawlIndex.setComment_page(page-1);
		return comments;
		
		
	}
	
	/**
	 * Fetches all the Releases of the given {@link Project} from the GitHub API
	 * 
	 * @param project the @{link Project} of which the Releases are about
	 * @return a {@link List} of {@link Release} objects
	 */
	public List<Release> getAllProjectReleases(Project project) {

		logger.info(("Searching " + project.getName() +  " project releases metadata"));
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/releases")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		if(jsonArray.size() == 0){
			return null;
		}
		
		List<Release> releases = new ArrayList<>();
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Release release = gson.fromJson(element, Release.class);
				release.setProject(project);	
				releases.add(release);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getUser().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/releases")
					  .withParam("?page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		}
		if(page == 1)
			this.crawlIndex.setRelease_page(page);
		else
			this.crawlIndex.setRelease_page(page-1);
		return releases;
	
	}
	
	/**
	 * with the page param
	 * @param project
	 * @param page
	 * @return
	 */
	public List<Release> getAllProjectReleases(Project project,int page) {
		logger.info(("Searching " + project.getName() +  " project releases metadata"));
				
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/releases")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		if(jsonArray.size() == 0){
			return null;
		}
		
		List<Release> releases = new ArrayList<>();
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Release release = gson.fromJson(element, Release.class);
				release.setProject(project);	
				releases.add(release);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getUser().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/releases")
					  .withParam("?page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		}
		if(page == 1)
			this.crawlIndex.setRelease_page(page);
		else
			this.crawlIndex.setRelease_page(page-1);
		return releases;
	}
	
	
	private String getWithProtection(String url){
		String data = requests.get(url);

		if (data.contains("API rate limit exceeded for")) {
			try {
				Thread.sleep(1000 * 60 * 60);
				data = requests.get(url);

			} catch (InterruptedException ex) {
				ex.printStackTrace();
			}
		}

		return data;
	}
	
	public static int getINFINITY() {
		return INFINITY;
	}


	public static void setINFINITY(int iNFINITY) {
		INFINITY = iNFINITY;
	}


	public Crawlindex getCrawlIndex() {
		return crawlIndex;
	}


	public void setCrawlIndex(Crawlindex crawlIndex) {
		this.crawlIndex = crawlIndex;
	}


	public Gson getGson() {
		return gson;
	}


	public Requests getRequests() {
		return requests;
	}


	public UrlBuilder getBuilder() {
		return builder;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\SearchException.java
package search;

import entity.GroundhogException;


/**
 * Thrown when something nasty happens
 * 
 * 
 */
public class SearchException extends GroundhogException {
	private static final long serialVersionUID = 1L;

	public SearchException(Throwable e) {
		super(e);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\SearchGitHub.java
package search;


import http.HttpModule;
import http.Requests;
import http.URLsDecoder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import search.UrlBuilder.GithubAPI;
import usefuldata.Developer;
import usefuldata.ProjectContribution;
import usefuldata.Vitality;
import util.Dates;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.inject.Guice;
import com.google.inject.Inject;

import entity.Commit;
import entity.Contributor;
import entity.GroundhogException;
import entity.Issue;
import entity.IssueLabel;
import entity.Language;
import entity.Milestone;
import entity.Project;
import entity.Release;
import entity.User;

/**
 * Performs the project search on GitHub, via its official JSON API
 * 
 * 
 */
public class SearchGitHub implements ForgeSearch {
	
	public static int INFINITY = -1;

	private final Gson gson;
	private final Requests requests;
	private final UrlBuilder builder;

	@Inject
	public SearchGitHub(Requests requests) {
		this.requests = requests;
		this.gson = new Gson();
		this.builder = Guice.createInjector(new HttpModule()).getInstance(UrlBuilder.class);
	}

	public List<Project> getProjects(String term, int page, int limit) throws SearchException {
		System.out.println("Searching project metadata");
		try {
			if (term == null) {
				return getAllForgeProjects(page, limit);
			}

			String searchUrl = builder.uses(GithubAPI.LEGACY_V2)
					  .withParam(URLsDecoder.encodeURL(term)
)
					  .withParam("start_page", page)
					  .withParam("language", "java")
					  .build();

			System.out.println(searchUrl);
			
			String json = requests.get(searchUrl);
			JsonObject jsonObject = gson.fromJson(json, JsonElement.class).getAsJsonObject();			
			JsonArray jsonArray = jsonObject.get("repositories").getAsJsonArray();

			List<Project> projects = new ArrayList<>();
			for (int i = 0; i < jsonArray.size() && (i < limit || limit < 0); i++) {
				String element = jsonArray.get(i).toString();

				Project p = gson.fromJson(element, Project.class);

				String owner = jsonArray.get(i).getAsJsonObject().get("owner").getAsString();
				p.setCheckoutURL(String.format("https://github.com/%s/%s.git", owner, p.getName()));

				String userUrl = builder.uses(GithubAPI.USERS).withParam(owner).build();
				String userJson = requests.get(userUrl);
				User user = gson.fromJson(userJson, User.class);

				p.setOwner(user);
				projects.add(p);
			}

			return projects;

		} catch (GroundhogException e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
	}

	
	
	/**
	 * Obtains from the GitHub API the set of projects with more than one language
	 * 
	 * @param Start indicates the desired page
	 * @param limit the total of projects that will be returned
	 * @throws SearchException
	 */
	
	public List<Project> getProjectsWithMoreThanOneLanguage(int limit) throws SearchException {
		
		try {
			
			System.out.println("Searching project with more than one language metadata");
			
			List<Project> rawData = getAllProjects(0, limit);

			List<Project> projects = new ArrayList<>();
			for (Project project : rawData) {
				List<Language> languages = getProjectLanguages(project);

				if (languages.size() > 1) {
					projects.add(project);
				}
			}

			return projects;

		} catch (GroundhogException e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
	}
	
	
	
	/**
	 * Obtains from the GitHub API the set of projects within a specific
	 * language
	 * 
	 * @param lang the specific language
	 */
	
	public List<Project> getAllProjectsByLanguage(String lang) throws SearchException {

		
		System.out.println("Searching all project by language metadata");
		
		String searchUrl = builder.uses(GithubAPI.LEGACY_V2).withSimpleParam("language=", lang).build();
		String json = requests.get(searchUrl);

		JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();
		JsonArray jsonArray= jsonObject.get("repositories").getAsJsonArray();

		List<Project> projects = new ArrayList<>();
		for (JsonElement element : jsonArray) {
			Project p = gson.fromJson(element, Project.class);
			String owner = element.getAsJsonObject().get("owner").getAsString();
			p.setUser(new User(owner));
			projects.add(p);
		}

		return projects;
	}
	
	
	/**
	 * Obtains from the GitHub API the set of projects
	 * 
	 * @param Start indicates the desired page
	 * @param limit is the total of projects that are going to me returned 
	 * @throws SearchException
	 */
	public List<Project> getAllProjects(int start, int limit) throws SearchException {

		try {

			int since = start;
			int totalRepositories = 0;

			List<Project> projects = new ArrayList<>();
			JsonParser parser = new JsonParser();
			while(totalRepositories < limit || limit < 0){

				String searchUrl = builder.uses(GithubAPI.REPOSITORIES)
										  .withParam("language", "java")
										  .withParam("since", since)
										  .build();
				
				String response = getWithProtection(searchUrl);
				JsonArray jsonArray = parser.parse(response).getAsJsonArray();

				int counter = 0;

				for (Iterator<JsonElement> iterator = jsonArray.iterator(); (iterator
						.hasNext() && (totalRepositories + counter < limit || limit < 0));) {

					JsonElement element = (JsonElement) iterator.next();

					String repoName = element.getAsJsonObject().get("name").getAsString();	
					String searchUrlLegacy = builder.uses(GithubAPI.LEGACY_V2).withParam(repoName).build();
					
					String jsonLegacy = getWithProtection(searchUrlLegacy);
					JsonElement jsonElement = parser.parse(jsonLegacy);
					JsonObject jsonObject = jsonElement.getAsJsonObject();
					JsonArray jsonArrayLegacy = jsonObject.get("repositories").getAsJsonArray();

					if(jsonArrayLegacy.size() > 0) {
						JsonObject rawJsonObject = jsonArrayLegacy.get(0).getAsJsonObject();

						String stringElement = rawJsonObject.toString();
						Project p = gson.fromJson(stringElement, Project.class);

						String owner = rawJsonObject.getAsJsonObject().get("owner").getAsString();
						p.setCheckoutURL(String.format("https://github.com/%s/%s.git", owner, p.getName()));
						p.setOwner(new User(owner));

						projects.add(p);

						counter++;
						totalRepositories++;
					}
				}

				JsonElement lastPagesRepository = jsonArray.get(jsonArray.size() -1);
				since = lastPagesRepository.getAsJsonObject().get("id").getAsInt();
			}
			return projects;

		} catch (Exception e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
	}

	/**
	 * get a certain project
	 * @param projectName
	 * @param username
	 * @return
	 * @throws SearchException
	 */
	public usefuldata.Project getProject(String projectName, String username) throws SearchException{
		try {
			System.out.println("Searching project metadata by term");
			
			
			String searchUrl = builder.uses(GithubAPI.SEARCH)
					  .withParam(projectName + "+user:" + username)
					  .withParam("sort", "stars")
					  .withParam("order", "desc")
					  .build();

			//System.out.println(searchUrl);
			
			String json = requests.get(searchUrl);
			
			JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();
			JsonArray jsonArray= jsonObject.get("items").getAsJsonArray();

			usefuldata.Project p = null;
			for (JsonElement element : jsonArray) {
				usefuldata.Project tmp = gson.fromJson(element, usefuldata.Project.class);
				if(tmp!=null){
					tmp.setOwner(element.getAsJsonObject().get("owner").getAsJsonObject().get("login").getAsString());
					
					if(tmp.getName()!=null && tmp.getOwner()!=null){
						p = tmp;
						break;
					}
				}
			}
			return p;
		} catch (Throwable e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
	}
	
	
	
	@Override
	public List<Project> getProjects(String term, String username, int page) throws SearchException {
		try {
			
			System.out.println("Searching project metadata by term");
			
			List<Project> projects = new ArrayList<>();
			
			String searchUrl = builder.uses(GithubAPI.LEGACY_V2)
					  .withParam(URLsDecoder.encodeURL(term))
					  .withParam("start_page", page)
					  .withParam("language", "java")
					  .build();

			//System.out.println(searchUrl);
			
			String jsonLegacy = getWithProtection(searchUrl);
			JsonElement jsonElement = new JsonParser().parse(jsonLegacy);
			
			JsonObject jsonObject = jsonElement.getAsJsonObject();
			JsonArray jsonArray = jsonObject.get("repositories").getAsJsonArray();
			
			for (JsonElement j: jsonArray) {
				Project p = gson.fromJson(j, Project.class);
				JsonObject jsonObj = j.getAsJsonObject();	
				
				p.setCheckoutURL(String.format("git@github.com:%s/%s.git", username, p.getName()));
				User u = new User(jsonObj.get("owner").getAsString());
				p.setUser(u);
				
				projects.add(p);
			}

			return projects;
		} catch (Throwable e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
	}
	

	/**
	 * Obtains from the GitHub API the set of languages that compose a
	 * {@link Project}
	 * 
	 * @param project
	 *            a {@link Project} object to have its languages fetched
	 */
	
	public List<Language> getProjectLanguages(Project project) {

	  String searchUrl = builder.uses(GithubAPI.ROOT)
			  .withParam("repos")
			  .withSimpleParam("/", project.getUser().getLogin())
			  .withSimpleParam("/", project.getName())
			  .withParam("/languages")
			  .build();

		String json = requests.get(searchUrl).replace("{", "").replace("}", "");

		List<Language> languages = new ArrayList<>();
		if(!json.equalsIgnoreCase("{}")){
			for (String str: json.split(",")) {
				String[] hash = str.split(":");
				String key = hash[0].trim().replaceAll("\"", "");
				Integer value = Integer.parseInt(hash[1].trim());
				Language lang = new Language(key, value);
				languages.add(lang);
			}
		}

		return languages;
	}
	

	/**
	 * Fetches all the Issues of the given {@link Project} from the GitHub API
	 * 
	 * @param project the @{link Project} of which the Issues are about
	 * @return a {@link List} of {@link Issues} objects
	 */
	
	public List<Issue> getAllProjectIssues(Project project) {

		System.out.println("Searching project issues metadata");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner())
				  .withSimpleParam("/", project.getName())
				  .withParam("/issues")
				  .build();
				
		String jsonString = requests.get(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		List<Issue> issues = new ArrayList<Issue>();
		List<IssueLabel> labels = new ArrayList<IssueLabel>();
		
		for (JsonElement element : jsonArray) {
			Issue issue = gson.fromJson(element, Issue.class);
			issue.setProject(project);
			
			for (JsonElement lab : element.getAsJsonObject().get("labels").getAsJsonArray()) {
				IssueLabel label = gson.fromJson(lab, IssueLabel.class);				
				labels.add(label);
			}
			
			issue.setLabels(labels);
			issues.add(issue);
		}

		return issues;
	}
	
	
	/**
	 * Fetches all the Milestones of the given {@link Project} from the GitHub API
	 * @param project the @{link Project} of which the Milestones are about
	 * @return a {@link List} of {@link Milestone} objects
	 */
	
	public List<Milestone> getAllProjectMilestones(Project project) {
		
		System.out.println("Searching project milestones metadata");
		
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/milestones")
				  .build();
		
		String jsonString = requests.get(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		List<Milestone> milestones = new ArrayList<>();
		
		for (JsonElement element : jsonArray) {
			Milestone milestone = gson.fromJson(element, Milestone.class);
			milestone.setProject(project);
			
			milestones.add(milestone);
		}

		return milestones;
	}
	
	
	/**
	 * Fetches all the Tags of the given {@link Project} from the GitHub API
	 * @param project the @{link Project} of which the Milestones are about
	 * @return a the size of the {@link List} of {@link Tags} objects
	 */
	public int getNumberProjectTags(Project project) {

		System.out.println("Searching project tags metadata");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/git/refs/tags")
				  .build();

		String jsonString = getWithProtection(searchUrl);

		int retorno = 0;
		
		if(!jsonString.contains("Not Found") && !jsonString.contains("Git Repository is empty.")){

			try {
				JsonElement element =gson.fromJson(jsonString, JsonElement.class);
				
				if(element.isJsonArray()){
					
					JsonArray jsonArray = element.getAsJsonArray();
					
					retorno = jsonArray.size();
				}
			} catch (Exception e) {
				e.printStackTrace();
				throw new GroundhogException(jsonString);
			}	
		}
		
		return retorno;
	}

	/**
	 * Fetches all the Commits of the given {@link Project} from the GitHub API
	 * @param project the @{link Project} to which the commits belong
	 * @return a {@link List} of {@link Commit} objects
	 */
	public List<Commit> getAllProjectCommits(Project project) {
		System.out.println("Searching project commits metadata");
		
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/commits?page=" +page +"&per_page=80")
				  .build();
		
		System.out.println(searchUrl);
			
		JsonElement jsonElement = gson.fromJson(requests.get(searchUrl), JsonElement.class);
					
		JsonArray jsonArray = jsonElement.getAsJsonArray();

		List<Commit> commits = new ArrayList<>();
		
		//int crawled_index = 0;
		
		while(jsonArray.size()!=0){
		
		for (JsonElement element : jsonArray) {
			//crawled_index++;
			
			
			Commit commit = gson.fromJson(element, Commit.class);
			commit.setProject(project);
			
			User user = gson.fromJson(element.getAsJsonObject().get("committer"), User.class);
			commit.setCommiter(user);
			
			commit.setMessage(element.getAsJsonObject().get("commit").getAsJsonObject().get("message").getAsString());

			String date = element.getAsJsonObject().get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
			commit.setCommitDate(date);
			
			String sha = element.getAsJsonObject().get("sha").getAsString();
			commit.setSha(sha);
			
			
			String anotherUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/commits")
					  .withParam("/" + sha)
					  .build();
			
			int add = 0;
			int del = 0;
			JsonElement ano_jsonElement = gson.fromJson(requests.get(anotherUrl), JsonElement.class);
			JsonArray ano_jsonArray = ano_jsonElement.getAsJsonObject().get("files").getAsJsonArray();
			for(JsonElement e:ano_jsonArray){
				int adi = e.getAsJsonObject().get("additions").getAsInt();
				int dei = e.getAsJsonObject().get("deletions").getAsInt();
				add += adi;
				del += dei;
			}
			commit.setAdditionsCount(add);
			commit.setDeletionsCount(del);
						
			commits.add(commit);
		}
		
		page++;
		searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/commits?page=" +page +"&per_page=80")
				  .build();
		
		System.out.println(searchUrl);
		
		jsonElement = gson.fromJson(requests.get(searchUrl), JsonElement.class);
		jsonArray = jsonElement.getAsJsonArray();
		
		}

		//System.out.println("finally at " + crawled_index);
		return commits;
	}


		
	/**
	 * Fetches all the Commits of the given {@link Project} from the GitHub API
	 * @param project the @{link Project} to which the commits belong
	 * @return a {@link List} of {@link Commit} objects
	 */
	public List<Commit> getAllProjectCommitsByDate(Project project, String start, String end) {

		System.out.println("Searching all project commits metadata by date");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withSimpleParam("/", "commits")
				  .withParam("since", start)
				  .withParam("until", end)
				  .build();
		
		String response = getWithProtection(searchUrl);

		JsonElement jsonElement = gson.fromJson(response, JsonElement.class);
		JsonArray jsonArray = jsonElement.getAsJsonArray();

		List<Commit> commits = new ArrayList<>();
		for (JsonElement element : jsonArray) {
			Commit commit = gson.fromJson(element, Commit.class);
			commit.setProject(project);

			String date = element.getAsJsonObject().get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
			commit.setCommitDate(date);
			commits.add(commit);
		}

		return commits;
	}

	/**
	 * 
	 * <p>Fetches all the contributors of the given {@link Project} from the GitHub API</p>
	 * <p>modified by guanjun</p>
	 * @see <p>We can map all {@link Contributor} into a {@link User} by {@link Contributor#getUrl} method that return is the same for a Contributor and his correspondent User ({@link User#getUrl})</p>
	 * @param project the @{link Project} to get the contributors from
	 * @return a {@link List} of {@link Contributor} objects
	 */
	public List<Contributor> getAllProjectContributors(Project project) {
		
		System.out.println("Searching project contributors metadata");
		
		List<Contributor> contributors = new ArrayList<>();
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/contributors")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
        JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
        
        if(jsonArray.size() == 0){
			return null;
		}
        
        
        while(jsonArray.size()!=0){
        	
        	for (JsonElement element: jsonArray) {
            	Contributor contributor = gson.fromJson(element, Contributor.class);
            	contributors.add(contributor);
            }
        	
        	page++;
        	
        	searchUrl = builder.uses(GithubAPI.ROOT)
  				  .withParam("repos")
  				  .withSimpleParam("/", project.getUser().getLogin())
  				  .withSimpleParam("/", project.getName())
  				  .withParam("/contributors")
  				  .withParam("?page=" + page + "&per_page=80")
  				  .build();
        	
        	jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

        }
        
        
		

		return contributors;
	}

	public List<Project> getAllForgeProjects(int start, int limit) throws SearchException{
		try{
			
			System.out.println("Searching all projects metadata");
			
			int since = start;
			int totalRepositories = 0;
			List<Project> projects = new ArrayList<>();
			
			while (totalRepositories < limit || limit < 0) {

				String searchUrl = builder.uses(GithubAPI.REPOSITORIES)
										  .withParam("since", since)
										  .withParam("language", "java")
										  .build();
				
				String jsonString = requests.get(searchUrl);
				JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
				for (int i = 0; i < jsonArray.size() && 
						(totalRepositories + i < limit || limit < 0); i++) {

					String repoName = jsonArray.get(i).getAsJsonObject().get("name").getAsString();					
					String searchUrlLegacy = builder.uses(GithubAPI.LEGACY_V2)
													  .withParam(repoName)
													  .withParam("language", "java")
													  .build();
					
					String jsonLegacy = requests.get(searchUrlLegacy);

					JsonObject jsonObject = gson.fromJson(jsonLegacy, JsonElement.class).getAsJsonObject();			
					JsonArray jsonArrayLegacy = jsonObject.get("repositories").getAsJsonArray();

					if (jsonArrayLegacy.size() > 0) {
						JsonObject rawJsonObject = jsonArrayLegacy.get(0).getAsJsonObject();
						String stringElement = rawJsonObject.toString(); // verify here
						
						Project p = gson.fromJson(stringElement, Project.class);

						String owner = rawJsonObject.getAsJsonObject().get("owner").getAsString();
						p.setCheckoutURL(String.format("https://github.com/%s/%s.git", owner, p.getName()));

						projects.add(p);
						totalRepositories++;
					}
				}
				
				JsonElement lastPagesRepository = jsonArray.get(jsonArray.size() -1);
				since = lastPagesRepository.getAsJsonObject().get("id").getAsInt();
			}
			return projects;
		} catch (GroundhogException e) {
			e.printStackTrace();
			throw new SearchException(e);
		}
	}
	
	/**
	 * Gets the top most Used languages among the projects considering the most used language
	 * in each project. 
	 * @param projects List of projects into consideration
	 * @param limit Limits the size of the returning list
	 * @return sorted list with the top most used languages
	 */
	public List<Language> getTopMostUsedLanguages(List<Project> projects, int limit){
		List<Language> topLanguages = new ArrayList<>();
		Map<String, Integer> languages = new HashMap<>(); 
		for (Project project: projects) {			
			String language = project.getLanguage();
			Integer count = 1;
			
			if (languages.containsKey(language)){ 
				count += languages.get(language);
			}						   
			
			languages.put(language, count);

		}
		for (Entry<String, Integer> language : languages.entrySet()) {
			topLanguages.add(new Language(language.getKey(), language.getValue()));
		}

		Collections.sort(topLanguages);
		if(limit < 0) limit = 0;
		
		topLanguages = topLanguages.subList(0, Math.min(limit, topLanguages.size()));
		return topLanguages;		
	}


	/**
	 * Gets the top most used languages among the projects according to the number 
	 * of LOC (lines of code) that they appear. 
	 * @param projects {@link List} of projects into consideration
	 * @param limit for limiting (upper bound) the size of the returning list
	 * @return sorted list with the top most used languages
	 */
	public List<Language> getTopMostUsedLanguagesLoc(List<Project> projects, int limit){
		List<Language> topLanguages = new ArrayList<>();
		Map<String, Integer> languages = new HashMap<>(); 
		
		for (Project project: projects){
			if (project.getLanguages() == null) {
				throw new GroundhogException("languages information required");
			}
			
			for (Language language : project.getLanguages()) {
				Integer newLoc = language.getByteCount();
				
				if (languages.containsKey(language.getName())) {
					newLoc += languages.get(language.getName());
				}
				
				languages.put(language.getName(), newLoc);
			}
		}
		
		for (Entry<String, Integer> language : languages.entrySet()) {
			topLanguages.add(new Language(language.getKey(), language.getValue()));
		}

		Collections.sort(topLanguages);
		if (limit < 0 ) limit = 0;
		
		topLanguages = topLanguages.subList(0, Math.min(limit, topLanguages.size()));
		return topLanguages;	
	}
	
	/**
	 * Fetches all the Releases of the given {@link Project} from the GitHub API
	 * 
	 * @param project the @{link Project} of which the Releases are about
	 * @return a {@link List} of {@link Release} objects
	 */
	public List<Release> getAllProjectReleases(Project project) {

		System.out.println("Searching project releases metadata");
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getUser().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withParam("/releases")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		if(jsonArray.size() == 0){
			return null;
		}
		
		List<Release> releases = new ArrayList<>();
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				Release release = gson.fromJson(element, Release.class);
				release.setProject(project);	
				releases.add(release);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getUser().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withParam("/releases")
					  .withParam("?page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
            jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		}
		
		return releases;
	
	}

	/**
	 * get a ceratin developer
	 * @param login
	 * @return
	 */
	public usefuldata.Developer getDeveloper(String login){
		System.out.println("Searching " +login +  "'s metadata");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("users")
				  .withSimpleParam("/", login)
				  .build();
		
		//System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		usefuldata.Developer dp = gson.fromJson(jsonobject, usefuldata.Developer.class);

		return dp;
	}
	
	/**
	 * get developers involved in a certain project
	 * @param project
	 * @return
	 */
	public List<Developer> getDevelopers(Project project){
		System.out.println("Searching all developers metadata");
		
		List<Contributor> list = getAllProjectContributors(project);
		
		List<Developer> result = new ArrayList<Developer>();
		
		for(Contributor a:list){
			Developer dp = getDeveloper(a.getLogin());
			result.add(dp);
		}
		
		return result;
	}
	
		
	
	/**
	 * get all releases url of a certain project 
	 * @param owner
	 * @param projectName
	 * @return
	 */
	public Map<String,String> getReleaseUrls(String owner,String projectName){
		System.out.println("Getting prepared for release downloading...");
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "tags")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();

		if(jsonArray.size() == 0){
			return null;
		}
		
		
		Map<String,String> urls = new HashMap<>();
		String name =null;
		String url = null;
		
		while(jsonArray.size()!=0){
			for (JsonElement element : jsonArray) {
				name = element.getAsJsonObject().get("name").getAsString();
				url = element.getAsJsonObject().get("zipball_url").getAsString();
				if(name!=null && url!=null)
				urls.put(name,url);
			}
			
			page++;			
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", owner)
					  .withSimpleParam("/", projectName)
					  .withSimpleParam("/", "tags")
					  .withParam("?page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
			jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
			
		}
		
		

		System.out.println("Urls fetching completed....");
		return urls;
	}
	
	/**
	 * get a developer's contribution to a certain project
	 * @param owner
	 * @param projectName
	 * @param developer
	 * @param project_id
	 * @return
	 */
	public ProjectContribution getAllProjectContribution(String owner,String projectName,String developer
			,int project_id){
		
		System.out.println("Now fetching all shas for commits...");
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "commits")
				  .withParam("?author=" + developer + "&page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
		if(jsonArray.size() == 0){
			return null;
		}
		
		JsonElement j1 = jsonArray.get(0);
		
		int developer_id = j1.getAsJsonObject().get("author").getAsJsonObject().get("id").getAsInt();
		int contributions = 0;
		
		while(jsonArray.size()!=0){
	
			for (JsonElement element : jsonArray) {
				String sha = element.getAsJsonObject().get("sha").getAsString();
				contributions += getContribution(owner,projectName,sha);
				
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", owner)
					  .withSimpleParam("/", projectName)
					  .withSimpleParam("/", "commits")
					  .withParam("?author=" + developer + "&page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
			jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
			
			
		}
		
		ProjectContribution pct = new ProjectContribution();
		pct.setProject_id(project_id);
		pct.setDeveloper_id(developer_id);
		pct.setContributions(contributions);
		
		return pct;
	}
	
	
	
	/**
	 * this method tries to fetch map(release,date)
	 * @return
	 */
	public Map<String,String> getReleaseDate(String owner,String projectName){
		System.out.println("trying to get release date...");
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "tags")
				  .withParam("?page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
		
		if(jsonArray.size() == 0){
			return null;
		}
		
		Map<String,String> results = new HashMap<String,String>();
		
		while(jsonArray.size()!=0){
			
			for(JsonElement element : jsonArray){
				String tag_name = element.getAsJsonObject().get("name").getAsString();
				String sha = element.getAsJsonObject().get("commit").getAsJsonObject().get("sha").getAsString();
				
				String url = builder.uses(GithubAPI.ROOT)
						  .withParam("repos")
						  .withSimpleParam("/", owner)
						  .withSimpleParam("/", projectName)
						  .withSimpleParam("/", "commits")
						  .withSimpleParam("/",sha)
						  .build();
				
				String date = getDateWithUrl(url);
				results.put(tag_name, date);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", owner)
					  .withSimpleParam("/", projectName)
					  .withSimpleParam("/", "tags")
					  .withParam("?page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
			jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
			
		}
		
		return results;
	}
	
	
	/**
	 * get a developer's contribution to a certain project
	 * separated by different releases
	 * @param dateMap
	 * @param project
	 * @param developer
	 * @return Map<releaseName,contributions>
	 */
	public Map<String,Integer> getReleaseContribution(Map<String,String> dateMap,Project project,String developer){
		System.out.println("trying to get release contributions...");
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withSimpleParam("/", "commits")
				  .withParam("?author=" + developer + "&page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
		if(jsonArray.size() == 0){
			return null;
		}
				
		/**
		 * initialize result map,with <release_name,0>
		 */
		
		Map<String,Integer> results = new HashMap<String,Integer>();
		Set<String> tmp_key = dateMap.keySet();
		for(String tmp_name:tmp_key){
			results.put(tmp_name, 0);
		}
		
		
		while(jsonArray.size()!=0){
	
			for (JsonElement element : jsonArray) {
				
				String sha = element.getAsJsonObject().get("sha").getAsString();
				//<date,contributions>
				Map<String,Integer> date_cont = getReleaseContribution(project,sha);
				Set<String> date_set = date_cont.keySet();
				
				int position = 0;
				ArrayList<String> sorted_release = Dates.dateSort(dateMap);
				
				for(String specific_date:date_set){
					 position = Dates.getDateIndex(specific_date,dateMap);
					 
					 if(position >= sorted_release.size())
						 position = sorted_release.size() - 1;
					 
					 results.replace(sorted_release.get(position), date_cont.get(specific_date) +results.get(sorted_release.get(position)));
				}
				
				
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withSimpleParam("/", "commits")
					  .withParam("?author=" + developer + "&page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
			jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
			
			
		}
		
		return results;
	}
	
	
	public List<Vitality> getVitality(Project project,String developer){	
		System.out.println("trying to get " +developer +  "'s vitalities...");
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withSimpleParam("/", "commits")
				  .withParam("?author=" + developer + "&page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
		if(jsonArray.size() == 0){
			return null;
		}
		
		
		/**
		 * initialize result map,with <release_name,0> (0 should be vitality)
		 */
		
		List<Vitality> results = new ArrayList<Vitality>();
		
		while(jsonArray.size()!=0){
			
			for (JsonElement element : jsonArray) {
				String sha = element.getAsJsonObject().get("sha").getAsString();
				String date = getCommitDate(project.getOwner().getLogin(),project.getName(),sha);
				
				boolean isEnd = false;
				for(int i = 0;i<results.size();i++){
					if(results.get(i).getDate().equals(date)){
						results.get(i).setVitality(results.get(i).getVitality() + 1);
						isEnd = true;
						break;
					}
				}
				if(isEnd == false){
					Vitality tmp_vi = new Vitality();
					tmp_vi.setVitality(1);
					tmp_vi.setDate(date);
					results.add(tmp_vi);
				}
				
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", project.getOwner().getLogin())
					  .withSimpleParam("/", project.getName())
					  .withSimpleParam("/", "commits")
					  .withParam("?author=" + developer + "&page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
			jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
			
			
		}
		
		return results;
	}
	
	public ArrayList<String> getFiles(Map<String,String> dateMap,String developerName,String owner,String projectName,
			String releaseName){
		
		System.out.println("trying to get " +developerName +  "'s changed files...");
		
		ArrayList<String> results = new ArrayList<String>();
		ArrayList<String> sorted_tag = Dates.dateSort(dateMap);
		int position = 0;
		for(int i =0;i<sorted_tag.size();i++){
			if(releaseName.equals(sorted_tag.get(i))){
				position = i;
			}
		}
		
		int page = 1;
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "commits")
				  .withParam("?author=" + developerName + "&page=" + page + "&per_page=80")
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonArray jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
		if(jsonArray.size() == 0){
			return null;
		}
		
		while(jsonArray.size()!=0){
			
			for (JsonElement element : jsonArray) {
				String sha = element.getAsJsonObject().get("sha").getAsString();
				addFiles(position,dateMap,results,owner,projectName,sha);
			}
			
			page++;
			searchUrl = builder.uses(GithubAPI.ROOT)
					  .withParam("repos")
					  .withSimpleParam("/", owner)
					  .withSimpleParam("/", projectName)
					  .withSimpleParam("/", "commits")
					  .withParam("?author=" + developerName + "&page=" + page + "&per_page=80")
					  .build();
			
			jsonString = requests.getWithPreviewHeader(searchUrl);
			jsonArray = gson.fromJson(jsonString, JsonElement.class).getAsJsonArray();
				
		}
		
		return results;
	}
	
	private void addFiles(int position,Map<String,String> dateMap,ArrayList<String> files,String owner,String projectName,String sha){
		System.out.println("Getting files for a certain commit...");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "commits")
				  .withSimpleParam("/",sha)
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		
		String date = jsonobject.get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
		date = Dates.dateFormat(date);
		
		int index = Dates.getDateIndex(date,dateMap);
		if(index >= dateMap.size())
			index = dateMap.size() - 1;
		 
		if(index == position){
			JsonArray jsonArray = jsonobject.get("files").getAsJsonArray();
			
			for (JsonElement element : jsonArray) {
				String filename = element.getAsJsonObject().get("filename").getAsString();
				files.add(filename);	
			}
		}
		
		
		
		
	}
	
	private Map<String,Integer> getReleaseContribution(Project project,String sha){
		System.out.println("Getting contributions for a certain commit...");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", project.getOwner().getLogin())
				  .withSimpleParam("/", project.getName())
				  .withSimpleParam("/", "commits")
				  .withSimpleParam("/",sha)
				  .build();
		
		System.out.println(searchUrl);
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		
		String date = jsonobject.get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
		int contributions = jsonobject.get("stats").getAsJsonObject().get("total").getAsInt();
		
		Map<String,Integer> result = new HashMap<String,Integer>();
		result.put(date, contributions);
		
		
		return result;
	}
	
	
	
	/**
	 * this method is used by getReleaseDate(String owner,String projectName)
	 * @param url
	 * @return
	 */
	private String getDateWithUrl(String url){
		System.out.println("trying to fetch the url...");
		
		String jsonString = requests.getWithPreviewHeader(url);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		
		
		//System.out.println(url);
		String date = jsonobject.get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
		
		return date;
	}
	
	/**
	 * get contribution using specific sha
	 * @param owner
	 * @param projectName
	 * @param sha
	 * @return
	 */
	private int getContribution(String owner,String projectName,String sha){
		
		System.out.println("Getting contributions for a certain commit...");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "commits")
				  .withSimpleParam("/",sha)
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		
		int contributions = jsonobject.get("stats").getAsJsonObject().get("total").getAsInt();
		
		return contributions;
	}
	
	private String getCommitDate(String owner,String projectName,String sha){
		System.out.println("Getting date for a certain commit...");
		
		String searchUrl = builder.uses(GithubAPI.ROOT)
				  .withParam("repos")
				  .withSimpleParam("/", owner)
				  .withSimpleParam("/", projectName)
				  .withSimpleParam("/", "commits")
				  .withSimpleParam("/",sha)
				  .build();
		
		String jsonString = requests.getWithPreviewHeader(searchUrl);
		JsonObject jsonobject = gson.fromJson(jsonString, JsonElement.class).getAsJsonObject();
		
		String date = jsonobject.get("commit").getAsJsonObject().get("author").getAsJsonObject().get("date").getAsString();
		date = Dates.dateFormat(date);
		return date;
	}
	
	private String getWithProtection(String url){
		String data = requests.get(url);

		if (data.contains("API rate limit exceeded for")) {
			try {
				Thread.sleep(1000 * 60 * 60);
				data = requests.get(url);

			} catch (InterruptedException ex) {
				ex.printStackTrace();
			}
		}

		return data;
	}
	
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\SearchModule.java
package search;

import com.google.inject.AbstractModule;
import com.google.inject.Singleton;

public class SearchModule extends AbstractModule {

	@Override
	protected void configure() {
		bind(SearchGitHub.class).in(Singleton.class);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\search\UrlBuilder.java
package search;

import java.util.Map;


import com.google.inject.Inject;
import com.google.inject.name.Named;

/**
 * Use this class when you need to create a github url, instead doing so by
 * string concatenation.
 * 
 * 
 */
public final class UrlBuilder {

	/**
	 * Root sources of the API
	 * 
	 * 
	 */
	enum GithubAPI {
		LEGACY_V2 {
			@Override
			public String baseForm() {
				return String.format("%slegacy/repos/search/", ROOT.baseForm());
			}
		},
		ROOT {
			@Override
			public String baseForm() {
				return "https://api.github.com/";
			}
		}, 
		REPOSITORIES {
			@Override
			public String baseForm() {
				return String.format("%srepositories", ROOT.baseForm());
			}
		},
		USERS {
			@Override
			public String baseForm() {
				return "https://api.github.com/users/";
			}
		},
		SEARCH{
			public String baseForm() {
				return "https://api.github.com/search/repositories?q=";
			}
		};

		public abstract String baseForm();
	}

	private final String oauthToken;
	private final StringBuilder builder;

	@Inject
	public UrlBuilder(@Named("githubOauthToken") String oauthToken) {
		this.oauthToken = oauthToken;
		this.builder = new StringBuilder();
	}

	/**
	 * Choose what will be your base API.
	 * Currently available: USERS, REPOSITORES, and LEGACY
	 * see {@link GithubAPI}

	 * @param api
	 * @return current url representation
	 */
	public UrlBuilder uses(GithubAPI api) {
		this.builder.append(api.baseForm());
		return this;
	}
	
	/**
	 * Add a parameter to the URL
	 * 
	 * @param value
	 * @return current url representation
	 */
	public UrlBuilder withParam(String value) {
		this.builder.append(value);
		return this;
	}
	
	/**
	 * Add a parameter and value to the URL. It will be concatenated with ? or
	 * &, depending on whether it is the first parameter or not.
	 * 
	 * @param key
	 * @param value
	 * @return current url representation
	 */
	public UrlBuilder withParam(String key, Object value) {
		String concat = isFirstParam() ? "?" : "&";
		
		String param = String.format("%s%s=%s", concat, key, value);
		this.builder.append(param);
		return this;
	}

	/**
	 * Add a parameter and value to the URL. Differently of {@link withparam},
	 * this method will not use ? or & to concatenate the url.
	 * 
	 * @param key
	 * @param value
	 * @return current url representation
	 */
	public UrlBuilder withSimpleParam(String key, Object value) {
		this.builder.append(key).append(value);
		return this;
	}

	private boolean isFirstParam() {
		return !builder.toString().contains("?");
	}

	public UrlBuilder withParam(Map<String, Object> params) {
		throw new UnsupportedOperationException("Sorry. Not implemented yet.");
	}

	/**
	 * Return the url as a string 
	 * 
	 * @return final url
	 */
	public String build() {
		if(this.builder == null) 
			throw new UnsupportedOperationException("Nenhum parametro de URL foi enviado!");
		
		String concat = isFirstParam() ? "?" : "&";
		String result = this.builder.append(concat).append(oauthToken).toString();
		this.builder.delete(0, result.length());
		return result;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\AnalysisTest.java
package test;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import timer.Server;
import usefuldata.CommitDate;
import usefuldata.Release;
import usefuldata.VersionDate;
import entity.Contributor;
import entity.Project;
import entity.UnPublishedRelease;
import factory.DaoFactory;
import factory.MetaDaoFactory;
import analysis.CodeLinesCount;
import analysis.CodeLinesCountImpl;
import analysis.DataHelperImpl;
import analysis.DevelopDigram;
import analysis.DevelopDigramImpl;
import analysis.EvolveAnalysis;
import analysis.PackageDependency;
import analysis.PackageDependencyImpl;
import analysis.Relation;
import analysis.RelationImpl;
public class AnalysisTest {
	
	final static Logger logger = LoggerFactory.getLogger(AnalysisTest.class);
	
	public static void main(String []args){

		
		AnalysisTest at = new AnalysisTest();
		at.logttest();
		
		//CodeLinesCount clc = new CodeLinesCount();
		
		//System.out.println(clc.StatisticCodeLines("", "v1.7b1.zip"));
		
		
//		ArrayList<String> files=new ArrayList<String>();//所有版本文件的路径
//		String destination=null;//.json文件要存入的文件夹位置
//		
//		files.add("v1.8b1.zip");
//		destination="Downloads/";
//		PackageDependency.readZipFile(files, destination);//将每个版本对应的包依赖json数据格式输出到目标文件夹
//		
//		
//		DevelopDigram dd = new DevelopDigramImpl();
//		ArrayList<String> ewq = new ArrayList<String>();
//		ewq.add("databasePersistence/src/main/java/gov/nasa/arc/mct/dbpersistence/service/PersistenceServiceImpl.java");
//		System.out.println(dd.getDevelopDigramByVersion(ewq));
//		
//		ArrayList<String> languages = new ArrayList<String>();
//		languages.add("java");
//		
//		ArrayList<String> paths = new ArrayList<String>();
//		
//		List<Release> rels = DaoFactory.getProjectDao().getAllReleases("mct");
//		
//		for(int i =0;i<rels.size();i++){
//			paths.add(rels.get(i).getName() + ".zip");
//		}
		
		//paths.add("v1.7.0.zip");
		//paths.add("v1.7b1.zip");
		
		
//		AnalysisTest at = new AnalysisTest();
//		at.evolveTest();
		
		//AnalysisTest a = new AnalysisTest();
		//a.release_echartTest();
		
		//Project p = MetaDaoFactory.getProjectDao().getProject("spinfo","java");
		//System.out.println(p == null);
		
//		DataHelperImpl dhi = new DataHelperImpl();
//		ArrayList<VersionDate> vd = dhi.getVersions("java","spinfo");
//		System.out.println(vd.size());
//		
//		System.out.println(MetaDaoFactory.getProjectDao().getProject("spinfo","java").getId());
	}
	
	public void logttest(){
		logger.info("hello");
	}
	
	public void DataHelperImplTest(){
		DataHelperImpl dhi = new DataHelperImpl();
		ArrayList<String> ss = dhi.getFiles("mct", "v1.8b2", "DanBerrios","");
		for(int i =0;i<ss.size();i++){
			System.out.println(ss.get(i));
		}
		
	}
	
	public void getCommitsTest(){
		DataHelperImpl dhi = new DataHelperImpl();
		ArrayList<CommitDate> cds = dhi.getCommits("mct","");
		for(CommitDate c:cds){
			System.out.println(c.getName());
			System.out.println(c.getDate());
			
		}
		
	}
	
	public void getFilesTest(){
		DataHelperImpl dhi = new DataHelperImpl();
		ArrayList<String> files = dhi.getFiles("mct", "VWoeltjen", "2012-06-11", "2013-08-12");
		for(int i =0;i<files.size();i++){
			System.out.println(files.get(i));
		}
		
	}
	
	public void evolveTest(){
		EvolveAnalysis ea = new EvolveAnalysis("mct","");
		List<UnPublishedRelease> upr = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(4193864);
		int project_id = MetaDaoFactory.getProjectDao().getProject("mct","").getId();
		for(UnPublishedRelease e:upr){
			String json = ea.getEvolveJson(e.getName());
			System.out.println(e.getName());
			System.out.println(json);
			System.out.println("*********");
			//DaoFactory.getEvolveEchartsDao().addEvolveEcharts(project_id, e.getId(), json);
		}
		
		
	}
	
	public void codecountTest(){
		CodeLinesCount ds = new CodeLinesCountImpl();
		ArrayList<String> languages = new ArrayList<String>();
		languages.add("java");
		System.out.println(ds.getCodeLines("Downloads/nasa_mct/v1.7.0.zip"));
	}
	
	
	public void RelationTest(){
		Map<String, String> date_maps = new HashMap<String, String>();
		
		List<Contributor> ctr = MetaDaoFactory.getContributorDao().getAllContributors(4193864);
		List<UnPublishedRelease> upr= MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(4193864);
		ArrayList<String> developers = new ArrayList<String>();
		for(Contributor c:ctr){
			//System.out.println(c.getLogin());
			developers.add(c.getLogin());
		}
			
		
		for(UnPublishedRelease u:upr){
			//System.out.println(u.getName());
			date_maps.put(u.getName(), u.getDate());
		}
			
		
		Relation relation;
		String projectName = "mct";
				
		for(UnPublishedRelease u:upr){
			relation = new RelationImpl(projectName, u.getName(),"");
			System.out.println(u.getName());
			System.out.println(relation.getRelations());
			System.out.println(relation.getMainRelations());
			System.out.println("*************************");
		}
	}
	
	public void release_echartTest(){
		PackageDependency dd = new PackageDependencyImpl();
		ArrayList<String> as = new ArrayList<String>();
		ArrayList<String> languages = new ArrayList<String>();
		languages.add("java");
		
		as.add("Downloads/java-s11.zip");
		ArrayList<String> s = dd.getPakageDependency(as, languages);
		for(int i = 0;i<s.size();i++){
			System.out.println(s.get(i));
		}
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\CrawlGitHubTest.java
package test;

import java.io.File;
import java.util.concurrent.ExecutionException;






import com.google.inject.Guice;
import com.google.inject.Injector;

import crawler.CrawlGitHub;
import entity.Project;
import scmclient.GitClient;
import scmclient.ScmModule;

public class CrawlGitHubTest {
	
	private GitClient gitClient;
	
	
	public static void main(String []args){
		
//		GitClient gitClient =  new GitClient();
//		File destinationFolder = new File("Downloads/mct/latest");
//		CrawlGitHub a = new CrawlGitHub(gitClient, destinationFolder);
//		Project p = new Project("mct", "description", "https://github.com/nasa/mct");
//		a.downloadProject(p);
		
		
		//CrawlToDB cm = new CrawlToDB("mct","nasa","Downloads/mct/latest");
		//cm.CrawlProjectInfoToDB();;
		//System.out.println(cm.getLatest_path());
		
		CrawlGitHubTest cght = new CrawlGitHubTest();
		cght.setup();
		
		
	}
	
	
	
	public void setup() {
		Injector injector = Guice.createInjector(new ScmModule());
		this.gitClient = injector.getInstance(GitClient.class);
	}

	
	public void testCrawlGithub() throws InterruptedException, ExecutionException {
		CrawlGitHub crawl = new CrawlGitHub(gitClient, new File("D:\\Files/AAA"));
		Project p = new Project("Music beets", "description", "https://github.com/sampsyo/beets");
		crawl.downloadProject(p);
		}
		
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\DataHelperTest.java
package test;

import java.util.ArrayList;
import java.util.List;

import entity.Contributor;
import entity.UnPublishedRelease;
import factory.MetaDaoFactory;
import usefuldata.VersionDate;
import analysis.DataHelperImpl;

public class DataHelperTest {
	public static void main(String []args){
		DataHelperTest t1 = new DataHelperTest();
		t1.getFilesTest();
	}
	
	
	public void getSizeTest1(){
		DataHelperImpl dhip = new DataHelperImpl();
		int size = dhip.getSize("DanBerrios", "mct","");
		System.out.println(size);
	}
	
	public void getSizeTest2(){
		DataHelperImpl dhip = new DataHelperImpl();
		int size = dhip.getSize("DanBerrios", "mct", "v1.8b1");
		System.out.println(size);
	}
	
	public void getAllDeveloperNamesTest(){
		DataHelperImpl dhip = new DataHelperImpl();
		ArrayList<String> names = dhip.getAllDeveloperNames("mct","");
		for(String e:names){
			System.out.println(e);
		}
	}
	
	public void getCodesTest(){
		DataHelperImpl dhip = new DataHelperImpl();
		int codes = dhip.getCodes("mct", "v1.8b1","");
		System.out.println(codes);
	}
	
	public void getVesionsTest(){
		DataHelperImpl dhip = new DataHelperImpl();
		ArrayList<VersionDate> versiondates = dhip.getVersions("mct","");
		
		for(int i =0;i<versiondates.size();i++){
			System.out.println(versiondates.get(i).getVersion());
			System.out.println(versiondates.get(i).getDate());
			System.out.println(versiondates.get(i).getOrder());
			
			System.out.println("--------------");
			
		}
		
	}
	
	public void getFilesTest(){
		DataHelperImpl dhip = new DataHelperImpl();
		List<UnPublishedRelease> up_releases = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(4193864);
		List<Contributor> contributos = MetaDaoFactory.getContributorDao().getAllContributors(4193864);
		for(Contributor c:contributos){
			for(UnPublishedRelease u:up_releases){
				dhip.getFiles("mct", u.getName(), c.getLogin(),"");
			}
		}
		
		
		
		
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\JsonTest.java
package test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import util.Dates;



public class JsonTest {
	
	public static void main(String []args){
		/*
		List<Vitality> ss = new ArrayList<Vitality>();
		Vitality a1 = new Vitality("1-Apr-12",12);
		//Vitality a2 = new Vitality("2-Apr-12",112);
		//Vitality a3 = new Vitality("3-Apr-12",123);
		//Vitality a4 = new Vitality("4-Apr-12",15212);
		//Vitality a5 = new Vitality("5-Apr-12",1233);
		ss.add(a1);
		//ss.add(a2);
		//ss.add(a3);
		//ss.add(a4);
		//ss.add(a5);
		
		VitalityDaoImpl a = new VitalityDaoImpl();
		String s = a.VitalityToJson(ss);
		System.out.println(s);
		
		Injector injector = Guice.createInjector(new SearchModule(), new HttpModule());
		SearchGitHub searchGitHub = injector.getInstance(SearchGitHub.class);
		
		
		VitalityTransform a = new VitalityTransform();
		User user = new User("twbs");
		Project project = new Project(user,"bootstrap");
		
		User uss = new User("cvrebert");
		
		List<Commit> commits = searchGitHub.getAllProjectCommits(project);
		
		List<Commit> sseqw = new ArrayList<Commit>();
		
		for(Commit cmit:commits){
			if(cmit.getCommiter().getLogin().equals(uss.getLogin())){
				sseqw.add(cmit);
			}
		}
		
		//System.out.println(uss.getLogin());
		
		uss.setCommits(sseqw);
		List<Vitality> ss = a.transform(uss, project);
		for(Vitality e:ss){
			System.out.println(e.toString());
		}
		
		
		Map<String,String> st = new HashMap<String,String>();
		st.put("v1.7b1", "2012-06-30T20:18:25Z");
		st.put("v1.7b2", "2012-07-19T20:18:25Z");
		st.put("v1.7b3", "2012-08-07T20:18:25Z");
		
		
		Map<String,String> rs = Dates.dateFormat(st);
		Set<String> ss = rs.keySet();
		for(String name:ss){
			System.out.println(name + ": " + rs.get(name));
		}
		
		
		
		Map<String, Integer> map = new HashMap<String, Integer>();  
		  
		map.put("lisi", 5);   
		map.put("lisi1", 1);   
		map.put("lisi2", 3);   
		map.put("lisi3", 9);   
		*/
		
		
		Map<String, String> map = new HashMap<String, String>(); 
		map.put("lisi", "2012-08-30"); 
		map.put("lisi1", "2012-06-30"); 
		map.put("lisi2", "2012-07-19"); 
		map.put("lisi3", "2012-08-07"); 
				
		ArrayList<String> aa = Dates.dateSort(map);
		for(int i = 0 ;i<aa.size();i++){
			System.out.println(aa.get(i));
		}
		
		
		
	}


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\MetaSearchTest.java
package test;

import java.util.List;

import http.HttpModule;

import com.google.inject.Guice;
import com.google.inject.Injector;

import entity.Commit;
import entity.CommitFile;
import entity.Contributor;
import entity.Issue;
import entity.Project;
import entity.UnPublishedRelease;
import entity.User;
import factory.MetaDaoFactory;
import search.MetaSearchGitHub;
import search.SearchGitHub;
import search.SearchModule;
import usefuldata.Developer;

public class MetaSearchTest {
	private MetaSearchGitHub MetasearchGitHub;
	private SearchGitHub searchGitHub2;

	public static void main(String []args){
		MetaSearchTest a = new MetaSearchTest();
		a.setup();
		a.testgetProject();
	}
	
	public void setup() {
		Injector injector = Guice.createInjector(new SearchModule(), new HttpModule());
		MetasearchGitHub = injector.getInstance(MetaSearchGitHub.class);
		searchGitHub2 = injector.getInstance(SearchGitHub.class);
	}
	
	/**
	 * already test over
	 */
	public void testgetProject(){
		try{
		Project p = MetasearchGitHub.getProject("java", "spinfo");
		if(p!=null){
			System.out.println(p.getId());
			System.out.println(p.getName());
			System.out.println(p.getDescription());
			System.out.println(p.getLanguage());
			System.out.println(p.getCheckoutURL());
			System.out.println(p.getSourceCodeURL());
			System.out.println(p.getCreatedAt());
			System.out.println(p.getLastPushedAt());
			System.out.println(p.isFork());
			System.out.println(p.hasDownloads());
			System.out.println(p.hasIssues());
			System.out.println(p.hasWiki());
			System.out.println(p.getWatchersCount());
			System.out.println(p.getForksCount());
			System.out.println(p.getIssuesCount());
			System.out.println(p.getOwner().getLogin());
			
			
			//MetaDaoFactory.getProjectDao().addProject(p);
			
			//System.out.println(p.getUser().getName());
			
		}else
			System.out.println("project not found");
		
		
		
		}catch(Exception e){
			e.printStackTrace();
		}
	}

	/**
	 * already test over
	 */
	public void testGetAllCommits(){
		try {
			entity.Project p = new Project(new User("nasa"), "mct");
			List<Developer> dp = searchGitHub2.getDevelopers(p);
			
			for(int i = dp.size()-1;i>=0;i--){
				List<Commit> commits = MetasearchGitHub.getProjectCommitsByCommiter(p, dp.get(i).getLogin());
				for(Commit cm:commits){
					MetaDaoFactory.getCommitDao().addCommit(cm, 4193864);
					
				}	
			}
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}

	/**
	 * already test over
	 */
	public void testGetUnPublishedRelease(){
		List<UnPublishedRelease> upbr = MetasearchGitHub.getAllUnPublishedRelease("nasa", "mct");
		if(upbr!=null){
			for(UnPublishedRelease r:upbr){
				MetaDaoFactory.getUnPublishedReleaseDao().addUnPublishedRelease(r, 4193864);
			}
		}
	}
	
	/**
	 * already test over 
	 * but has some bugs
	 * time 60000 with no response
	 */
	public void testGetCommitFiles(){
		
		int projectId = MetaDaoFactory.getProjectDao().getProject("nasa", "mct").getId();
		List<Commit> commits = MetaDaoFactory.getCommitDao().getCommits(projectId);
		
		
		for(int i = 537;i < commits.size();i++){
//			if(commits.get(i).getSha().equals("ab9761a663d890d3051eeda306c7dcc4b386ed1d")){
//				System.out.println(i);
//			}
			
			List<CommitFile> cmfs = MetasearchGitHub.getCommitFiles("nasa", "mct", commits.get(i).getSha());
			if(cmfs !=null){
				for(CommitFile commitfile:cmfs){
					MetaDaoFactory.getCommitFileDao().addCommitFile(commitfile);
				}
			}
				
		}
		
	}
	
	
	public void testGetUsers(){
		List<Contributor> ctbs = MetaDaoFactory.getContributorDao().getAllContributors(4193864);
		for(Contributor c:ctbs){
			entity.User user = MetasearchGitHub.getUser(c.getLogin());
			MetaDaoFactory.getUserDao().addUser(user);
		}
		
	}
	
	public void testgetAllProjectIssues(){
		entity.Project p = new Project(new User("codahale"), "bcrypt-ruby");
		List<Issue> issues = MetasearchGitHub.getAllProjectIssues(p);
		
		for(Issue i:issues){
			System.out.println(i.getTitle());
		}
		
	}
	
	public void testGetProjectComment(){
		List<entity.Comment> comments = MetasearchGitHub.getComments("mct", "nasa");
		for(entity.Comment c :comments){
			MetaDaoFactory.getCommentDao().addComment(c, 4193864);
//			System.out.println(c.getId());
//			System.out.println(c.getUrl());
//			System.out.println(c.getUser());
//			System.out.println(c.getUser_id());
//			System.out.println(c.getPosition());
//			System.out.println(c.getLine());
//			System.out.println(c.getPath());
//			System.out.println(c.getCommit_id());
//			System.out.println(c.getCreated_at());
//			System.out.println(c.getUpdated_at());
//			System.out.println(c.getBody());
//			
//			System.out.println("---------------------");
			
		}
		
	}
	
}
	
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\MetaSqlTest.java
package test;

import http.HttpModule;

import java.util.List;

import search.MetaSearchGitHub;
import search.SearchGitHub;
import search.SearchModule;
import usefuldata.Developer;
import util.Dates;

import com.google.inject.Guice;
import com.google.inject.Injector;

import entity.Commit;
import entity.Contributor;
import entity.Project;
import entity.User;
import factory.MetaDaoFactory;

public class MetaSqlTest {
	private MetaSearchGitHub searchGitHub;
	private SearchGitHub searchGitHub2;
	
	public static void main(String []args){
		
//		MetaSqlTest mst = new MetaSqlTest();
//		mst.setup();
//		mst.testIssueDao();
//		
		
		Project p = MetaDaoFactory.getProjectDao().getProject("spinfo", "java");
		System.out.println( p == null);
		
//		List<Commit> ccs = MetaDaoFactory.getCommitDao().getCommits(4193864);
//		for(Commit c:ccs){
//			//c.setCommitDate(c.getCommitDate().toString());
//			
//			c.setCommitDate(Dates.metaDateFormat(c.getCommitDate().toString()));
//			MetaDaoFactory.getCommitDao().updateCommit(c, 4193864);
//		}
//		
	}
	
	public void setup() {
		Injector injector = Guice.createInjector(new SearchModule(), new HttpModule());
		searchGitHub = injector.getInstance(MetaSearchGitHub.class);
		
		searchGitHub2 = injector.getInstance(SearchGitHub.class);
	
	}
	
	
//	public void testContributorDao(){
//		try {
//			
//			/*Sanity test, if the list of contributors is null, something is wrong*/
//			Project project = new Project(new User("nasa"), "mct");
//			List<Contributor> contributors = searchGitHub.getAllProjectContributors(project);
//			
//			for(Contributor a:contributors){
//				MetaDaoFactory.getContributorDao().addContributor(a);
//				
//			}
//			
//		} catch (Exception e) {
//			e.printStackTrace();
//			
//		}
//		
//	}
	
	public void testCommitDao(){
		try {
			
			/*Sanity test, if the list of contributors is null, something is wrong*/
		
			//System.out.println(project.getId());
			
			entity.Project p = new Project(new User("nasa"), "mct");
			List<Contributor> dp = MetaDaoFactory.getContributorDao().getAllContributors(4193864);
			
			for(int i = 4;i>=0;i--){
				//only 4 has not been crawled
				if(dp.get(i).getLogin().equals("VWoeltjen")){
					List<Commit> commits = searchGitHub.getProjectCommitsByCommiter(p, dp.get(i).getLogin());
					for(Commit cm:commits){
						MetaDaoFactory.getCommitDao().addCommit(cm, 4193864);
					}
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			
		}
		
	}
	
	public void testGetAllContributors(){
		try {
			List<Contributor> ctbs = MetaDaoFactory.getContributorDao().getAllContributors(4193864);
			for(Contributor c:ctbs){
				System.out.println(c.getLogin());
			}
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	public void testIssueDao(){
		try{
			List<entity.Issue> isss = MetaDaoFactory.getIssueDao().getAllMetaIssues(4193864);
			for(entity.Issue is:isss){
				MetaDaoFactory.getIssueDao().updateIssue(is,4193864);
				
			}
			
		}catch (Exception e) {
			e.printStackTrace();
			
		}
		
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\ModuleTest.java
package test;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import usefuldata.DeveloperEcharts;
import usefuldata.EvolveEcharts;
import usefuldata.ForceEcharts;
import usefuldata.ProjectContribution;
import usefuldata.Release;
import usefuldata.ReleaseContribution;
import usefuldata.ReleaseEcharts;
import usefuldata.Vitality;
import util.Dates;
import analysis.AnalysisModule;
import analysis.CodeLinesCount;
import analysis.CodeLinesCountImpl;
import analysis.DataHelper;
import analysis.DataHelperImpl;
import analysis.DevelopDigram;
import analysis.DevelopDigramImpl;
import analysis.EvolveAnalysis;
import analysis.PackageDependency;
import analysis.PackageDependencyImpl;
import analysis.Relation;
import analysis.RelationImpl;
import crawler.CrawlModule;
import entity.Contributor;
import entity.UnPublishedRelease;
import factory.MetaDaoFactory;

public class ModuleTest {
	public static void main(String []args){
		ModuleTest mt = new ModuleTest();
		//System.out.println(111);
		mt.ProjectAnalysis();
	}
	
	public void test(){
		//CrawlToDB ctdb = new CrawlToDB("mct","nasa","aaa");
		//System.out.println(ctdb.getCrawlController().getProjectName());
		//List<UnPublishedRelease> unPublishedRelease = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(4193864);
		//System.out.println(111);
		//ctdb.CrawlCommitsToDB(contributors);
		
		//ctdb.downLoadUnpublish_releases(unPublishedRelease);
	}
	
	public void EvolveEchartsAnalysis(){
		ArrayList<usefuldata.EvolveEcharts> evolve_echarts = new ArrayList<usefuldata.EvolveEcharts>();
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(15293);
		String json = "";
		EvolveAnalysis evolveAnalysis = new EvolveAnalysis("bcrypt-ruby","");
		
		for(int i = 0;i<uprs.size();i++){
			json = evolveAnalysis.getEvolveJson(uprs.get(i).getName());
			if(!json.equals("")){
				EvolveEcharts e = new EvolveEcharts(15293,uprs.get(i).getId(),json);
				if(e!=null)
					evolve_echarts.add(e);	
			}
				
		}
	}
	
	
	public void AnalysisTest(){
		String projectName,owner,filepath;
    	projectName = "bcrypt-ruby";
    	owner = "codahale";
    	filepath = "Downloads/" + owner +"/";
		
    	
    	
    	//CrawlModule crawlModule = new CrawlModule(projectName,owner,filepath);
		
		//AnalysisModule analysisModule = new AnalysisModule(crawlModule);
		
		List<usefuldata.DeveloperEcharts> developer_echarts = new ArrayList<usefuldata.DeveloperEcharts>();
		
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(15293);	
		
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(15293);
		
		DataHelper dataHelperImpl = new DataHelperImpl("bcrypt-ruby","");
		DevelopDigram developDigram = new DevelopDigramImpl();
		
		for(int i = 0;i<contributors.size();i++){
			for(int j = 0;j<uprs.size();j++){
				DeveloperEcharts dle = new DeveloperEcharts();
				dle.setProject_id(15293);
				dle.setRelease_id(uprs.get(j).getId());
				dle.setDeveloper_id(contributors.get(i).getId());
				ArrayList<String> file_names = dataHelperImpl.getFiles("bcrypt-ruby", uprs.get(j).getName(), contributors.get(i).getLogin(),"");
				
//				System.out.println(file_names.size());
//				for(int z = 0;z<file_names.size();z++){
//					System.out.println(file_names.get(z) +" contributor:" + contributors.get(i).getLogin() + "   " + uprs.get(j).getName());
//				}
				
				//System.out.println(uprs.get(j).getName());
				//System.out.println(contributors.get(i).getLogin());
				
				String json_string = "";
				if(file_names!=null && file_names.size() != 0)
					json_string = developDigram.getDevelopDigramByVersion(file_names);
		
				if(!json_string.equals("")){
					dle.setJson_string(json_string);
					developer_echarts.add(dle);
				}
				
			}
		}
		
//		for(int i = 0;i<developer_echarts.size();i++){
//			System.out.println(developer_echarts.get(i).toString());
//			
//		}
			
		
	}
	
	public void ForceEchartsAnalysis(){
		ArrayList<usefuldata.ForceEcharts> force_echarts = new ArrayList<usefuldata.ForceEcharts>();
		
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(15293);	
		String relation_json = "";
		String main_relation_json = "";
		
		Relation relation;
		
		for(int i = 0;i<uprs.size();i++){
			relation = new RelationImpl("bcrypt-ruby",uprs.get(i).getName(),"");
			relation_json = relation.getRelations();
			main_relation_json = relation.getMainRelations();
			if(!relation_json.equals("") && !main_relation_json.equals("")){
				ForceEcharts fe = new ForceEcharts(15293,uprs.get(i).getId(),relation_json,main_relation_json);
				if(fe!=null)
					force_echarts.add(fe);
			}
			
		}
		
		
		for(int i = 0;i<force_echarts.size();i++){
			System.out.println(force_echarts.get(i).getProject_id());
			System.out.println(force_echarts.get(i).getRelease_id());
			System.out.println(force_echarts.get(i).getRelation());
			System.out.println(force_echarts.get(i).getMain_relation());
			System.out.println("********");
		}
	}
	
	public void ProjectContributionAnalysis(){
		ArrayList<ProjectContribution> project_contribution = new ArrayList<ProjectContribution>();
		
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(15293);
		
		for(int i = 0;i<contributors.size();i++){
			ProjectContribution pjc = new ProjectContribution();
			pjc.setProjectName("bcrypt-ruby");
			pjc.setProject_id(15293);
			pjc.setDeveloper_id(contributors.get(i).getId());
			
			int ctb = MetaDaoFactory.getCommitDao().Contributions(15293, contributors.get(i).getId());
			pjc.setContributions(ctb);	
			project_contribution.add(pjc);
		}
		
		for(int i = 0;i<project_contribution.size();i++){
			System.out.println(project_contribution.get(i).getContributions());
		}
		
	}
	
	public void ReleaseContributionAnalysis(){		
		ArrayList<usefuldata.ReleaseContribution> release_contributions = new ArrayList<usefuldata.ReleaseContribution>();
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(15293);	
		
		List<Contributor> contributors = MetaDaoFactory.getContributorDao().getAllContributors(15293);
		
		DataHelper dataHelperImpl = new DataHelperImpl("bcrypt-ruby","");
		
		for(int i = 0;i<contributors.size();i++){
		
		for(int j = 0;j<uprs.size();j++){
			ReleaseContribution rlct = new ReleaseContribution();
			rlct.setRelease_id(uprs.get(j).getId());
			rlct.setProject_id(15293);
			rlct.setDeveloper_id(contributors.get(i).getId());
			rlct.setReleaseName(uprs.get(j).getName());
			
			int contributions = dataHelperImpl.getReleaseSize(contributors.get(i).getLogin(), "bcrypt-ruby", uprs.get(j).getName(),"");
			rlct.setContributions(contributions);
			
			release_contributions.add(rlct);
		}
		}
		
		for(int i = 0;i<release_contributions.size();i++){
			System.out.println(release_contributions.get(i).getContributions());
		}
	}
	
	public  void ReleaseEchartsAnalysis(){
		ArrayList<usefuldata.ReleaseEcharts> release_echarts = new ArrayList<usefuldata.ReleaseEcharts>();
		ArrayList<String> languages = new ArrayList<String>();
		languages.add("c");	
		
		PackageDependency packageDependency = new PackageDependencyImpl();
		
		ArrayList<String> location = new ArrayList<String>();
		location.add("Downloads/codahale_bcrypt-ruby/rel_2_0_3.zip");
		location.add("Downloads/codahale_bcrypt-ruby/rel_2_0_4.zip");
		location.add("Downloads/codahale_bcrypt-ruby/rel_2_0_5.zip");
		location.add("Downloads/codahale_bcrypt-ruby/rel_2_1_0.zip");
		location.add("Downloads/codahale_bcrypt-ruby/rel_2_1_1.zip");
		location.add("Downloads/codahale_bcrypt-ruby/rel_2_1_2.zip");
		location.add("Downloads/codahale_bcrypt-ruby/v3.0.0.zip");
		location.add("Downloads/codahale_bcrypt-ruby/v3.0.1.zip");
		location.add("Downloads/codahale_bcrypt-ruby/v3.1.1.zip");
		location.add("Downloads/codahale_bcrypt-ruby/v3.1.3.zip");
		location.add("Downloads/codahale_bcrypt-ruby/v3.1.6.zip");
		
		
		ArrayList<String> package_json = packageDependency.getPakageDependency(location, languages);		
		List<UnPublishedRelease> uprs = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(15293);			
		
		for(int i = 0;i<uprs.size();i++){
			ReleaseEcharts re = new ReleaseEcharts(15293,
				uprs.get(i).getId(),package_json.get(i));		
			release_echarts.add(re);
			
			System.out.println(re.getJson_string());
		}
	}

	public  void ReleaseAnalysis(){		
		//ArrayList<usefuldata.Release> releases = new ArrayList<usefuldata.Release>();
		List<UnPublishedRelease> unpublish_releases = MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(15293);	
		
		CodeLinesCount codeLinesCount = new CodeLinesCountImpl();
		
		ArrayList<String> languages = new ArrayList<String>();
		languages.add("c");	
		
		ArrayList<String> uprs_location = new ArrayList<String>();
		uprs_location.add("Downloads/codahale_bcrypt-ruby/rel_2_0_3.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/rel_2_0_4.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/rel_2_0_5.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/rel_2_1_0.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/rel_2_1_1.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/rel_2_1_2.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/v3.0.0.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/v3.0.1.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/v3.1.1.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/v3.1.3.zip");
		uprs_location.add("Downloads/codahale_bcrypt-ruby/v3.1.6.zip");
		
		DataHelper dataHelperImpl = new DataHelperImpl("bcrypt-ruby","");
		
		for(int i = 0;i<unpublish_releases.size();i++){
			Release release = new Release();
			release.setId(unpublish_releases.get(i).getId());			
			release.setName(unpublish_releases.get(i).getName());	
			
			int codes = codeLinesCount.getCodeLines(uprs_location.get(i));
			release.setCodes(codes);
			release.setDate(unpublish_releases.get(i).getDate());
			
			int commits = dataHelperImpl.getReleaseCommits("bcrypt-ruby", unpublish_releases.get(i).getName(),"");
			release.setRelease_commits(commits);
			
			release.setDocument(dataHelperImpl.getDocument());
			release.setTest(dataHelperImpl.getTest());
			
			if(i != unpublish_releases.size()-1){
				String date1 = unpublish_releases.get(i).getDate();
				String date2 = unpublish_releases.get(i+1).getDate();
				long diff_day = Dates.dayDiffer(date1, date2);
				double rate = diff_day/1.0;
				release.setCommit_rate(rate);
			}
			else{
				String date1 = unpublish_releases.get(i).getDate();
				String date2 = Dates.dateToString(new Date());
				long diff_day = Dates.dayDiffer(date1, date2);
				double rate = diff_day/7.0;
				release.setCommit_rate(rate);
			}
			
			int issues = dataHelperImpl.getIssueNum("bcrypt-ruby", unpublish_releases.get(i).getName(),"");
			release.setIssue_number(issues);
			
			release.setComprehensive(dataHelperImpl.getComprehensive());
			
			System.out.println(release.getId());
			System.out.println(release.getName());
			System.out.println(release.getCodes());
			System.out.println(release.getDate());
			System.out.println(release.getCommit_rate());
			System.out.println(release.getIssue_number());
			
			System.out.println("***********");
			
			
		}
			
	}
	
	public void VitalityAnalysis(){
		ArrayList<Vitality> vitalities = new ArrayList<Vitality>();
		
		List<Contributor> developers = MetaDaoFactory.getContributorDao().getAllContributors(15293);
		
		DataHelper dataHelperImpl = new DataHelperImpl("bcrypt-ruby","");
		
		for(Contributor c:developers){
			List<Vitality> v1 = dataHelperImpl.getVitality("bcrypt-ruby", c.getLogin(),"");
			if(v1!=null){
				vitalities.addAll(v1);	
				
			}
			
		}
		
		
		for(int i = 0;i<vitalities.size();i++){
			System.out.println(vitalities.get(i).getVitality());
			System.out.println(vitalities.get(i).getDate());
			System.out.println("************");
			
		}
	}
	
//	public void ProjectAnalysis(){
//		ArrayList<String> languages = new ArrayList<String>();
//		languages.add("c");		
//		CodeLinesCount codeLinesCount = new CodeLinesCountImpl();
//		
//		int main_count = codeLinesCount.getCodeLines(crawlModule.getLatest_path(), languages);
//		this.project = crawlModule.getProject().ProjectTransform(main_count);
//				
//	}
	
	public void ProjectAnalysis(){
		ArrayList<String> languages = new ArrayList<String>();
		languages.add("c");		
		
		CodeLinesCount codeLinesCount = new CodeLinesCountImpl();
		
		int main_count = codeLinesCount.getCodeLines("Downloads/bcrypt-ruby.zip");
		
		System.out.println(main_count);
		
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\SearchGitHubTest.java
package test;

import http.HttpModule;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import scmclient.GitClient;
import search.SearchGitHub;
import search.SearchModule;


import usefuldata.Developer;
import usefuldata.ProjectContribution;
import usefuldata.Vitality;
import analysis.DataHelperImpl;
import analysis.DevelopDigramImpl;
import analysis.Relation;
import analysis.RelationImpl;
import analysis.VitalityCount;

import com.google.inject.Guice;
import com.google.inject.Injector;

import crawler.CrawlGitHub;
import entity.Commit;
import entity.Contributor;
import entity.Language;
import entity.Project;
import entity.Release;
import entity.User;
import factory.DaoFactory;
import factory.DataFactoryImpl;

public class SearchGitHubTest {
	
	private SearchGitHub searchGitHub;
	private Project fakeProject;
	private SearchGitHub searchGitHub2;
	
	public static void main(String []args){
		SearchGitHubTest a = new SearchGitHubTest();
		a.setup();
		
		//a.testGetProjects();
		
		//a.testGetDeveloper();
		
		//a.testGetAllProjectContributors();
		
		
		//a.testGetAllProjectReleases();
		
		//a.testSearchByProjectName();
		
		//a.testGetAllProjectReleases();
		
		a.testGetAllProjectCommits();

		
		//a.testSearchByProjectName();
		
		
		//a.testGetVitality();
		
		//a.testDownladAllRelease();
		
		//a.testGetContributions();
		
		//a.testGetVitality();
		
		//a.testGetFile();
		
		//a.testGetMetaProject();
	}
	
	public void setup() {
		Injector injector = Guice.createInjector(new SearchModule(), new HttpModule());
		searchGitHub = injector.getInstance(SearchGitHub.class);
		
		Injector injector2 = Guice.createInjector(new SearchModule(), new HttpModule());
		searchGitHub2 = injector2.getInstance(SearchGitHub.class);
		//User user = new User("elixir-lang");
		//fakeProject = new Project("elixir", "", "git@github.com:elixir-lang/elixir.git");
		//fakeProject.setUser(user);
	}
	
	public void test1(){
		try{
			
			Project project = new Project(new User("nasa"), "mct");
			List<Contributor> contributors = searchGitHub.getAllProjectContributors(project);
			for(Contributor cb:contributors){
				if(!cb.getLogin().equals("VWoeltjen")){
				ProjectContribution pcp = searchGitHub.getAllProjectContribution("nasa", "mct", cb.getLogin(), 4193864);
				DaoFactory.getProjectContribution().addProjectContribution(pcp);
				}
			}
			
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	
	public void testGetProjects(){
		try {			
			/*
			List<Project> projects = searchGitHub.getProjects("mct", "nasa", SearchGitHub.INFINITY);
			for(Project p:projects){
					if(p.getName().equals("mct") && p.getOwner().getLogin().equals("nasa")){
						System.out.println(p.getId());
						break;
					}
					
			}
			*/
			
			usefuldata.Project p = searchGitHub.getProject("mct", "nasa");
			if(p!=null){
				System.out.println(p.getId());
				System.out.println(p.getName());
				System.out.println(p.getOwner());
				System.out.println(p.getDescription());
				
			}
			
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
		
		
	}
	
	
	/**
	 * search all developers and add into mysql
	 */
	public void testGetDeveloper(){
		try {			
			
			Project project = new Project(new User("nasa"), "mct");
			List<Developer> dp = searchGitHub.getDevelopers(project);
			for(Developer d:dp)
			DaoFactory.getDeveloperDao().addDeveloper(d);
			
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testSearchByProjectName() {
		try {			
			List<Project> projects = searchGitHub.getProjects("mct", 1, SearchGitHub.INFINITY);
			searchGitHub.getProjectLanguages(projects.get(0));
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testFetchByProjectLanguages() {
		try {
			List<Language> langs = searchGitHub.getProjectLanguages(fakeProject);
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testGetAllProjects() {
		try {
			List<Project> projects = searchGitHub.getAllProjects(0, 5);
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testGetProjectsByLanguage() {
		try {
			List<Project> projects = searchGitHub.getAllProjectsByLanguage("java");
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testGetAllProjectCommits() {
		try {

			Project project = new Project(new User("byelaney"),"codeforce");
			
			List<Commit> commits = searchGitHub.getAllProjectCommits(project);
			
			if(commits!=null){
			//System.out.println(commits.size());
			for(Commit cc:commits){
				System.out.println(cc.getCommiter().getLogin());
				System.out.println(cc.getAdditionsCount());
				System.out.println(cc.getDeletionsCount());
				System.out.println(cc.getSha());
				System.out.println("---------------------");
			}
			
			
			}
			else
				System.out.println("project not found");
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testGetAllProjectContributors() {
		try {
			
			/*Sanity test, if the list of contributors is null, something is wrong*/
			Project project = new Project(new User("nasa"), "mct");
			List<Contributor> contributors = searchGitHub.getAllProjectContributors(project);
			
			for(Contributor a:contributors){
				System.out.println(a.getId() + "  contributions:" + a.getContributions());
			}
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testGetAllProjectReleases() {
		try {
			User u = new User("nasa");
			Project project = new Project(u, "mct");
			
			List<Release> releases = searchGitHub.getAllProjectReleases(project);
			
			
			for(Release a:releases){
				System.out.println(a.getName());
			}
			
			
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
	}
	
	
	public void testGetVitality(){
		try{
			//List<Developer> devlops = DaoFactory.getProjectDao().getAllDevelopers(4193864);
			
			//Map<String,String> ss = searchGitHub.getReleaseDate("nasa","mct");
			
			
			
			/*
			for(Developer dev:devlops){
				Map<String,Integer> sas = searchGitHub.getVitality(ss,project,dev.getLogin());
				Set<String> asd = sas.keySet();
				
				for(String qwe:asd){
					if(sas.get(qwe) > 0){
						Vitality vitality = new Vitality();
						vitality.setVitality(sas.get(qwe));
						usefuldata.Release ress = DaoFactory.getReleaseDao().getRelease(4193864, qwe);
						DaoFactory.getVitalityDao().addVitality(vitality, dev.getId(), 4193864, ress.getId());
					}
					
				}
				
			}
			*/
			List<Developer> devlops = DaoFactory.getProjectDao().getAllDevelopers(4193864);
			
			Project project = new Project(new User("nasa"), "mct");
			
			for(Developer dev:devlops){
				List<Vitality> sas = searchGitHub.getVitality(project,dev.getLogin());
				VitalityCount vc = new VitalityCount();				
				List<Vitality> results = vc.handleVitalityRelease(sas, project.getName(), dev.getLogin(),"");
				
				for(Vitality vvvv:results){
					DaoFactory.getVitalityDao().addVitality(vvvv);				
				}
				
				
			}
			
			
			
			
		}catch (Exception e) {
			e.printStackTrace();
			
		}
		
	}
	
	public void testDownladAllRelease(){
		try{
			Map<String,String> maps = searchGitHub.getReleaseUrls("nasa", "mct");
			
			GitClient gitClient =  new GitClient();
			File destinationFolder = new File("Downloads/");
			CrawlGitHub a = new CrawlGitHub(gitClient, destinationFolder);
			
			Set<String> keys = maps.keySet();
			for(String name:keys){
				String url = maps.get(name);
				a.httpDownload(url,"Downloads/mct/releases/",name +".zip");
			}
			
			
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	public void testGetContributions(){
		try{
			
			//int i = searchGitHub.getContribution("nasa", "mct","7f0574327c8be70a91b8229d7beb59744dfce55e");
			
			//System.out.println(i);
		}catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	public void testGetReleaseContributions(){
		try{
			
			/*
			List<usefuldata.Release> rs = DaoFactory.getReleaseDao().getAllRelease(4193864);
			List<Developer> developers = DaoFactory.getProjectDao().getAllDevelopers(4193864);
			
			Map<String,String> ss = searchGitHub.getReleaseDate("nasa","mct");
			
			Project project = new Project(new User("nasa"), "mct");
			
			for(int i =0;i<developers.size();i++){
				
				if(!developers.get(i).getLogin().equals("VWoeltjen"))
				{	
				Map<String,Integer> res = searchGitHub.getReleaseContribution(ss,project,developers.get(i).getLogin());
				Set<String> keys = res.keySet();
				
				for(String key_name:keys){
					for(int j = 0;j<rs.size();j++){
						if(key_name.equals(rs.get(j))){
							DaoFactory.getReleaseDao().addRelease(rs.get(j).getId(), developers.get(i).getId(), 4193864, res.get(key_name));	
						}
						
						
					}
					
				}
				
			}
				
			}
			
			*/
			
			Map<String,String> ss = searchGitHub.getReleaseDate("nasa","mct");
			Project project = new Project(new User("nasa"), "mct");
			
			List<Developer> dvls = DaoFactory.getProjectDao().getAllDevelopers(4193864);
			for(Developer dp:dvls){
				Map<String,Integer> res = searchGitHub.getReleaseContribution(ss,project,dp.getLogin());
				
				Set<String> keys = res.keySet();
				for(String key_name:keys){
					usefuldata.Release sars = DaoFactory.getReleaseDao().getRelease(4193864, key_name);
					if(res.get(key_name) > 0)
					DaoFactory.getReleaseDao().addReleaseContribution(sars.getId(),dp.getId(), 4193864,res.get(key_name));
				
				}
				
			}
			
			/*
			Map<String,Integer> res = searchGitHub.getReleaseContribution(ss,project,"dtran320");
			
			
			Set<String> keys = res.keySet();
			for(String key_name:keys){
				usefuldata.Release sars = DaoFactory.getReleaseDao().getRelease(4193864, key_name);
				if(res.get(key_name) > 0)
				DaoFactory.getReleaseDao().addRelease(sars.getId(),177059, 4193864,res.get(key_name));
			
			}
			*/
			
			
						
		}catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	public void testGetFile(){
		try{
			
//			ArrayList<String> files = searchGitHub.getFiles(ss, "kptran", "nasa", "mct","v1.7b3");
//			for(int i =0;i<files.size();i++){
//				System.out.println(files.get(i));
//			}
//			
			
			Map<String,String> ss = searchGitHub.getReleaseDate("nasa","mct");
			List<Developer> devs = DaoFactory.getProjectDao().getAllDevelopers(4193864);
			
			//ArrayList<String> developers = new ArrayList<String>();
			 			
			List<usefuldata.Release> rels = DaoFactory.getReleaseDao().getAllRelease(4193864);
			
			DevelopDigramImpl ddi = new DevelopDigramImpl();
			
			ArrayList<String> filenames = null;
			
			for(Developer d:devs){
				for(usefuldata.Release rrr:rels){
					
					filenames = searchGitHub.getFiles(ss, d.getLogin(), "nasa", "mct", rrr.getName());
					for(int i=0;i<filenames.size();i++){
						System.out.println(filenames.get(i));
					}
					
					if(!filenames.isEmpty()){
						String json_string = ddi.getDevelopDigramByVersion(filenames);
						if(json_string!=null)
						DaoFactory.getDeveloperEchartsDao().addDeveloperEcharts(4193864, rrr.getId(), d.getId(), json_string);
						
					}
					
				}
			}
			
			
			
			
			
//			DataHelperImpl dhpi = new DataHelperImpl();
//			ArrayList<String> files = dhpi.getFiles(ss, "kptran", "nasa", "mct", "v1.7b3");
//			for(int i =0;i<files.size();i++){
//				System.out.println(files.get(i));
//			}
			
			
		}catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	public void testGetMetaProject(){
		try {			
			List<Project> projects = searchGitHub.getProjects("mct", 1, SearchGitHub.INFINITY);
			for(Project p:projects){
				if(p.getName().equals("mct")){
					System.out.println(p.getId());
					System.out.println(p.getName());
					System.out.println(p.getDescription());
					
					System.out.println(p.getLanguage());
					System.out.println(p.getCheckoutURL());
					System.out.println(p.getSourceCodeURL());
					System.out.println(p.getCreatedAt().toString());
					System.out.println(p.getLastPushedAt().toString());
					
					System.out.println(p.isFork());
					System.out.println(p.hasDownloads());
					System.out.println(p.hasIssues());
					System.out.println(p.hasWiki());
					
					System.out.println(p.getWatchersCount());
					System.out.println(p.getForksCount());
					System.out.println(p.getIssuesCount());
					
					break;
				}
			}
			
			
		} catch (Exception e) {
			e.printStackTrace();
			
		}
		
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\SqlTest.java
package test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import usefuldata.Developer;
import usefuldata.DeveloperEcharts;
import usefuldata.Project;
import usefuldata.ProjectContribution;
import usefuldata.Release;
import usefuldata.ReleaseContribution;
import usefuldata.Vitality;
import entity.Crawlindex;
import factory.DaoFactory;
import factory.MetaDaoFactory;

public class SqlTest {
	
	
	public static void main(String []args){
//		DeveloperEcharts dpe = new DeveloperEcharts();
//		dpe.setDeveloper_id(1);
//		dpe.setJson_string("hello world");
//		dpe.setProject_id(2);
//		dpe.setRelease_id(3);
//		DaoFactory.getDeveloperEchartsDao().updateEcharts(dpe);
//		
//		Crawlindex ci = new Crawlindex();
//		ci.setComment_page(1);
//		ci.setCommit_page(1);
//		ci.setContributor_page(1);
//		ci.setIssue_page(1);
//		ci.setMilestone_page(1);
//		ci.setProject_id(1);
//		ci.setPullrequest_page(1);
//		ci.setRelease_idx(1);
//		ci.setRelease_page(1);
//		ci.setUpbrelease_page(1);
//		ci.setUser_page(1);
//		
//		
//		MetaDaoFactory.getCrawlindexDao().addCrawlindex(ci);
		
		entity.Project p = MetaDaoFactory.getProjectDao().getProject("spinfo", "java");
		
		System.out.println(p == null);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\TimerTask.java
package test;


import java.util.Timer;

public class TimerTask {
	Timer timer;
	Timer timer2;
	 public void setUp(){
	    	timer = new Timer();
	        timer.schedule(new CrawlTask(),
	               0,        //initial delay
	               5000); 
	    }
	 
	 public void setUp2(){
	    	timer2 = new Timer();
	        timer2.schedule(new CrawlTask2(),
	               0,        //initial delay
	               1000); 
	    }
	 
	 class CrawlTask extends java.util.TimerTask {
	    	    		 		
	    	    public void run() {
	            	System.out.println(111);            	
	            }
	    	}
	  
	 class CrawlTask2 extends java.util.TimerTask {
	 		
 	    public void run() {
         	System.out.println(222);            	
         }
 	}
	    	   
	    public static void main(String []args){
	    	TimerTask t = new TimerTask();
	    	t.setUp();
	    	t.setUp2();
	    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\TransformTest.java
package test;

import java.util.List;

import transform.MetaTransformImpl;
import util.Dates;

public class TransformTest {
	public static void main(String []args){
		TransformTest tt = new TransformTest();
		tt.testRate();
//		long t = Dates.dayDiffer("2014-11-01", "2014-12-05");
//		System.out.println(t);
	}
	
	
	public void testCommit(){
		MetaTransformImpl mm = new MetaTransformImpl();
		List<entity.UnPublishedRelease> ubsrs = mm.getAllUnPublishedRelease(4193864);
		List<usefuldata.Release> rs = mm.getCommitNumber(ubsrs, 4193864);
		for(int i = 0;i<rs.size();i++){
			System.out.print(rs.get(i).getName() + "  " + rs.get(i).getRelease_commits());
			System.out.println();
		}
	}
	
	public void testRate(){
		MetaTransformImpl mm = new MetaTransformImpl();
		List<entity.UnPublishedRelease> ubsrs = mm.getAllUnPublishedRelease(4193864);
		List<usefuldata.Release> rs = mm.getCommitNumber(ubsrs, 4193864);
		mm.getCommitRate(rs);
		for(int i = 0;i<rs.size();i++){
			System.out.print(rs.get(i).getName() + "  " + rs.get(i).getCommit_rate());
			System.out.println();
		}
		
	}
	
	public void testIssue(){
		MetaTransformImpl mm = new MetaTransformImpl();
		List<entity.UnPublishedRelease> ubsrs = mm.getAllUnPublishedRelease(4193864);
		List<usefuldata.Release> rs = mm.getCommitNumber(ubsrs, 4193864);
		mm.getIssueNum(rs, 4193864);
		for(int i = 0;i<rs.size();i++){
			System.out.print(rs.get(i).getName() + "  " +rs.get(i).getIssue_number() + "  " + rs.get(i).getId());
			System.out.println();
		}
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\UtilTest.java
package test;

import java.util.List;

import factory.DaoFactory;
import usefuldata.Release;
import util.Dates;

public class UtilTest {
	public static void main(String []args){
//		List<Release> rls = DaoFactory.getProjectDao().getAllReleases("mct");
//		//List<Release> sorted = Dates.releaseSort(rls);
//		for(int i = 0;i<rls.size();i++){
//			System.out.println(rls.get(i).getName());
//			System.out.println(rls.get(i).getDate());
//			System.out.println("---------------------");
//		}
		
		String ss = Dates.metaDateFormat("Tue Sep 03 23:12:18 CST 2013");
		
		System.out.println(ss);
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\test\XMLTest.java
package test;

import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import util.XMLHelper;

public class XMLTest {
	public static void main(String[] args)  
    {  
		XMLHelper xx = new XMLHelper();
		ArrayList<String> s = xx.DBInputXML("DBConfigure.xml");
		for(int i = 0;i<s.size();i++){
			System.out.println(s.get(i));
		}
		
		//System.out.println(a.size());
		
//        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();  
//        try  
//        {  
//            DocumentBuilder db = dbf.newDocumentBuilder();  
//            Document doc = db.parse("pet.xml");  
//  
//            NodeList dogList = doc.getElementsByTagName("dog");  
//            System.out.println("共有" + dogList.getLength() + "个dog节点");  
//            for (int i = 0; i < dogList.getLength(); i++)  
//            {  
//                Node dog = dogList.item(i);  
//                Element elem = (Element) dog;  
//                System.out.println("id:" + elem.getAttribute("id"));  
//                for (Node node = dog.getFirstChild(); node != null; node = node.getNextSibling())  
//                {  
//                    if (node.getNodeType() == Node.ELEMENT_NODE)  
//                    {  
//                        String name = node.getNodeName();  
//                        String value = node.getFirstChild().getNodeValue();  
//                        System.out.print(name + ":" + value + "\t");  
//                    }  
//                }  
//                System.out.println();  
//            }  
//        }  
//        catch (Exception e)  
//        {  
//            e.printStackTrace();  
//        }  
    }  
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\timer\MyServletContextListener.java
package timer;

//import javax.servlet.ServletContextEvent;
//import javax.servlet.ServletContextListener;

//import timer.Server;

/**
 * init server and conduct task
 * @author guanjun
 *
 */
public class MyServletContextListener{ //implements ServletContextListener {
 
//        public void contextInitialized(ServletContextEvent arg0) {
//        	Server server = new Server();
//        	server.setUp();
//        	
//        }
// 
//        public void contextDestroyed(ServletContextEvent sce) {
// 
//        }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\timer\Server.java
package timer;

import java.util.ArrayList;
import java.util.Timer;
import java.util.TimerTask;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import util.URLHelper;
import util.XMLHelper;
import metadao.MetaDaoController;
import metadao.MySQLController;
import analysis.AnalysisModule;
import analysis.BasicAnalysis;
import crawler.CrawlModule;
import crawler.DataSource;
import dao.DaoController;
import factory.MetaDaoFactory;

public class Server {
    Timer timer;
    Timer dbtimer;
    
    int task_period;
    
    final static Logger logger = LoggerFactory.getLogger(Server.class);
    
    public Server(){
    	super();
    }
    
    public void setUp(){
    	task_period = selectPeriod();
    	timer = new Timer();
        timer.schedule(new CrawlTask(),
               0,        //initial delay
               task_period); 
        
        dbtimer = new Timer();
        dbtimer.schedule(new DbTask(),86400000,86400000);
    }
    
    public int selectPeriod(){
    	XMLHelper xmlHelper = new XMLHelper();
		ArrayList<Integer> periods = xmlHelper.PeriodInputXML("configure.xml");		
    	return periods.get(0);
    }
    
    class DbTask extends TimerTask {

		@Override
		public void run() {
			ArrayList<String> finished = MetaDaoFactory.getGitURLDao().getURLNotCrawled("finished");
			for(int i = 0;i<finished.size();i++){
				MetaDaoFactory.getGitURLDao().changeState(finished.get(i), "ready");
			}
			
		}
    	
    	
    }
    
    class CrawlTask extends TimerTask {
    	
    	public void crawlAndAnalysis(String projectName,String owner,String filepath){
    			//get all metadata to server
    			DataSource dataSource = new CrawlModule(projectName,owner,filepath);
    			dataSource.getData();
        		
        		MetaDaoController metadaoController = new MySQLController(dataSource);
        		metadaoController.IntoDataBase();
        		logger.info("succeed saving metadata...");
        		
        		
        		AnalysisModule analysisModule = new BasicAnalysis(metadaoController);
        		analysisModule.analyzeAll();
        		logger.info("succeed analysising metadata...");
        		
        		
        		DaoController daoController = new DaoController(analysisModule);
        		daoController.IntoDataBase();
        		logger.info("succeed saving useful data...");       		
        		        		
        		//now some data already in database
        		//evolve will use some analyzed data 
        		analysisModule.invokeEvolveAnalysis();
        	
        		//finally evolve chart 
        		daoController.EvolveIntoDB(analysisModule.getEvolve_echarts());   		
    			
        		logger.info(owner + "'s " + projectName + " project all finished!");
    		}
    		 		
    	    public void run() {
            	String projectName,owner,filepath;
            	//nikolaypavlov,codahale,spinfo,bytedeco,pagseguro,riolet
            	//MLPNeuralNet,bcrypt-ruby,java,javacv,java,nope.c
            	          	
            	ArrayList<String> uncrawled = MetaDaoFactory.getGitURLDao().getURLNotCrawled("uncrawled");
            	ArrayList<String> unupdated = MetaDaoFactory.getGitURLDao().getURLNotCrawled("unupdated");
            	
            	for(int i = 0;i<uncrawled.size();i++){
            		owner = URLHelper.getProjectOwner(uncrawled.get(i));
                	projectName = URLHelper.getProjectName(uncrawled.get(i));
                	filepath = "Downloads/" + owner +"/";
                	crawlAndAnalysis(projectName,owner,filepath);
                	MetaDaoFactory.getGitURLDao().changeState(uncrawled.get(i), "unupdated");
            	}
            	
            	for(int i = 0;i<unupdated.size();i++){
            		owner = URLHelper.getProjectOwner(unupdated.get(i));
                	projectName = URLHelper.getProjectName(unupdated.get(i));
                	filepath = "Downloads/" + owner +"/";
                	crawlAndAnalysis(projectName,owner,filepath);
                	MetaDaoFactory.getGitURLDao().changeState(unupdated.get(i), "finished");
            	}
            	
            }
    	}
    	
    	   
    public static void main(String []args){
    	Server server = new Server();
    	server.setUp();
    	
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\tojson\VitalityToJson.java
package tojson;

import java.util.List;

import usefuldata.Vitality;

import com.google.gson.JsonObject;

public class VitalityToJson {

	public String ToJson(Vitality vitality) {
		JsonObject json = new JsonObject();
		json.addProperty("date", vitality.getDate());
		json.addProperty("number", vitality.getVitality());
		return json.toString();
	}

	public String ToJson(List<Vitality> vitalities) {
		String result = "";
		if(vitalities.size()!=1){
		result = "[";
		for(Vitality a :vitalities){
			String tmp = ToJson(a);
			result += tmp + ",";
		}
		
		result = (String) result.subSequence(0, result.length()-1);
		result += "]";}
		else{
			result = ToJson(vitalities.get(0));
		}
		return result;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\transform\MetaTransform.java
package transform;

import java.util.List;

import usefuldata.Release;
import entity.UnPublishedRelease;

public interface MetaTransform {
	
	//get all unsorted releases
	public List<entity.UnPublishedRelease> getAllUnPublishedRelease(int project_id);
	
	public List<Release> getCommitNumber(List<UnPublishedRelease> ubsrs,int project_id);
	
	//commit per day
	public List<Release> getCommitRate(List<Release> rel);
	
	public List<Release> getIssueNum(List<Release> rel,int project_id);
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\transform\MetaTransformImpl.java
package transform;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import usefuldata.Release;
import util.Dates;
import entity.UnPublishedRelease;
import factory.MetaDaoFactory;

public class MetaTransformImpl implements MetaTransform{

	@Override
	public List<UnPublishedRelease> getAllUnPublishedRelease(int project_id) {
		return MetaDaoFactory.getUnPublishedReleaseDao().getAllUnPublishedReleases(project_id);
	}

	@Override
	public List<Release> getCommitNumber(List<UnPublishedRelease> ubsrs,int project_id) {
		List<UnPublishedRelease> sorted_ubsr = Dates.unPublishedReleaseSort(ubsrs);
		
		List<Release> releases = new ArrayList<Release>();
		
		Map<String,String> release_date = new HashMap<String,String>();
		
		for(int i = 0;i<sorted_ubsr.size();i++){
			Release r = new Release();			
			r.setName(sorted_ubsr.get(i).getName());
			r.setDate(sorted_ubsr.get(i).getDate());
			r.setId(sorted_ubsr.get(i).getId());
			releases.add(r);
			release_date.put(r.getName(), r.getDate());
		}
		
		List<entity.Commit> commits = MetaDaoFactory.getCommitDao().getCommits(project_id);
		for(int i = 0;i<commits.size();i++){
			String date = Dates.dateToString(commits.get(i).getCommitDate());
			int idx = Dates.getDateIndex(date, release_date);
			if(idx >= releases.size())
				idx = releases.size() - 1;
			releases.get(idx).CommitsPlus();
		}
		
		return releases;
	}

	@Override
	public List<Release> getCommitRate(List<Release> rel) {
		for(int i = 0;i<rel.size()-1;i++){
			Release r = rel.get(i);
			String date1 = r.getDate();
			String date2 = rel.get(i+1).getDate();
			long diff_day = Dates.dayDiffer(date1, date2);
			double rate = diff_day/1.0;
			r.setCommit_rate(rate);
		}
		
		Release r = rel.get(rel.size() - 1);
		String date1 = r.getDate();
		String date2 = Dates.dateToString(new Date());
		long diff_day = Dates.dayDiffer(date1, date2);
		double rate = diff_day/7.0;
		r.setCommit_rate(rate);
		
		
		return rel;
	}

	@Override
	public List<Release> getIssueNum(List<Release> rel, int project_id) {
		Map<String,String> release_date = new HashMap<String,String>();
		for(int i = 0;i<rel.size();i++){		
			release_date.put(rel.get(i).getName(),rel.get(i).getDate());
		}
		List<entity.Issue> issues = MetaDaoFactory.getIssueDao().getAllMetaIssues(project_id);
		for(int i = 0;i<issues.size();i++){
			String date = Dates.dateToString(issues.get(i).getCreatedAt());
			int idx = Dates.getDateIndex(date, release_date);
			if(idx >= rel.size())
				idx = rel.size() - 1;
			
			rel.get(idx).issuePlus();
			
		}
				
		return rel;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\transform\VitalityTransform.java
package transform;

import java.util.ArrayList;
import java.util.List;

import entity.Commit;
import entity.Project;
import entity.User;
import usefuldata.Vitality;

public class VitalityTransform {
	public List<Vitality> transform(User user,Project project){
		List<Vitality> vitalities = new ArrayList<Vitality>();
		List<Commit> commits = user.getCommits();
		for(Commit commit:commits){
			if(commit.getProject().equals(project)){
				Vitality v = new Vitality();
				String s = v.dateTrim(commit.getCommitDate());
				v.setDate(s);
				v.setVitality(commit.getAdditionsCount());
				vitalities.add(v);
			}
		}
		
		
		return vitalities;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Comment.java
package usefuldata;

public class Comment {
	private int commentId;
	private String content;
	private String commentator;
	private String commitId;
	private String date;
	private String projectName;
	
	public int getCommentId() {
		return commentId;
	}
	public void setCommentId(int commentId) {
		this.commentId = commentId;
	}
	public String getContent() {
		return content;
	}
	public void setContent(String content) {
		this.content = content;
	}
	public String getCommentator() {
		return commentator;
	}
	public void setCommentator(String commentator) {
		this.commentator = commentator;
	}
	public String getCommitId() {
		return commitId;
	}
	public void setCommitId(String commitId) {
		this.commitId = commitId;
	}
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
	public String getProjectName() {
		return projectName;
	}
	public void setProjectName(String projectName) {
		this.projectName = projectName;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\CommitDate.java
package usefuldata;

/**
 *
 *存放所有commit记录
 *name为提交者的用户名
 *date 为提交时间
 *
 *@author Bacchus_yl
 */
public class CommitDate 
{
	private String name;
	private String date;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
	

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Developer.java
package usefuldata;

import java.util.List;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;

import com.google.gson.annotations.SerializedName;


@Entity("developers")
public class Developer {
	
	@SerializedName("id")
    @Indexed(unique=true, dropDups=true)
    @Id private int id;
	
	@SerializedName("login")
	private String login;
	
	@SerializedName("email")
	private String email;
	
	@SerializedName("html_url")
	private String url;
	
	@Reference
	private List<Vitality> vitalities;	
	
	public Developer(){
		super();
	}

	
	
	public Developer(int id, String login,String email,String url, List<Vitality> vitalities) {
		super();
		this.id = id;
		this.login = login;
		this.vitalities = vitalities;
		this.email = email;
		this.url = url;
	}



	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getLogin() {
		return login;
	}

	public void setLogin(String login) {
		this.login = login;
	}

	public List<Vitality> getVitalities() {
		return vitalities;
	}

	public void setVitalities(List<Vitality> vitalities) {
		this.vitalities = vitalities;
	}



	public String getEmail() {
		return email;
	}



	public void setEmail(String email) {
		this.email = email;
	}



	public String getUrl() {
		return url;
	}



	public void setUrl(String url) {
		this.url = url;
	}

	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\DeveloperEcharts.java
package usefuldata;

public class DeveloperEcharts {
	private int developer_id;
	private int project_id;
	private int release_id;
	private String json_string;
	
	public DeveloperEcharts(){
		super();
	}
	
	public DeveloperEcharts(int developer_id, int project_id,
			int release_id, String json_string) {
		super();
		this.developer_id = developer_id;
		this.project_id = project_id;
		this.release_id = release_id;
		this.json_string = json_string;
	}

	public int getDeveloper_id() {
		return developer_id;
	}
	public void setDeveloper_id(int developer_id) {
		this.developer_id = developer_id;
	}
	public int getProject_id() {
		return project_id;
	}
	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	public int getRelease_id() {
		return release_id;
	}
	public void setRelease_id(int release_id) {
		this.release_id = release_id;
	}
	public String getJson_string() {
		return json_string;
	}
	public void setJson_string(String json_string) {
		this.json_string = json_string;
	}
	
	public String toString(){
		return  " developer_id" + developer_id + " project_id" + project_id
				+ " release_id" + release_id + " json_string" + json_string;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\EvolveEcharts.java
package usefuldata;

public class EvolveEcharts {
	private int project_id;
	private int release_id;
	private String json_string;
	
	public EvolveEcharts(){
		super();
	}
	
	public EvolveEcharts(int project_id, int release_id,
			String json_string) {
		this.project_id = project_id;
		this.release_id = release_id;
		this.json_string = json_string;
	}
	
	public int getProject_id() {
		return project_id;
	}
	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	public int getRelease_id() {
		return release_id;
	}
	public void setRelease_id(int release_id) {
		this.release_id = release_id;
	}
	public String getJson_string() {
		return json_string;
	}
	public void setJson_string(String json_string) {
		this.json_string = json_string;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\ForceEcharts.java
package usefuldata;

public class ForceEcharts {
	private int project_id;
	private int release_id;
	private String relation;
	private String main_relation;
	
	public ForceEcharts(){
		super();
	}
	
	public ForceEcharts(int project_id, int release_id, String relation,
			String main_relation) {
		super();
		this.project_id = project_id;
		this.release_id = release_id;
		this.relation = relation;
		this.main_relation = main_relation;
	}
	public int getProject_id() {
		return project_id;
	}
	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	public int getRelease_id() {
		return release_id;
	}
	public void setRelease_id(int release_id) {
		this.release_id = release_id;
	}
	public String getRelation() {
		return relation;
	}
	public void setRelation(String relation) {
		this.relation = relation;
	}
	public String getMain_relation() {
		return main_relation;
	}
	public void setMain_relation(String main_relation) {
		this.main_relation = main_relation;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Issue.java
package usefuldata;

import java.util.ArrayList;

public class Issue {
	private int issueId;
	private String injectedDate;
	private ArrayList<String> updateDate;
    private String state;
    
	public int getIssueId() {
		return issueId;
	}
	public void setIssueId(int issueId) {
		this.issueId = issueId;
	}
	public String getInjectedDate() {
		return injectedDate;
	}
	public void setInjectedDate(String injectedDate) {
		this.injectedDate = injectedDate;
	}
	public ArrayList<String> getUpdateDate() {
		return updateDate;
	}
	public void setUpdateDate(ArrayList<String> updateDate) {
		this.updateDate = updateDate;
	}
	public String getState() {
		return state;
	}
	public void setState(String state) {
		this.state = state;
	}
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Link.java
package usefuldata;

/**
 * 
 * @author Bacchus_yl
 * 表示node 间关联
 */
public class Link {
	private int source;
	private int target;

	public Link(int i, int j) {
		// TODO Auto-generated constructor stub
		source=i;
		target=j;
	}

	public int getSource() {
		return source;
	}

	public void setSource(int source) {
		this.source = source;
	}

	public int getTarget() {
		return target;
	}

	public void setTarget(int target) {
		this.target = target;
	}

}


C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Movement.java
package usefuldata;

/**
 * 
 * @author Bacchus_yl
 * 表示用户迁移状况
 *name为开发者用语名
 *move表示 进入莒南迁出（leave or join）
 *date 表示迁移时间
 *leave:某次版本开发用户没有参加，以上一版本最后一次提交时间记
 *join:第一次提交或者move状态变为leave后的第一次提交时间记
 */

public class Movement 
{
	private String name;
    private String move;
    private String date;

	public String getMove() {
		return move;
	}
	public void setMove(String move) {
		this.move = move;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
    

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Node.java
package usefuldata;

/**
 * 
 * @author Bacchus_yl
 *size:开发者贡献度，可能为整个project也可能只是某次release
 *name:开发者用户名
 */
public class Node 
{
	private int size;
	private String name;

	public Node(String name, int size) 
	{
		// TODO Auto-generated constructor stub
	this.size=size;
	this.name=name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getSize() {
		return size;
	}

	public void setSize(int size) {
		this.size = size;
	}
	
}

C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\PackageNode.java
package usefuldata;

import java.util.ArrayList;
import java.util.List;

public class PackageNode {
	private List<PackageNode> children = new ArrayList<PackageNode>();
	private List<Integer> childrenIndex = new ArrayList<Integer>();
	private String path;
	private String name;

	public PackageNode(String path, String name) {
		super();
		this.setName(name);
		this.setPath(path);
	}


	public void setPath(String path) {
		this.path = path;
	}
	
	public String getName() {
		return name;
	}

	public List<PackageNode> getChildren() {
		return children;
	}

	public void setChildren(List<PackageNode> children) {
		this.children = children;
	}
    public List<Integer> takeCIndex()
    {
    	return childrenIndex;
    }

	public void addChild(int i) {
		childrenIndex.add(i);
	}	

	public void addChild(PackageNode pn) {
		children.add(pn);
	}

	

	public void setName(String name) {
		this.name = name;
	}

	public String takePath() {
		return path;
	}


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Project.java
package usefuldata;

import java.util.HashMap;
import java.util.List;

import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Indexed;
import org.mongodb.morphia.annotations.Reference;

import com.google.gson.annotations.SerializedName;

@Entity("project")
public class Project {
	
	@SerializedName("id")
	@Indexed(unique=true, dropDups=true)
	@Id private int id;
	
	@SerializedName("name")
	private String name;
	
	@SerializedName("codes")
	private int codes;
	
	
	@SerializedName("login")
	private String owner;
	
	@SerializedName("description")
	private String description;
	
	@Reference
	private List<Developer> developpers;
	
	@Reference
	private List<Release> releases;
	
	@Reference
	private HashMap<Integer,Integer> contributions;
	
	public Project(){
		super();
	}

	

	public Project(int id, String name, int codes, String owner,
			String description,
			List<Developer> developpers, List<Release> releases,
			HashMap<Integer, Integer> contributions) {
		super();
		this.id = id;
		this.name = name;
		this.codes = codes;
		this.owner = owner;
		this.description = description;
		this.developpers = developpers;
		this.releases = releases;
		this.contributions = contributions;
	}



	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getCodes() {
		return codes;
	}

	public void setCodes(int codes) {
		this.codes = codes;
	}


	public List<Developer> getDeveloppers() {
		return developpers;
	}

	public void setDeveloppers(List<Developer> developpers) {
		this.developpers = developpers;
	}

	public List<Release> getReleases() {
		return releases;
	}

	public void setReleases(List<Release> releases) {
		this.releases = releases;
	}

	public HashMap<Integer, Integer> getContributions() {
		return contributions;
	}

	public void setContributions(HashMap<Integer, Integer> contributions) {
		this.contributions = contributions;
	}



	public String getOwner() {
		return owner;
	}



	public void setOwner(String owner) {
		this.owner = owner;
	}



	public String getDescription() {
		return description;
	}



	public void setDescription(String description) {
		this.description = description;
	}
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\ProjectContribution.java
package usefuldata;

public class ProjectContribution {
	private int project_id;
	private int developer_id;
	private int contributions;
	private String projectName;
	
	
	public ProjectContribution(){
		super();
	}

	public ProjectContribution(int project_id, int developer_id,
			int contributions,String projectName) {
		super();
		this.project_id = project_id;
		this.developer_id = developer_id;
		this.contributions = contributions;
		this.projectName = projectName;
	}

	public int getProject_id() {
		return project_id;
	}

	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}

	public int getDeveloper_id() {
		return developer_id;
	}

	public void setDeveloper_id(int developer_id) {
		this.developer_id = developer_id;
	}

	public int getContributions() {
		return contributions;
	}

	public void setContributions(int contributions) {
		this.contributions = contributions;
	}

	public String getProjectName() {
		return projectName;
	}

	public void setProjectName(String projectName) {
		this.projectName = projectName;
	}
	
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Radar.java
package usefuldata;

/**
 * 
 * @author Bacchus_yl
 * 用以存放单位雷达图数据的实体
 *axis:issue  or comment or codes or developers or commit
 *value:axis对应的值
 */
public class Radar 
{
	private String axis;
	private int value;
	public Radar(String axis,int i)
	{
		this.setAxis(axis);
		this.value=i;
	}
	public int getValue() {
		return value;
	}
	public void setValue(int value) {
		this.value = value;
	}
	public String getAxis() {
		return axis;
	}
	public void setAxis(String axis) {
		this.axis = axis;
	}
	
	

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Release.java
package usefuldata;

import java.util.HashMap;
import java.util.List;

public class Release {
	private int id;
	private String name;
	private int codes;
	private int project_id;
	private String date;
	private int release_commits;
	private int document;
	private int test;
	private double commit_rate;
	private int issue_number;
	private int comprehensive;
	
	private List<Developer> developpers;
	
	//map with developer_id and contributions
	private HashMap<Integer,Integer> contributions;
	
	public Release(){
		super();
	}

	public Release(int id, String name, int codes,
			List<Developer> developpers,
			HashMap<Integer, Integer> contributions,
			String date,
			int release_commits) {
		super();
		this.id = id;
		this.name = name;
		this.codes = codes;
		this.developpers = developpers;
		this.contributions = contributions;
		this.date = date;
		this.release_commits = release_commits;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getCodes() {
		return codes;
	}

	public void setCodes(int codes) {
		this.codes = codes;
	}



	public List<Developer> getDeveloppers() {
		return developpers;
	}

	public void setDeveloppers(List<Developer> developpers) {
		this.developpers = developpers;
	}

	public HashMap<Integer, Integer> getContributions() {
		return contributions;
	}

	public void setContributions(HashMap<Integer, Integer> contributions) {
		this.contributions = contributions;
	}

	public String getDate() {
		return date;
	}

	public void setDate(String date) {
		this.date = date;
	}

	public int getRelease_commits() {
		return release_commits;
	}

	public void setRelease_commits(int release_commits) {
		this.release_commits = release_commits;
	}

	public int getDocument() {
		return document;
	}

	public void setDocument(int document) {
		this.document = document;
	}

	public int getTest() {
		return test;
	}

	public void setTest(int test) {
		this.test = test;
	}

	public double getCommit_rate() {
		return commit_rate;
	}

	public void setCommit_rate(double commit_rate) {
		this.commit_rate = commit_rate;
	}

	public int getIssue_number() {
		return issue_number;
	}

	public void setIssue_number(int issue_number) {
		this.issue_number = issue_number;
	}

	public int getComprehensive() {
		return comprehensive;
	}

	public void setComprehensive(int comprehensive) {
		this.comprehensive = comprehensive;
	}
	
	public void CommitsPlus(){
		this.release_commits++;
	}
	
	public void issuePlus(){
		this.issue_number++;
	}

	public int getProject_id() {
		return project_id;
	}

	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\ReleaseContribution.java
package usefuldata;

public class ReleaseContribution {
	private String releaseName;
	private int contributions;
	
	/**
	 * 
	 */
	private int release_id;
	private int developer_id;
	private int project_id;
	
	public ReleaseContribution(){
		super();
	}

	
	
	public ReleaseContribution(String releaseName, int contributions) {
		super();
		this.releaseName = releaseName;
		this.contributions = contributions;
	}


	public String getReleaseName() {
		return releaseName;
	}



	public void setReleaseName(String releaseName) {
		this.releaseName = releaseName;
	}



	public int getContributions() {
		return contributions;
	}

	public void setContributions(int contributions) {
		this.contributions = contributions;
	}



	public int getRelease_id() {
		return release_id;
	}



	public void setRelease_id(int release_id) {
		this.release_id = release_id;
	}



	public int getDeveloper_id() {
		return developer_id;
	}



	public void setDeveloper_id(int developer_id) {
		this.developer_id = developer_id;
	}



	public int getProject_id() {
		return project_id;
	}



	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\ReleaseEcharts.java
package usefuldata;

public class ReleaseEcharts {
	private int project_id;
	private int release_id;
	private String json_string;
	private String main_json; //better not use this
		
	public String getMain_json() {
		return main_json;
	}
	public void setMain_json(String main_json) {
		this.main_json = main_json;
	}
	public ReleaseEcharts(int project_id, int release_id,
			String json_string) {
		super();
		this.project_id = project_id;
		this.release_id = release_id;
		this.json_string = json_string;
	}

	public int getProject_id() {
		return project_id;
	}
	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	public int getRelease_id() {
		return release_id;
	}
	public void setRelease_id(int release_id) {
		this.release_id = release_id;
	}
	public String getJson_string() {
		return json_string;
	}
	public void setJson_string(String json_string) {
		this.json_string = json_string;
	}
	public ReleaseEcharts(int project_id, int release_id,
			String json_string, String main_json) {
		super();
		this.project_id = project_id;
		this.release_id = release_id;
		this.json_string = json_string;
		this.main_json = main_json;
	}
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Version.java
package usefuldata;

import java.util.ArrayList;
import java.util.List;
 /**
  * 
  * @author Bacchus_ly
  * name:release name
  * date: 版本发布时间
  * radar：存放雷达图数据
  */
public class Version 
{
	private String name;
	private String date;
	private List<List<Radar>> radar=new ArrayList<List<Radar>>();
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
	public List<List<Radar>> getRadar() {
		return radar;
	}
	public void setRadar(List<List<Radar>> radarlist) {
		this.radar = radarlist;
	}

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\VersionDate.java
package usefuldata;

/**
 * @author Bacchus_yl
 * 
 * version:release name
 * date:版本发布时间
 * order:是发布的第几个版本
 *
 */
public class VersionDate 
{
	private String version;//版本名称
	private String date;//发布时间
	private int order;//是第几个版本
	public String getVersion() {
		return version;
	}
	public void setVersion(String version) {
		this.version = version;
	}
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
	public int getOrder() {
		return order;
	}
	public void setOrder(int order) {
		this.order = order;
	}

}

C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\usefuldata\Vitality.java
package usefuldata;

import java.text.SimpleDateFormat;
import java.util.Date;


public class Vitality {
	
    private int id;
	
	private String date;
	
	private int vitality;
	
	private int developer_id;
	
	private int project_id;
	
	private int release_id;


	public Vitality(){
		super();
	}
	
	
	public Vitality(int id, String date, int vitality,
			int developer_id,int project_id,int release_id) {
		super();
		this.id = id;
		this.date = date;
		this.vitality = vitality;
		this.developer_id = developer_id;
		this.project_id = project_id;
		this.release_id = release_id;
		
	}

	public int getVitality() {
		return vitality;
	}
	public void setVitality(int vitality) {
		this.vitality = vitality;
	}
	
	
	public String getDate() {
		return date;
	}
	public void setDate(String date) {
		this.date = date;
	}
	
	

	public int getId() {
		return id;
	}


	public void setId(int id) {
		this.id = id;
	}


	public String dateTrim(Date date){
		SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");    
		String result=sdf.format(date);  
		return result;
	}
		

	public String toString(){
		return "date:" + date + ",number:" + vitality;
	}


	public int getRelease_id() {
		return release_id;
	}


	public void setRelease_id(int release_id) {
		this.release_id = release_id;
	}


	public int getDeveloper_id() {
		return developer_id;
	}


	public void setDeveloper_id(int developer_id) {
		this.developer_id = developer_id;
	}


	public int getProject_id() {
		return project_id;
	}


	public void setProject_id(int project_id) {
		this.project_id = project_id;
	}
	
	
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\util\Dates.java
package util;

import helper.QuickSort;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import entity.UnPublishedRelease;
import usefuldata.Release;

/**
 * Helper class to deal with dates
 * 
 * 
 */
public class Dates {

	private SimpleDateFormat simpleDateFormat;

	public Dates() {
		simpleDateFormat = new SimpleDateFormat();
	}

	public Dates(String pattern) {
		simpleDateFormat = new SimpleDateFormat(pattern);
	}

	public String format(Date date) {
		return simpleDateFormat.format(date);
	}

	public Date format(String date) {
		try {
			return simpleDateFormat.parse(date);
		} catch (ParseException e) {
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * trim date like 2012-06-30T20:18:25Z to 2012-06-30
	 * @param unformatedDates
	 * @return
	 */
	public static Map<String,String> dateFormat(Map<String,String> unformatedDates){
		Set<String> keys = unformatedDates.keySet();
		Map<String,String> results = new HashMap<String,String>();
		
		for(String name:keys){
			String date = unformatedDates.get(name);
			String formatedDate = date.substring(0, 10);
			results.put(name, formatedDate);
		}
			
		return results;
	}
	
	public static String dateFormat(String unformatedDate){
		return unformatedDate.substring(0, 10);
	}
	
	/**
	 * 
	 * @param unSortedDates
	 * @return ArrayList<String> with sorted tagNames
	 */
	public static ArrayList<String> dateSort(Map<String,String> unSortedDates){
		Map<String,String> tmp = dateFormat(unSortedDates);
		
		List<Map.Entry<String, String>> infoIds = new ArrayList<Map.Entry<String, String>>(  
		        tmp.entrySet()); 
		
		Collections.sort(infoIds, new Comparator<Map.Entry<String, String>>() {  
		    public int compare(Map.Entry<String, String> o1,  
		            Map.Entry<String, String> o2) {  
		        String s1 = o1.getValue();
		        String s2 = o2.getValue();
		    	if(s1.equals(s2))
		    		return 0;
		    	else{
		    		int year1 = Integer.parseInt(s1.substring(0, 4));
		    		int year2 = Integer.parseInt(s2.substring(0, 4));
		    		int month1 = Integer.parseInt(s1.substring(5, 7));
		    		int month2 = Integer.parseInt(s2.substring(5, 7));
		    		int day1 = Integer.parseInt(s1.substring(8, 10));
		    		int day2 = Integer.parseInt(s2.substring(8, 10));
		    		
		    		if(year1 < year2)
		    			return -1;
		    		else if(year1 > year2)
		    			return 1;
		    		else{
		    			//year is the same
		    			if(month1 < month2)
		    				return -1;
		    			else if(month1 > month2)
		    				return 1;
		    			else{
		    				//year and month is the same
		    				if(day1 < day2)
		    					return -1;
		    				else if(day1 > day2)
		    					return 1;
		    				else
		    					return 0;
		    			}
		    		}
		    	}
		        
		    }  
		});  
		
		ArrayList<String> results = new ArrayList<String>();
		for (int i = 0; i < infoIds.size(); i++) {  
		    Entry<String,String> ent=infoIds.get(i);  		    
		    results.add(ent.getKey());
		}  
		
		return results;
	}
	
	
	//<tagName,date>
	public static int getDateIndex(String unformated_date,Map<String,String> release_date){
		String formated_date = unformated_date.substring(0, 10);
		ArrayList<String> sorted_dates = dateSort(release_date);
		
		String tmp_date = null;
		for(int i = 0;i<sorted_dates.size();i++){
			tmp_date = sorted_dates.get(i);
			if (compare_date(formated_date,release_date.get(tmp_date)) <=0){
				return i;
			}
			
		}
		
		return sorted_dates.size();
	}
	
	/**
	 * if date1 < date2 return -1
	 * if date1 == date2 return 0
	 * if date1 > date2 return 1
	 * @param date1
	 * @param date2
	 * @return
	 */
	public static int compare_date(String date1,String date2){
	    	if(date1.equals(date2))
	    		return 0;
	    	else{
	    		int year1 = Integer.parseInt(date1.substring(0, 4));
	    		int year2 = Integer.parseInt(date2.substring(0, 4));
	    		int month1 = Integer.parseInt(date1.substring(5, 7));
	    		int month2 = Integer.parseInt(date2.substring(5, 7));
	    		int day1 = Integer.parseInt(date1.substring(8, 10));
	    		int day2 = Integer.parseInt(date2.substring(8, 10));
	    		
	    		if(year1 < year2)
	    			return -1;
	    		else if(year1 > year2)
	    			return 1;
	    		else{
	    			//year is the same
	    			if(month1 < month2)
	    				return -1;
	    			else if(month1 > month2)
	    				return 1;
	    			else{
	    				//year and month is the same
	    				if(day1 < day2)
	    					return -1;
	    				else if(day1 > day2)
	    					return 1;
	    				else
	    					return 0;
	    			}
	    		}
	    	}
	        
	    }  
	
	
	public static List<Release> releaseSort(List<Release> unsorted_release){
		String[] dates= new String[unsorted_release.size()];
		for(int i = 0;i<unsorted_release.size();i++){
			String date = unsorted_release.get(i).getDate();
			dates[i] = date;
		}
		
		QuickSort.qsort(dates);
		List<Release> results = new ArrayList<Release>();
		
		for(int j = 0;j<dates.length;j++){
			for(int i =0;i<unsorted_release.size();i++){
				if(dates[j].equals(unsorted_release.get(i).getDate())){
					results.add(unsorted_release.get(i));
					break;
				}
			}
				
		}
		
		return results;
	}
	
	public static String metaDateFormat(String date){
		//"Fri Sep 21 21:43:26 CST 2012";
		String []months = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
		String result;
		try{
		String year = date.substring(24);// 2012
		String month = date.substring(4, 7);
		
		for(int i =0;i<months.length;i++){
			
			if(months[i].equals(month)){
				
				int idx = i + 1;
				if(idx<10){
					month = "0" + idx;
				}
				else
					month = "" + idx;
			}
				
		}
		
		String day = date.substring(8, 10);
		result = year + "-" + month + "-" + day;
		return result;
		
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return null;
	}
	
	public static List<UnPublishedRelease> unPublishedReleaseSort(List<UnPublishedRelease> unsorted_release){
		String[] dates= new String[unsorted_release.size()];
		for(int i = 0;i<unsorted_release.size();i++){
			String date = unsorted_release.get(i).getDate();
			dates[i] = date;
			
		}
		
		QuickSort.qsort(dates);
		
		List<UnPublishedRelease> results = new ArrayList<UnPublishedRelease>();
		
		
		for(int j = 0;j<dates.length;j++){
			
			for(int i =0;i<unsorted_release.size();i++){
				if(dates[j].equals(unsorted_release.get(i).getDate())){
					results.add(unsorted_release.get(i));
					break;
				}
			}
				
		}
		
		return results;
	}
	
	public static String dateToString(Date date){
		   SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd");
		   return df.format(date);
	}
	
	public static Date stringToDate(String date){
		if(date.equals("")){
			return null;
		}
		
		SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");  
		try{
			java.util.Date result=sdf.parse(date);
			return result;
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return null;
	}
	
	
	public static long dayDiffer(String date1,String date2){
		SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");  
		try{
			java.util.Date da1=sdf.parse(date1);
			java.util.Date da2=sdf.parse(date2);
			Calendar cal1=Calendar.getInstance();
			Calendar cal2=Calendar.getInstance();
			
			cal1.setTime(da1);
			cal2.setTime(da2);
			
			long timeNow=cal1.getTimeInMillis();
			long timeOld=cal2.getTimeInMillis();
			
			long tt =(timeNow-timeOld)/(1000*60*60*24);//化为天
			
			return Math.abs(tt);
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return -1;
	}
	
	/**
	 * judges if a commit belongs to a certain release
	 * using date to judge
	 * @return
	 */
	public static boolean BelongToRelease(String commit_date,String release_date,List<String> all_dates){
		Collections.sort(all_dates, new Comparator<String>(){
			@Override
			public int compare(String str1, String str2) {
				return compare_date(str1,str2);
			}
		});
		
		for(int i = 0;i<all_dates.size();i++){
			if(release_date.equals(all_dates.get(i))){
				if(i == all_dates.size()-1){
					if(compare_date(commit_date,all_dates.get(i))>0)
						return true;
				}
				else{
					if(compare_date(commit_date,all_dates.get(i))>=0 && compare_date(commit_date,all_dates.get(i+1))<=0)
						return true;
				}
			}
		}
		
		return false;
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\util\FileHelper.java
package util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;

public class FileHelper {
	
	public static void readTxtFile(String filePath){
        try {
                String encoding="utf-8";
                File file=new File(filePath);
                if(file.isFile() && file.exists()){ //判断文件是否存在
                    InputStreamReader read = new InputStreamReader(
                    new FileInputStream(file),encoding);//考虑到编码格式
                    BufferedReader bufferedReader = new BufferedReader(read);
                    String lineTxt = null;
                    while((lineTxt = bufferedReader.readLine()) != null){
                        System.out.println(lineTxt);
                    }
                    read.close();
        }else{
            System.out.println("file not found");
        }
        } catch (Exception e) {
            System.out.println("failure to read");
            e.printStackTrace();
        }
     
    }
   
	 /** 
	  * delete dir and files within
	  *  
	  * @param dir 
	  *            
	  * @return 
	  */  
	 public static boolean deleteDirectory(String dir) {  
	   
	  if (!dir.endsWith(File.separator))  
	   dir = dir + File.separator;  
	  File dirFile = new File(dir);  
	  
	  if ((!dirFile.exists()) || (!dirFile.isDirectory())) {  
	   System.out.println("delete failure：" + dir + "not exist！");  
	   return false;  
	  }  
	  boolean flag = true;  
	  
	  File[] files = dirFile.listFiles();  
	  for (int i = 0; i < files.length; i++) {  
	   
	   if (files[i].isFile()) {  
	    flag = FileHelper.deleteFile(files[i].getAbsolutePath());  
	    if (!flag)  
	     break;  
	   }  
	    
	   else if (files[i].isDirectory()) {  
	    flag = FileHelper.deleteDirectory(files[i]  
	      .getAbsolutePath());  
	    if (!flag)  
	     break;  
	   }  
	  }  
	  if (!flag) {  
	   System.out.println("delete dir failure");  
	   return false;  
	  }  
	  
	  if (dirFile.delete()) {  
	   //System.out.println("delete" + dir + " succeed");  
	   return true;  
	  } else {  
	   return false;  
	  }  
	 }  
	
	 /** 
	  * delete single file
	  *  
	  * @param fileName 
	  *            
	  * @return 
	  */  
	 public static boolean deleteFile(String fileName) {  
	  File file = new File(fileName);  
	   
	  if (file.exists() && file.isFile()) {  
	   if (file.delete()) {  
	    //System.out.println("delete single file" + fileName + " succeed");  
	    return true;  
	   } else {  
	    System.out.println("delete single file" + fileName + " failure");  
	    return false;  
	   }  
	  } else {  
	   System.out.println("delete single file" + fileName + " not exist");  
	   return false;  
	  }  
	 }  
	 
	 public static void main(String argv[]){
	        String filePath = "integer.txt";
	        readTxtFile(filePath);
	    }
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\util\URLHelper.java
package util;

public class URLHelper {

	public static String getProjectName(String URL){
		String[] a= URL.split("/");		
		return a[a.length-1];
	}
	
	public static String getProjectOwner(String URL){
		String[] a= URL.split("/");		
		return a[a.length-2];
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\util\XMLHelper.java
package util;

import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XMLHelper {
	
	public ArrayList<Integer> PeriodInputXML(String filepath){
		ArrayList<Integer> task_period = new ArrayList<Integer>();
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();  
        try  
        {  
            DocumentBuilder db = dbf.newDocumentBuilder();  
            Document doc = db.parse(filepath);  
  
            NodeList rateList = doc.getElementsByTagName("rate");  
            //System.out.println("共有" + rateList.getLength() + "个dbRate节点");  
            for (int i = 0; i < rateList.getLength(); i++)  
            {  
                Node rate = rateList.item(i);  
                //Element elem = (Element) rate;  
                //System.out.println("id:" + elem.getAttribute("id"));  
                for (Node node = rate.getFirstChild(); node != null; node = node.getNextSibling())  
                {  
                    if (node.getNodeType() == Node.ELEMENT_NODE)  
                    {  
                        //String name = node.getNodeName();  
                        String value = node.getFirstChild().getNodeValue();  
                        task_period.add(Integer.parseInt(value));
                        //System.out.print(name + ":" + value + "\t");  
                    }  
                }  
                //System.out.println();  
            }  
            
        }  
        catch (Exception e)  
        {  
            e.printStackTrace();  
        }
		
        return task_period;  
		
	}
	
	
	public ArrayList<String> DBInputXML(String filepath){
		ArrayList<String> configures = new ArrayList<String>();
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();  
        try  
        {  
            DocumentBuilder db = dbf.newDocumentBuilder();  
            Document doc = db.parse(filepath);  
  
            NodeList dbList = doc.getElementsByTagName("DataBase");  
            //System.out.println("共有" + rateList.getLength() + "个dbRate节点");  
            for (int i = 0; i < dbList.getLength(); i++)  
            {  
                Node dataNode = dbList.item(i);  
                //Element elem = (Element) rate;  
                //System.out.println("id:" + elem.getAttribute("id"));  
                for (Node node = dataNode.getFirstChild(); node != null; node = node.getNextSibling())  
                {  
                    if (node.getNodeType() == Node.ELEMENT_NODE)  
                    {  
                        //String name = node.getNodeName();  
                        String value = node.getFirstChild().getNodeValue();  
                        if(value.equals("null"))
                        	value = "";
                        configures.add(value);
                        //System.out.print(name + ":" + value + "\t");  
                    }  
                }  
                //System.out.println();  
            }  
            
        }  
        catch (Exception e)  
        {  
            e.printStackTrace();  
        }
		
        return configures;  
		
	}
	
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\GitCrawler\src\util\ZipFiles.java
package util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipFiles {
    
    List<String> filesListInDir = new ArrayList<String>();

    private String source;
    private String destination;
    
    public ZipFiles(String source,String destination){
    	this.source = source;
    	this.destination = destination;
    }
    
    public void ZipZup(){
    	File dir = new File(source);
    	zipDirectory(dir,destination);
    }
    
    public static void main(String[] args) {
        File file = new File("abcde");
        //String zipFileName = "/Users/pankaj/sitemap.zip";
        
        //File dir = new File("Downloads/codahale");
        //String zipDirName = "tmp.zip";
        
        //zipSingleFile(file, zipFileName);
        
        ZipFiles zipFiles = new ZipFiles("Downloads/codahale","tmp.zip");
        zipFiles.ZipZup();
        
        zipFiles.recursiveDelete(file);
    }

    public List<String> getFilesListInDir() {
		return filesListInDir;
	}


	public void setFilesListInDir(List<String> filesListInDir) {
		this.filesListInDir = filesListInDir;
	}


	public String getSource() {
		return source;
	}


	public void setSource(String source) {
		this.source = source;
	}


	public String getDestination() {
		return destination;
	}


	public void setDestination(String destination) {
		this.destination = destination;
	}


	/**
     * This method zips the directory
     * @param dir
     * @param zipDirName
     */
    private void zipDirectory(File dir, String zipDirName) {
        try {
            populateFilesList(dir);
            //now zip files one by one
            //create ZipOutputStream to write to the zip file
            FileOutputStream fos = new FileOutputStream(zipDirName);
            ZipOutputStream zos = new ZipOutputStream(fos);
            for(String filePath : filesListInDir){
                //System.out.println("Zipping "+filePath);
                //for ZipEntry we need to keep only relative file path, so we used substring on absolute path
                ZipEntry ze = new ZipEntry(filePath.substring(dir.getAbsolutePath().length()+1, filePath.length()));
                zos.putNextEntry(ze);
                //read the file and write to ZipOutputStream
                FileInputStream fis = new FileInputStream(filePath);
                byte[] buffer = new byte[1024];
                int len;
                while ((len = fis.read(buffer)) > 0) {
                    zos.write(buffer, 0, len);
                }
                zos.closeEntry();
                fis.close();
            }
            zos.close();
            fos.close();
            System.out.println("Zipping finished!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * This method populates all the files in a directory to a List
     * @param dir
     * @throws IOException
     */
    private void populateFilesList(File dir) throws IOException {
        File[] files = dir.listFiles();
        for(File file : files){
            if(file.isFile()) filesListInDir.add(file.getAbsolutePath());
            else populateFilesList(file);
        }
    }

//    /**
//     * This method compresses the single file to zip format
//     * @param file
//     * @param zipFileName
//     */
//    private static void zipSingleFile(File file, String zipFileName) {
//        try {
//            //create ZipOutputStream to write to the zip file
//            FileOutputStream fos = new FileOutputStream(zipFileName);
//            ZipOutputStream zos = new ZipOutputStream(fos);
//            //add a new Zip Entry to the ZipOutputStream
//            ZipEntry ze = new ZipEntry(file.getName());
//            zos.putNextEntry(ze);
//            //read the file and write to ZipOutputStream
//            FileInputStream fis = new FileInputStream(file);
//            byte[] buffer = new byte[1024];
//            int len;
//            while ((len = fis.read(buffer)) > 0) {
//                zos.write(buffer, 0, len);
//            }
//            
//            //Close the zip entry to write to zip file
//            zos.closeEntry();
//            //Close resources
//            zos.close();
//            fis.close();
//            fos.close();
//            System.out.println(file.getCanonicalPath()+" is zipped to "+zipFileName);
//            
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//
//    }

    public void recursiveDelete(File file) {
        if (!file.exists())
            return;
        if (file.isDirectory()) {
            for (File f : file.listFiles()) {
                recursiveDelete(f);
            }
        }
        file.delete();
    }
    
}
