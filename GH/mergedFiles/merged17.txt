C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Backend\GameData.java
package Backend;

import Builders.*;
import GameMap.GameMap;
import Placement.Player;
import StateMachine.StateManager.StateManager;
import asciiPanel.AsciiFont;
import asciiPanel.AsciiPanel;

/**
 * Created by evanputnam on 8/19/17.
 */
public class GameData {

    /**
     * Constant for width of game(not counting menu);
     */
    public static final int X_WIDTH = 60;

    /**
     * Constant for height of game(not counting menu);
     */
    public static final int Y_HEIGHT = 30;

    /**
     * Offset x-value for the stats menu
     */
    public static final int STATS_X_OFFSET = 20;

    /**
     * World size is X_WIDTH * Y_HEIGHT;
     */
    public static final int WORLD_SIZE = X_WIDTH * Y_HEIGHT;

    /**
     * Some name for the game
     */
    public static final String GAME_NAME = "Rouge-Lite Crawler";


    /**
     * Map object that holds information about the map of the game
     */
    private GameMap gameMap;






    /**
     * Armor builder class
     */
    private ArmorBuilder armorBuilder;

    /**
     * Weapon builder class
     */
    private WeaponBuilder weaponBuilder;

    /**
     * Enemy builder class
     */
    private EnemyBuilder enemyBuilder;

    /**
     * Food builder class
     */
    private FoodBuilder foodBuilder;

    /**
     * World builder class
     */
    private WorldBuilder worldBuilder;






    /**
     * Stores the player object if want to get it quickly
     */
    private Player player;

    /**
     * Stores the ascii panel object if wanted to access it directly
     */
    private AsciiPanel panel;

    /**
     * State machine that handles scene transitions.
     */
    private StateManager manager;


    /**
     * Initializer for game data
     */
    public GameData(){

        //Player
        this.player = new Player(X_WIDTH/2,Y_HEIGHT/2);

        //Main panel
        this.panel = new AsciiPanel(X_WIDTH+STATS_X_OFFSET, Y_HEIGHT, AsciiFont.CP437_16x16);



        //Builders
        this.armorBuilder = new ArmorBuilder();
        this.weaponBuilder = new WeaponBuilder();
        this.enemyBuilder = new EnemyBuilder();
        this.foodBuilder = new FoodBuilder();
        this.worldBuilder = new WorldBuilder(this);

        //Game map
        this.gameMap = new GameMap(worldBuilder, player);

        //State Manager
        manager = new StateManager(this);
    }


    /**
     * Resets the game data on a losing condition
     */
    public void resetData(){
        //Player
        this.player = new Player(X_WIDTH/2,Y_HEIGHT/2);

        //Builders
        this.armorBuilder = new ArmorBuilder();
        this.weaponBuilder = new WeaponBuilder();
        this.enemyBuilder = new EnemyBuilder();
        this.foodBuilder = new FoodBuilder();
        this.worldBuilder = new WorldBuilder(this);

        //Game map
        this.gameMap = new GameMap(worldBuilder, player);
    }


    /**
     * Ascii panel object
     * @return
     */
    public AsciiPanel getPanel(){
        return this.panel;
    }

    /**
     * Game map of current level
     * @return
     */
    public GameMap getGameMap() {
        return gameMap;
    }

    /**
     * Updates the game map with a new level
     * @param gameMap
     */
    public void setGameMap(GameMap gameMap) {
        this.gameMap = gameMap;
    }

    /**
     * Gets the armor builder that builds armor objects
     * @return
     */
    public ArmorBuilder getArmorBuilder() {
        return armorBuilder;
    }

    /**
     * Gets the weapon builder that builds weapon objects
     * @return
     */
    public WeaponBuilder getWeaponBuilder() {
        return weaponBuilder;
    }

    /**
     * Gets the enemy builder which builds enemy objects
     * @return
     */
    public EnemyBuilder getEnemyBuilder() {
        return enemyBuilder;
    }

    /**
     * Gets the food builder which builds food objects
     * @return
     */
    public FoodBuilder getFoodBuilder() {
        return foodBuilder;
    }

    /**
     * Get the world builder which creates a world given a level
     * @return
     */
    public WorldBuilder getWorldBuilder() {
        return worldBuilder;
    }

    /**
     * Get the player, helpful for player update move operations
     * @return
     */
    public Player getPlayer() {
        return player;
    }

    /**
     * Get the state manager that handles all movement between scenes
     * @return
     */
    public StateManager getManager() {
        return manager;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Builders\ArmorBuilder.java
package Builders;

import Items.Armor;

import java.util.Random;

/**
 * Created by evanputnam on 8/18/17.
 */
public class ArmorBuilder {


    private static Random random = new Random();

    public enum ArmorType{
        CHEST, LEGS, HEAD;

        public static ArmorType generateArmor(){
            return values()[random.nextInt(values().length)];
        }

    }

    private static int generateDef(ArmorType t, int level){
        switch (t){
            case HEAD:
                return 1+random.nextInt(level+1);
            case LEGS:
                return 2+random.nextInt(level+1);
            case CHEST:
                return 3+random.nextInt(level+1);
        }
        return 1;
    }

    public static Armor generateArmor(int level) {
        ArmorType t = ArmorBuilder.ArmorType.generateArmor();
        return new Armor(t.toString(), generateDef(t, level), t);
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Builders\EnemyBuilder.java
package Builders;

import Placement.Enemy;

import java.util.Random;

/**
 * Created by evanputnam on 8/18/17.
 */
public class EnemyBuilder {

    private static Random random = new Random();


    private enum EnemyName{
        Skeleton, Goblin, Thief, Human, Elf, Dwarf;

        public static EnemyName getRandomEnemy() {
            return values()[random.nextInt(values().length)];
        }

    }

    private enum BossName{
        Medusa, Dragon, Giant, Homer_Simpson, Potato_Head;

        public static BossName getRandomBoss() {
            return values()[random.nextInt(values().length)];
        }
    }

    private static int getDamageReg(int level){
        return 1+random.nextInt(level+1);
    }

    private static int getDamageBoss(int level){
        return 2+random.nextInt(level+2);
    }


    public Enemy getEnemy(int x, int y, boolean isBoss, int level){
        if(isBoss){
            return new Enemy(BossName.getRandomBoss().toString(), x, y, 0, getDamageBoss(level), 10, true);
        }
        return new Enemy(EnemyName.getRandomEnemy().toString(), x, y, 0, getDamageReg(level), 10, false);
    }



}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Builders\FoodBuilder.java
package Builders;

import Items.Food;

import java.util.Random;

/**
 * Created by evanputnam on 8/18/17.
 */
public class FoodBuilder {

    private static Random random = new Random();

    public enum FoodName{
        Pizza, Gum, Potato, Eye, Bladder, Slime, Potion, Kidney;

        public static FoodName getRandomFood() {
            return values()[random.nextInt(values().length)];
        }

        public static int getFoodHitpoints(int playerMax){
            return 1+random.nextInt(playerMax+5);
        }
    }

    public static Food generateFood(int playerMax) {
        return new Food(FoodName.getRandomFood().toString(), FoodName.getFoodHitpoints(playerMax));
    }


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Builders\WeaponBuilder.java
package Builders;

import Items.Weapon;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * Class that creates a new weapon.
 */
public class WeaponBuilder {


    /**
     * Enum to store the different types of weapons
     */
    private enum WEAPON_TYPE{
        Sword, Axe, Spear, Hammer
    }

    /**
     * Enum to store a weapon description
     */
    public enum WEAPON_DESC{
        Holy, Savage, Awesome, Strong, Weak
    }

    /**
     * Enum to store a weapon material
     */
    public enum WEAPON_MATERIAL{
        Wood, Bronze, Iron, Steel, Dwarvish, Elvish, Adamant, Runite
    }





    /**
     * List of all possible WEAPON_TYPE values
     */
    private static final List<WEAPON_TYPE> WEAPON_T =
            Collections.unmodifiableList(Arrays.asList(WEAPON_TYPE.values()));

    /**
     * List of all possible WEAPON_DESC values
     */
    private static final List<WEAPON_DESC> WEAPON_D =
            Collections.unmodifiableList(Arrays.asList(WEAPON_DESC.values()));

    /**
     * List of all possible WEAPON_MATERIAL values
     */
    private static final List<WEAPON_MATERIAL> WEAPON_M =
            Collections.unmodifiableList(Arrays.asList(WEAPON_MATERIAL.values()));


    /**
     * Random generator to generate new weapons.
     */
    private static final Random ranWepStatGen = new Random();


    //TODO: Handle weapon generation. Also figure out level crap
    /**
     * Static function to generate a weapon
     * @return
     */
    public static Weapon genWeapon(){

        int minDamage = 0;
        int maxDamage = 0;

        String desc = "";

        //Process weapon type
        WEAPON_TYPE wt = WEAPON_T.get(ranWepStatGen.nextInt(WEAPON_T.size()));
        switch (wt){
            case Axe: desc = "Axe"; break;
            case Spear: desc = "Spear"; break;
            case Sword: desc = "Sword"; break;
            case Hammer: desc = "Hammer"; break;
        }

        //Process weapon material
        WEAPON_MATERIAL wm = WEAPON_M.get(ranWepStatGen.nextInt(WEAPON_M.size()));
        switch (wm){
            case Wood: minDamage = 1; maxDamage = 3; break;
            case Bronze: minDamage = 2; maxDamage = 5; break;
            case Iron: minDamage = 4; maxDamage = 7; break;
            case Steel: minDamage = 6; maxDamage = 9; break;
            case Dwarvish: minDamage = 8; maxDamage = 12; break;
            case Elvish: minDamage = 12; maxDamage = 17; break;
            case Adamant: minDamage = 18; maxDamage = 22; break;
            case Runite: minDamage = 22; maxDamage = 30; break;
        }

        //Process weapon description
        WEAPON_DESC wd = WEAPON_D.get(ranWepStatGen.nextInt(WEAPON_D.size()));
        switch (wd){
            case Weak: maxDamage -=1; break;
            case Strong: minDamage +=1; break;
            case Awesome: maxDamage += 1;break;
            case Holy: maxDamage += 2;break;
            case Savage: minDamage += 1; break;
        }

        return new Weapon(desc, minDamage, maxDamage, wd, wm);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Builders\WorldBuilder.java
package Builders;

import Backend.GameData;
import GameMap.Coordinate;
import GameMap.GameMap;
import Placement.Enemy;
import Placement.Floor;
import Placement.Ladder;
import Placement.Placeable;

import java.util.HashMap;
import java.util.Random;

/**
 * Created by evanputnam on 8/18/17.
 */
public class WorldBuilder {


    /**
     * Random object for unique dungeon layout
     */
    private Random random;

    /**
     * Game data backend
     */
    private GameData data;

    /**
     * Previous level value
     */
    private int previousLevel;

    /**
     * Constructor merely takes in game data backend
     * @param data
     */
    public WorldBuilder(GameData data){
        this.data = data;
        this.random = new Random();
        this.previousLevel = 1;
    }


    /**
     * Get a new level based on the current world.
     * @param level
     * @return
     */
    public HashMap<Coordinate, Placeable> getWorld(int level, GameMap gameMap){

        HashMap<Coordinate, Placeable> world = genWorld(level, gameMap);
        this.previousLevel = level;
        return world;
    }

    /**
     * Generates a world map for a given level
     * @param level
     * @param gameMap
     * @return
     */
    private HashMap<Coordinate, Placeable> genWorld(int level, GameMap gameMap){

        //Map
        HashMap<Coordinate, Placeable> map = new HashMap<>();

        //Count of tiles to place
        int count = 1000+(100*level);

        //Sets the values back to the start
        //data.getPlayer().setX(0);
        //data.getPlayer().setY(0);

        //Start x position
        int startX = data.getPlayer().getX();
        //Start y position
        int startY = data.getPlayer().getY();

        //Starting player coord
        Coordinate cord = new Coordinate(startX,startY);
        data.getPlayer().setX(startX);
        data.getPlayer().setY(startY);

        //Put player into map
        map.put(cord, data.getPlayer());


        //While more tiles to place
        while(count != 0){
            //Get next location and change x/y accordingly
            int randNum = random.nextInt(4);
            switch (randNum){
                case 0:
                    startX -= 1;
                    break;
                case 1:
                    startX += 1;
                    break;
                case 2:
                    startY -= 1;
                    break;
                case 3:
                    startY += 1;
                    break;
            }
            //System.out.println(count);

            //New Coordinate
            Coordinate c = new Coordinate(startX, startY);

            //If map does not contain coordinate already
            if(!map.containsKey(c)){
                //Alter placeables here with order of precedence at bottom


                //Floor tile
                if(count != 1) {
                    map.put(c, new Floor(startX, startY));
                }

                //Enemy tile
                if(count % 30 == 0){
                    map.put(c, this.data.getEnemyBuilder().getEnemy(startX, startY, false, level));
                }

                //Ladder
                if(count == 1){
                    map.put(c, new Ladder(startX, startY));
                }


                //Add to lists here
                if(map.get(new Coordinate(startX, startY)) instanceof Enemy){
                    gameMap.getEnemies().add((Enemy)map.get(new Coordinate(startX, startY)));
                }



                count -= 1;

            }
        }

        //Add walls here maybe...




        return map;
    }


    public int getPreviousLevel() {
        return previousLevel;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\GameMap\Coordinate.java
package GameMap;

/**
 * Created by evanputnam on 8/17/17.
 */
public class Coordinate implements Comparable<Coordinate>{

    /**
     * X coordinate for game position on map.  Can be pos or negative
     */
    private int x;

    /**
     * Y coordinate for game position on map. Can be pos or negative
     */
    private int y;


    /**
     * Constructor for coordinate given an x and y position
     * @param x
     * @param y
     */
    public Coordinate(int x, int y){
        this.x = x;
        this.y = y;
    }





    /**
     * Get x location
     * @return
     */
    public int getX() {
        return x;
    }

    /**
     * Get y location
     * @return
     */
    public int getY() {
        return y;
    }







    /**
     * Equals if x and y are equivilant
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Coordinate that = (Coordinate) o;
        return that.x == this.x && that.y == this.y;
    }

    @Override
    public int compareTo(Coordinate c){
        //System.out.println("COMPARISON!");
        if(this.equals(c)){
            return 0;
        }
        int i = Integer.compare(this.getX(), c.getX());
        if(i != 0){
            return i;
        }
        int i2 = Integer.compare(this.getY(), c.getY());
        return i2;

    }

    /**
     * Hash code for hashmap.  Default given with intellij auto gen.
     * @return
     */
    @Override
    public int hashCode() {
        //System.out.println("HASH!");
        int result = x;
        result = 31 * result + y;
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\GameMap\GameMap.java
package GameMap;

import Builders.ArmorBuilder;
import Builders.FoodBuilder;
import Builders.WeaponBuilder;
import Builders.WorldBuilder;
import Items.Weapon;
import Placement.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

/**
 * Created by evanputnam on 8/17/17.
 */
public class GameMap {


    /**
     * Level
     */
    private static int LEVEL = 0;

    /**
     * Hash map that stores a coordinate pair to locate a placeable on the map
     */
    private HashMap<Coordinate, Placeable> map;

    /**
     * Stores references to all the enemies in the map
     */
    private ArrayList<Enemy> enemies;

    /**
     * Random generating object
     */
    private static Random generator = new Random();

    /**
     * Keeps track of player
     */
    private Player player;

    /**
     * Constructor for the game map object
     */
    public GameMap(Player player){
        this.enemies = new ArrayList<>();
        this.map = new HashMap<Coordinate, Placeable>();
        this.player = player;
        LEVEL += 1;
    }

    /**
     * Construct a game map object with a given map
     * @param map
     */
    public GameMap(HashMap<Coordinate, Placeable> map, Player player){
        this.enemies = new ArrayList<>();
        this.map = map;
        this.player = player;
        LEVEL += 1;
    }

    /**
     * Create a level with a world builder object
     * @param worldBuilder
     */
    public GameMap(WorldBuilder worldBuilder, Player player){
        this.enemies = new ArrayList<>();
        this.map = worldBuilder.getWorld(0, this);
        this.player = player;
        LEVEL += 1;
    }

    /**
     * Create a level with a worldbuilder object AND a level.
     * @param worldBuilder
     * @param level
     */
    public GameMap(WorldBuilder worldBuilder, int level, Player player){
        this.enemies = new ArrayList<>();
        this.map = worldBuilder.getWorld(level, this);
        this.player = player;
        LEVEL = level;
    }


    /**
     * Call a game map to attack an enemy
     * @param damage
     * @param enemy
     * return boolean to indicate if the current player is dead
     */
    public boolean attackEnemy(int damage, Enemy enemy){

        boolean dead = enemy.damageEnemy(damage);
        //Simulates player attacking first
        if(dead){
            int x = generator.nextInt(4);
            if(x == 0){
                this.getMap().put(new Coordinate(enemy.getX(), enemy.getY()),
                        new Drop(enemy.getX(), enemy.getY(), ArmorBuilder.generateArmor(LEVEL)));
            }else if (x == 1){
                this.getMap().put(new Coordinate(enemy.getX(), enemy.getY()),
                        new Drop(enemy.getX(), enemy.getY(), WeaponBuilder.genWeapon()));
            }else if (x == 2){
                this.getMap().put(new Coordinate(enemy.getX(), enemy.getY()),
                        new Drop(enemy.getX(), enemy.getY(), FoodBuilder.generateFood(this.player.getMaxHitPoints())));
            }else{
                this.getMap().put(new Coordinate(enemy.getX(), enemy.getY()), new Floor(enemy.getX(), enemy.getY()));
            }

            enemies.remove(enemy);
            return false;
        }else{
            int enemyDam = enemy.getDamage(this.player);
            return player.takeDamage(enemyDam);
        }

    }


    /**
     * Gets the map hashmap
     * @return
     */
    public HashMap<Coordinate, Placeable> getMap(){
        return this.map;
    }


    /**
     * Gets the enemies of in the hashmap
     * @return
     */
    public ArrayList<Enemy> getEnemies() {
        return enemies;
    }


    /**
     * Adds an coordinate-placeable pair to the map
     * @param c
     * @param p
     * @return
     */
    private boolean addObj(Coordinate c, Placeable p){
        if(!map.containsKey(c)){
            map.put(c, p);
            return true;
        }
        return false;
    }

    /**
     * Adds an enemy to the enemy array list
     * @param e
     */
    private void addEnemy(Enemy e){
        enemies.add(e);
    }

    /**
     * Removes a given enemy from the array list
     * @param e
     * @return
     */
    private boolean removeEnemy(Enemy e){
        return enemies.remove(e);
    }


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Items\Armor.java
package Items;

import Builders.ArmorBuilder.ArmorType;
import Placement.Player;

/**
 * Created by evanputnam on 8/18/17.
 */
public class Armor implements Item{


    private ArmorType type;
    private int defense;
    private String name;
    private boolean equiped = false;

    public Armor(String name, int defense, ArmorType type){
        this.name = name;
        this.defense = defense;
        this.type = type;
    }


    public ArmorType getType() {
        return type;
    }

    public int getDefense() {
        return defense;
    }

    public String getName() {
        return name;
    }

    public String getItemName(){
        return name;
    }

    public void useItem(Player player){
        equiped = true;
        switch (type){
            case CHEST:
                player.equipBody(this);
                break;
            case LEGS:
                player.equipHead(this);
                break;
            case HEAD:
                player.equipLegs(this);
                break;
        }
    }

    public boolean isEquiped(){
        return equiped;
    }

    public void setEquiped(boolean eq){
        this.equiped = eq;
    }

    public String getStatReadOff(){
        return this.name +"\n"
                +"Item: " +"Armor"+"\n"
                +"Def: " + this.defense+"\n"
                +"Type: " + this.type;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Items\Food.java
package Items;

import Placement.Player;

/**
 * Created by evanputnam on 8/18/17.
 */
public class Food implements Item{


    private String name;
    private int hitpoints;


    public Food(String name, int hitpoints){
        this.name = name;
        this.hitpoints = hitpoints;
    }

    public int getHitpoints() {
        return hitpoints;
    }

    public String getItemName(){
        return this.name;
    }


    public String getStatReadOff(){
        return this.name +"\n"
                +"Item: " + "Food" +'\n'
                +"Hitpoints: " + this.hitpoints;
    }

    public void useItem(Player player){
        player.heal(hitpoints);
        player.getItems().remove(this);
    }

    public boolean isEquiped(){
        return false;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Items\Item.java
package Items;

import Placement.Player;

/**
 * Created by evanputnam on 8/18/17.
 * //TODO update stat read offs for each item
 */
public interface Item {

    String getItemName();
    String getStatReadOff();
    void useItem(Player player);
    boolean isEquiped();
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Items\Weapon.java
package Items;

import Builders.WeaponBuilder;
import Placement.Player;

/**
 * Created by evanputnam on 8/18/17.
 */
public class Weapon implements Item{

    private int minDamage;
    private int maxDamage;
    private WeaponBuilder.WEAPON_DESC weaponDesc;
    private WeaponBuilder.WEAPON_MATERIAL weaponMat;
    private boolean equiped = false;

    private String name;

    public Weapon(String name, int minDam, int maxDam,
                  WeaponBuilder.WEAPON_DESC weaponDesc, WeaponBuilder.WEAPON_MATERIAL weaponMat){
        this.name = name;
        this.minDamage = minDam;
        this.maxDamage = maxDam;
        this.weaponDesc = weaponDesc;
        this.weaponMat = weaponMat;
    }

    public int getMinDamage(){
        return this.minDamage;
    }

    public int getMaxDamage(){
        return this.maxDamage;
    }

    public String getItemName(){
        return name;
    }

    public void useItem(Player player){
        equiped = true;
        player.equipWeapon(this);
    }

    public boolean isEquiped(){
        return equiped;
    }

    public void setEquiped(boolean eq){
        this.equiped = eq;
    }



    public String getStatReadOff(){
        return this.name +"\n"
                +"Item: " + "Weapon"+"\n"
                +"Max Dam: " + this.maxDamage+"\n"
                +"Min Dam: " + this.minDamage+"\n"
                +"Type: " + weaponDesc.toString()+"\n"
                +"Material: " + weaponMat.toString();
    }



}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Main.java
import Backend.GameData;

import javax.swing.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

//TODO note that the following command is great... "find . -name '*.java' -print0 | xargs -0 wc -l"
//TODO document
//TODO fix second layer where the charachters are just staying in random positions...
public class Main extends JFrame implements KeyListener{

    /**
     * Game data object has all the data of the game
     */
    private GameData data;


    /**
     * Main class initializes the game data, adds the key listener, adds the panel and packs, and sets
     * default scene
     */
    public Main(){
        super();
        data = new GameData();
        addKeyListener(this);
        add(data.getPanel());
        pack();
        data.getManager().getCurrentState().updateScreen();
    }


    /**
     * Key pressed. Unused
     * @param e
     */
    public void keyPressed(KeyEvent e) {

    }


    /**
     * Handles the main game loop
     * First gets the keycode and passes it to the process command and update screen of current state.
     * @param e
     */
    public void keyReleased(KeyEvent e) {
        //System.out.println(e.getKeyCode());
        data.getManager().getCurrentState().processCommand(e.getKeyCode());
        data.getManager().getCurrentState().updateScreen();
    }


    /**
     * Key typed.  Unused
     * @param event
     */
    public void keyTyped(KeyEvent event){}


    /**
     * Main function creates new Main object and sets close op and visibility
     * @param args
     */
    public static void main(String[] args) {
        Main game = new Main();
        game.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        game.setVisible(true);
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Drop.java
package Placement;

import Items.Item;

/**
 * Class that acts as an item on the map that is dropped by the enemy.
 */
public class Drop implements Placeable {

    /**
     * X location of the drop
     */
    private int x;

    /**
     * Y location of the drop
     */
    private int y;

    /**
     * Charachter to represent a drop
     */
    private static final char ITEM_CHAR = 'I';

    /**
     * Item that is stored on the given space
     */
    private Item item;


    /**
     * Constructor
     * @param x x location coordinate
     * @param y y location coordinate
     * @param item item to store
     */
    public Drop(int x, int y, Item item){
        this.x = x;
        this.y = y;
        this.item = item;
    }


    /**
     * Gets the x location on the screen
     * @return
     */
    public int getX() {
        return x;
    }

    /**
     * Gets the y location on the screen
     * @return
     */
    public int getY() {
        return y;
    }

    /**
     * Sets the x location of the object
     * @param x
     */
    public void setX(int x) {
        this.x = x;
    }

    /**
     * Sets the y location of the object
     * @param y
     */
    public void setY(int y) {
        this.y = y;
    }

    /**
     * Gets the character to display for the placeable
     * @return I character
     */
    public char getChar(){
        return ITEM_CHAR;
    }

    /**
     * Returns the item that the placeable represents.
     * @return
     */
    public Item getItem() {
        return item;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Enemy.java
package Placement;

import GameMap.Coordinate;

import java.util.HashMap;
import java.util.Random;

/**
 * Created by evanputnam on 8/18/17.
 */
public class Enemy implements Placeable{

    /**
     * X location of enemy
     */
    private int x;

    /**
     * Y location of enemy
     */
    private int y;

    /**
     * Min damage of enemy
     */
    private int minDam;

    /**
     * Max damage of enemy
     */
    private int maxDam;

    /**
     * Health of enemy
     */
    private int health;

    /**
     * Name of enemy
     */
    private String name;

    /**
     * Random object to calculate attack values
     */
    private Random random;

    /**
     * Boolean to represent if boss or not
     */
    private boolean isBoss;

    /**
     * Static charachter for regular enemy
     */
    private static final char ENEMY_CHAR = 'E';

    /**
     * Static charachter for boss enemy
     */
    private static final char BOSS_ENEMY_CHAR = 'B';





    /**
     * Enemy contructor
     * @param name
     * @param x
     * @param y
     * @param minDam
     * @param maxDam
     * @param health
     */
    public Enemy(String name, int x, int y, int minDam, int maxDam, int health, boolean isBoss){
        this.x = x;
        this.y = y;
        this.minDam = minDam;
        this.maxDam = maxDam;
        this.name = name;
        this.random = new Random();
        this.health = health;
        this.isBoss = isBoss;
        random.setSeed(System.currentTimeMillis());
    }


    /**
     * Get x location
     * @return
     */
    public int getX(){
        return this.x;
    }

    /**
     * Get y location
     * @return
     */
    public int getY(){
        return this.y;
    }

    /**
     * Set the x location
     * @param x
     */
    public void setX(int x) {
        this.x = x;
    }

    /**
     * Set the y location
     * @param y
     */
    public void setY(int y) {
        this.y = y;
    }


    /**
     * Get the constant charachter for the given placeable
     * @return
     */
    public char getChar(){
        if(isBoss){
            return BOSS_ENEMY_CHAR;
        }
        return ENEMY_CHAR;
    }

    /**
     * Get the minimum damage
     * @return
     */
    public int getMinDam() {
        return minDam;
    }

    /**
     * Get the maximum damage
     * @return
     */
    public int getMaxDam() {
        return maxDam;
    }

    /**
     * Get the name of the enemy
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * Get the health of the enemy
     * @return
     */
    public int getHealth() {
        return health;
    }

    /**
     * Adds damage to an enemy.
     * If dead returns true, if alive returns false
     * @param damage
     * @return
     */
    public boolean damageEnemy(int damage){
        this.health = this.health - damage;
        if(this.health <= 0){
            return true;
        }
        return false;
    }


    /**
     * Get a random damage value from min-max of enemy.
     * @return
     */
    public int getDamage(Player p){
        int def = p.getDefenseBonus();
        int hitSuccess = random.nextInt(200);
        if (hitSuccess <= def){
            System.out.println(def);
            return 0;
        }
        return random.nextInt((maxDam - minDam)+1) + minDam;
    }


    /**
     * Equals if x and y are the same.
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Enemy enemy = (Enemy) o;

        if (x != enemy.x) return false;
        return y == enemy.y;
    }

    /**
     * Hash code based on x and y
     * @return
     */
    @Override
    public int hashCode() {
        int result = x;
        result = 31 * result + y;
        return result;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Floor.java
package Placement;

/**
 * Created by evanputnam on 8/17/17.
 */
public class Floor implements Placeable {

    private int x;
    private int y;

    private static final char FLOOR_CHAR = '.';


    public Floor(int x, int y){
        this.x = x;
        this.y = y;
    }


    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public char getChar(){
        return FLOOR_CHAR;
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Ladder.java
package Placement;

/**
 * Ladder to move onto the next level.  Once you move on you can not move back!!!
 */
public class Ladder implements Placeable  {


    private int x;
    private int y;

    private static final char LADDER_CHAR = 'L';


    public Ladder(int x, int y){
        this.x = x;
        this.y = y;
    }


    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public char getChar(){
        return LADDER_CHAR;
    }

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Placeable.java
package Placement;

/**
 * Created by evanputnam on 8/18/17.
 */
public interface Placeable {

    int getX();
    int getY();
    void setX(int x);
    void setY(int x);
    char getChar();


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Player.java
package Placement;

import Builders.WeaponBuilder;
import Items.Armor;
import Items.Food;
import Items.Item;
import Items.Weapon;

import java.util.ArrayList;
import java.util.Random;

/**
 * Created by evanputnam on 8/17/17.
 */
public class Player implements Placeable {

    private static final char PLAYER_CHAR = '@';

    public static final int MAX_INVENTORY_SLOTS = 40;

    private Random diceRoller;

    private int x;
    private int y;
    private int hitPoints;
    private int maxHitPoints;

    private ArrayList<Item> items;


    private Armor headPiece;
    private Armor chestPiece;
    private Armor legPiece;

    private Weapon weapon;

    private String playerName;

    public Player(int x, int y){
        this.x = x;
        this.y = y;
        this.items = new ArrayList<>();
        this.headPiece = null;
        this.chestPiece = null;
        this.legPiece = null;
        this.weapon = null;
        this.diceRoller = new Random();
        this.playerName = "";
        diceRoller.setSeed(System.currentTimeMillis());

        this.hitPoints = 10;
        this.maxHitPoints = 10;

        this.items.add(new Weapon("POKER", 1, 4, WeaponBuilder.WEAPON_DESC.Weak, WeaponBuilder.WEAPON_MATERIAL.Bronze));
        this.items.add(new Food("POTION", 100));

    }

    public String getPlayerName(){
        if(this.playerName == null){
            return "";
        }else{
            return playerName;
        }
    }


    public boolean addPlayerNameCh(char c){
        if(this.playerName.length() < 10){
            this.playerName += c;
            return true;
        }else{
            return false;
        }
    }

    public boolean removePlayerNameCh(){
        if(this.playerName.length() != 0){
            this.playerName = this.playerName.substring(0, this.playerName.length()-1);
            return true;
        }
        return false;
    }

    public int getAttackDamage(){
        if(weapon == null){
            //Max fist damage is 3
            return diceRoller.nextInt(3);
        }
        return diceRoller.nextInt((weapon.getMaxDamage() - weapon.getMinDamage()) + 1)
                + weapon.getMinDamage();
    }

    public int getDefenseBonus(){
        int def = 0;
        if(headPiece != null){
            def += headPiece.getDefense();
        }

        if(chestPiece != null){
            def += chestPiece.getDefense();
        }

        if(legPiece != null){
            def += legPiece.getDefense();
        }

        return def;
    }

    public int getX(){
        return this.x;
    }

    public int getY(){
        return this.y;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public char getChar(){
        return PLAYER_CHAR;
    }

    public int getHitPoints(){return this.hitPoints;}

    public int getMaxHitPoints(){return this.maxHitPoints;}

    public ArrayList<Item> getItems(){
        return this.items;
    }

    public void equipWeapon(Weapon weapon){
        if (this.weapon != null){
            this.weapon.setEquiped(false);
        }
        this.weapon = weapon;
    }

    public void equipHead(Armor armor){
        if (this.headPiece != null){
            this.headPiece.setEquiped(false);
        }
        this.headPiece = armor;
    }

    public void equipBody(Armor armor){
        if (this.chestPiece != null){
            this.chestPiece.setEquiped(false);
        }
        this.chestPiece = armor;
    }

    public void equipLegs(Armor armor){
        if(this.legPiece != null){
            this.legPiece.setEquiped(false);
        }
        this.legPiece = armor;
    }

    public boolean takeDamage(int damage){
        this.hitPoints -= damage;
        if (this.hitPoints <= 0){
            return true;
        }
        return false;
    }

    public void heal(int health){
        this.hitPoints += health;
        if (this.hitPoints > this.maxHitPoints){
            this.hitPoints = this.maxHitPoints;
        }
    }



    /**
     * Adds an item to the inventory if under the required slots.
     * @param item
     * @return
     */
    public boolean addItem(Item item){
        if(this.items.size() >= MAX_INVENTORY_SLOTS){
            return false;
        }else{
            this.items.add(item);
            return true;
        }
    }


    public String getReadoff(){
        String s = "";
        if (headPiece != null){
            s += headPiece.getName();
            s += '\n';
        }
        if (legPiece != null){
            s += legPiece.getName();
            s += '\n';
        }
        if (chestPiece != null){
            s += chestPiece.getName();
            s += '\n';
        }
        if (weapon != null){
            s += weapon.getItemName();
            s += '\n';
        }
        return s;
    }



}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\Placement\Wall.java
package Placement;

/**
 * Created by evanputnam on 8/17/17.
 */
public class Wall implements Placeable{

    private int x;
    private int y;

    private static final char WALL_CHAR = '#';

    public Wall(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return this.x;
    }

    public int getY(){
        return this.y;
    }

    public char getChar(){
        return WALL_CHAR;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }





}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\StateMachine\State.java
package StateMachine;

import asciiPanel.AsciiPanel;

/**
 * Created by evanputnam on 8/19/17.
 */
public interface State {

    static final int LEFT_KEY = 37;
    static final int RIGHT_KEY = 39;
    static final int UP_KEY = 38;
    static final int DOWN_KEY = 40;
    static final int ENTER_KEY = 10;
    static final int ESCAPE_KEY = 27;
    static final int I_KEY = 73;

    void processCommand(int com);
    void updateScreen(AsciiPanel panel);
    void updateScreen();

}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\StateMachine\StateGame.java
package StateMachine;

import Backend.GameData;
import GameMap.Coordinate;
import GameMap.GameMap;
import Items.Item;
import Placement.*;
import StateMachine.StateManager.StateManager;
import asciiPanel.AsciiPanel;

import java.util.*;


/**
 * Created by evanputnam on 8/19/17.
 * Game state
 * TODO: Add status effects to enemies like blue for frozen, yellow stunned(after a crit hit),
 * TODO: green for poison, red for bloody???
 * TODO: Add a queue for things happening in the world in the status bar...
 * TODO: Make enemies drop stuff
 */
public class StateGame implements State {


    /**
     * Backend object
     */
    private GameData data;

    /**
     * Random object for movement
     */
    private Random randomMove;

    /**
     * Initializes the object with the game data backend
     *
     * @param data
     */
    public StateGame(GameData data) {
        this.randomMove = new Random();
        this.data = data;
    }

    /**
     * Processes each of the commands that comes in.
     *
     * @param com
     */
    public void processCommand(int com) {
        HashMap<Coordinate, Placeable> map = data.getGameMap().getMap();

        //State changes here
        if (com == State.I_KEY) {
            System.out.println("Changing to inventory");
            data.getManager().setGameState(StateManager.INVENTORY_STATE);
        }

        if (com == State.ESCAPE_KEY) {
            System.out.println("Going to Pause");
            data.getManager().setGameState(StateManager.PAUSE_STATE);
        }


        //Update movement here
        //Variable to check if did move
        boolean didMove = false;

        if (com == LEFT_KEY) {
            didMove = checkCollisionMove(map, LEFT_KEY);
        }

        if (com == RIGHT_KEY) {
            didMove = checkCollisionMove(map, RIGHT_KEY);
        }

        if (com == UP_KEY) {
            didMove = checkCollisionMove(map, UP_KEY);
        }

        if (com == DOWN_KEY) {
            didMove = checkCollisionMove(map, DOWN_KEY);
        }


        //Update enemies here
        //TODO Implement enemy movement.  Also note... That attacking enemy should count as movement.
        if (didMove) {
            for (Enemy e: data.getGameMap().getEnemies()) {
                Coordinate c = getEnemyMovement(data.getPlayer(), e);
                if(map.get(c) != null && (map.get(c) instanceof Floor)){
                    map.put(new Coordinate(e.getX(), e.getY()), new Floor(e.getX(), e.getY()));
                    map.put(c, e);
                    e.setX(c.getX());
                    e.setY(c.getY());
                }
            }
        }


         if (data.getPlayer().takeDamage(0)){
            data.getManager().setGameState(StateManager.START_MENU);
            data.resetData();
         }




    }


    /**
     * Checks collisions with specific objects and checks values
     *
     * @param map
     * @param direction
     */
    private boolean checkCollisionMove(HashMap<Coordinate, Placeable> map, int direction) {

        //Get player placable
        Placeable player = map.get(new Coordinate(data.getPlayer().getX(), data.getPlayer().getY()));

        //Get where the player wants to move
        Placeable next;
        switch (direction) {
            case LEFT_KEY:
                next = map.get(new Coordinate(player.getX() - 1, player.getY()));
                break;
            case RIGHT_KEY:
                next = map.get(new Coordinate(player.getX() + 1, player.getY()));
                break;
            case UP_KEY:
                next = map.get(new Coordinate(player.getX(), player.getY() - 1));
                break;
            case DOWN_KEY:
                next = map.get(new Coordinate(player.getX(), player.getY() + 1));
                break;
            default:
                next = null;
        }

        //If not null then process each option for move type
        if (next != null) {
            if (next instanceof Floor) {
                //Merely swap the values in the hash map.
                map.put(new Coordinate(next.getX(), next.getY()), player);
                map.put(new Coordinate(player.getX(), player.getY()), next);
                int xP = next.getX();
                int yP = next.getY();
                int xN = player.getX();
                int yN = player.getY();
                player.setX(xP);
                player.setY(yP);
                next.setX(xN);
                next.setY(yN);
                return true;
            } else if (next instanceof Ladder) {
                GameMap gameMap = new GameMap(data.getWorldBuilder(), data.getWorldBuilder().getPreviousLevel() + 1, this.data.getPlayer());
                data.setGameMap(gameMap);
                return true;
            }else if (next instanceof Enemy){
                this.data.getGameMap().attackEnemy(this.data.getPlayer().getAttackDamage(), (Enemy)next);
                return true;
            }else if (next instanceof Drop){
                data.getPlayer().addItem(((Drop) next).getItem());
                map.put(new Coordinate(next.getX(), next.getY()), new Floor(next.getX(), next.getY()));
                return true;
            }
        }

        return false;


    }

    /**
     * Updates screen if given an ascii panel object
     *
     * @param panel
     */
    public void updateScreen(AsciiPanel panel) {
    }


    /**
     * Updates the screen so that the main charachter is always in the middle.
     */
    public void updateScreen() {

        //Clears the panel before writing
        data.getPanel().clear();

        //Gets the player location
        int xS = data.getPlayer().getX();
        int yS = data.getPlayer().getY();

        //Gets the offset to calculate
        int offSetX = xS - GameData.X_WIDTH / 2;
        int offSetY = yS - GameData.Y_HEIGHT / 2;

        //Draws the board with each object
        for (int y = 0; y < GameData.Y_HEIGHT; y++) {
            for (int x = 0; x < GameData.X_WIDTH; x++) {
                Placeable p = data.getGameMap().getMap().get(new Coordinate(x + offSetX, y + offSetY));

                if (p != null) {
                    data.getPanel().write(p.getChar(), x, y);
                }
            }
        }


        //Write to the right hand portion of the screen for status indicators.
        data.getPanel().write("Name: " + data.getPlayer().getPlayerName(), GameData.X_WIDTH + 1, 0);
        data.getPanel().write("Hit Points: "+data.getPlayer().getHitPoints()
                        +"/"+data.getPlayer().getMaxHitPoints()
                , GameData.X_WIDTH + 1, 2);
        data.getPanel().write("Other Stuff: ", GameData.X_WIDTH + 1, 4);
        data.getPanel().write("Level: " + String.valueOf(data.getWorldBuilder().getPreviousLevel()),
                GameData.X_WIDTH + 1, 6);

        data.getPanel().write("------------------", GameData.X_WIDTH + 1, 14);

        int y = 15;
        String s[] = this.data.getPlayer().getReadoff().split("\n");
        for (String st:s) {
            data.getPanel().write(st, GameData.X_WIDTH + 1, y);
            y += 1;
        }



        data.getPanel().updateUI();


    }


    /**
     * Value for attack radius of an enemy
     */
    private static final int ATTACK_RADIUS = 5;

    /**
     * Handles the enemy movement given the player and the enemy to calc movement for
     * @param p player
     * @param e enemy to calc movement for
     * @return
     */
    private Coordinate getEnemyMovement(Player p, Enemy e) {
        //BFS if close to player or within radius
        if (Math.abs(p.getX() - e.getX()) < ATTACK_RADIUS && Math.abs(p.getY() - e.getY()) < ATTACK_RADIUS) {


            ArrayList<Coordinate> c = nextMovePath(e.getX(), e.getY(), p.getX(), p.getY());
            if(c == null || c.size() <= 1){
                return null;
            }

            return c.get(1);


            //Random move if not within radius
        } else {

            //0, 1, 2 you move randomly if not then stay the same.
            if (randomMove.nextInt(4) != 3) {

                //Get storage for coordinates
                ArrayList<Coordinate> coordinatesAvailable = new ArrayList<>();

                //Get coordinates to check
                Coordinate left = new Coordinate(e.getX() - 1, e.getY());
                Coordinate right = new Coordinate(e.getX() + 1, e.getY());
                Coordinate up = new Coordinate(e.getX(), e.getY() - 1);
                Coordinate down = new Coordinate(e.getX(), e.getY() + 1);

                //Check coordinates and add to list if available
                if (data.getGameMap().getMap().get(left) != null) {
                    coordinatesAvailable.add(left);
                }
                if (data.getGameMap().getMap().get(right) != null) {
                    coordinatesAvailable.add(right);
                }
                if (data.getGameMap().getMap().get(up) != null) {
                    coordinatesAvailable.add(up);
                }
                if (data.getGameMap().getMap().get(down) != null) {
                    coordinatesAvailable.add(down);
                }

                if (coordinatesAvailable.size() != 0) {
                    //Get coordinate from available
                    Coordinate c = coordinatesAvailable.get(
                            randomMove.nextInt(coordinatesAvailable.size()));
                    return c;
                } else {
                    return new Coordinate(e.getX(), e.getY());
                }
            } else {
                return new Coordinate(e.getX(), e.getY());
            }

        }

    }

    /**
     * Search for player with bfs
     * @param currX current x of enemy
     * @param currY current y of enemy
     * @param goalX current goal of enemy
     * @param goalY current goal of enemy
     * @return
     */
    private ArrayList<Coordinate> nextMovePath(int currX, int currY, int goalX, int goalY){
        //Acts as a queue for those that are open
        ArrayList<Coordinate> openSet = new ArrayList<>();

        //Acts as a set for those that are not open
        Set<Coordinate> closedSet = new TreeSet<Coordinate>();

        //Coordinate mapping to later build paths
        HashMap<Coordinate, Coordinate> mapTrace = new HashMap<>();


        //Put path
        mapTrace.put(new Coordinate(currX, currY), null);


        //Initialize
        openSet.add(new Coordinate(currX, currY));

        //While the set is not empty iterate over it
        while(!openSet.isEmpty()){

            Coordinate c = openSet.remove(0);

            //Goal met then return a constructed path
            if(c.getX() == goalX && c.getY() == goalY){
                return constructPath(c, mapTrace);
            }

            //Children array to store next entry nodes
            ArrayList<Coordinate> child = new ArrayList<>();


            //Get possible coordinates
            Coordinate cLeft = new Coordinate(c.getX() - 1, c.getY());
            Coordinate cRight = new Coordinate(c.getX() + 1, c.getY());
            Coordinate cDown = new Coordinate(c.getX(), c.getY()+1);
            Coordinate cUp = new Coordinate(c.getX(), c.getY()-1);

            //Make sure the tile is either the player or the floor
            if(data.getGameMap().getMap().get(cLeft)!= null &&
                    (data.getGameMap().getMap().get(cLeft) instanceof Floor ||
                    data.getGameMap().getMap().get(cLeft) instanceof Player)){
                child.add(new Coordinate(c.getX() - 1, c.getY()));
            }
            if(data.getGameMap().getMap().get(cRight)!= null &&
                    (data.getGameMap().getMap().get(cRight) instanceof Floor ||
                            data.getGameMap().getMap().get(cRight) instanceof Player)){
                child.add(new Coordinate(c.getX() + 1, c.getY()));
            }
            if(data.getGameMap().getMap().get(cDown)!= null &&
                    (data.getGameMap().getMap().get(cDown) instanceof Floor ||
                    data.getGameMap().getMap().get(cDown) instanceof Player)){
                child.add(new Coordinate(c.getX(), c.getY()+1));
            }
            if(data.getGameMap().getMap().get(cUp) != null &&
                    (data.getGameMap().getMap().get(cUp) instanceof Floor ||
                            data.getGameMap().getMap().get(cUp) instanceof Player)){
                child.add(new Coordinate(c.getX(), c.getY()-1));
            }

            //For each possible move
            for(Coordinate s:child){
                //If already handled move on.
                if(closedSet.contains(s)){
                    continue;
                }
                //If the open set does not contain the next move add it
                if(!openSet.contains(s)){
                    mapTrace.put(s, c);
                    openSet.add(s);

                }

            }
            //System.out.println(closedSet.size());
            closedSet.add(c);
        }

        return null;


    }

    /**
     * Constructs a path between enemy and player if can be found
     * @param state player coordinate to go backwards in hashmap to find
     * @param mainMap Hash map of coordinates and corresponding child-parent pairs.
     * @return array list of coordinate path.
     */
    private ArrayList<Coordinate> constructPath(Coordinate state, HashMap<Coordinate, Coordinate> mainMap){
        ArrayList<Coordinate> lst = new ArrayList<>();
        while(true){
            Coordinate c = mainMap.get(state);
            if(c != null){
                state = c;
                lst.add(state);
            }else{
                break;
            }
        }
        Collections.reverse(lst);
        return lst;
    }
    


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\StateMachine\StateInventory.java
package StateMachine;

import Backend.GameData;
import Items.Item;
import Placement.Player;
import StateMachine.StateManager.StateManager;
import asciiPanel.AsciiPanel;

import java.awt.*;



/**
 * State that handles all inventory logic for a given character
 * Cursor setup like this:
 * 0  1
 * 2  3
 * 4  5
 * .  .
 * .  .
 * 38 39
 *
 * TODO need to add use and display current items user has on.
 * TODO need to add equipment equip and un-equip
 */
public class StateInventory implements State {


    /**
     * Backend game object that has all the games required information
     */
    private GameData data;

    /**
     * Integer values to represent cursor positions.
     * Formulas to calculate positions based on this value are used in this states update screen method
     */
    private int cursor;

    /**
     * Constructor for the inventory state.
     * @param data
     */
    public StateInventory(GameData data){
        this.data = data;
    }


    /**
     * Process the commands that occur during inventory state
     * @param com
     */
    public void processCommand(int com){
        //Set state to game with new hero
        if(com == State.ESCAPE_KEY || com == State.I_KEY){
            System.out.println("Going to game");
            this.cursor = 0;
            data.getManager().setGameState(StateManager.GAME_STATE);
        }


        //Handle cursor movement.
        if(com == State.RIGHT_KEY){
            if (this.cursor < Player.MAX_INVENTORY_SLOTS-1){
                this.cursor += 1;
            }
        }

        if(com == State.LEFT_KEY){
            if (this.cursor > 0){
                this.cursor -= 1;
            }
        }

        if(com == State.DOWN_KEY){
            if (this.cursor + 1 < Player.MAX_INVENTORY_SLOTS-1){
                this.cursor += 2;
            }
        }

        if(com == State.UP_KEY){
            if (this.cursor-1 > 0){
                this.cursor -= 2;
            }
        }

        if(com == State.ENTER_KEY){
            try {
                data.getPlayer().getItems().get(cursor).useItem(data.getPlayer());
            }catch (IndexOutOfBoundsException e){
                System.out.println("Invalid");
            }

        }




    }

    /**
     * Same as update screen but gives an AsciiPanel object instead
     * @param panel
     */
    public void updateScreen(AsciiPanel panel){}



    /**
     * Update screen with text.
     * Has a cursor, items, and information on those items.
     */
    public void updateScreen(){
        //Clears the panel before writing
        data.getPanel().clear();


        int yOffset = 1; //Y offset for operations
        boolean right = true; //Boolean to switch between left and right
        int count = 0; //Count value to temporarily keep track of item count
        int max = 20;  //Max number of rows
        int xStart = 5;  //Start x value on screen
        int xEnd = 20;  //Start y value on screen

        //Display each item that is available
        for (Item i: data.getPlayer().getItems()) {
            Color color = Color.WHITE;
            if (i.isEquiped()){
                color = Color.cyan;
            }
            if(right){
                data.getPanel().write(i.getItemName(), xStart, yOffset+count, color);
                right = false;
            }else{
                data.getPanel().write(i.getItemName(), xEnd, yOffset+count, color);
                count += 1;
                right = true;
            }
        }

        //Display not filled items.
        for (int i = count; i < max; i++){
            if(right == true){
                data.getPanel().write("---", xStart, yOffset+i);
                right = false;
            }
            if (right != true){
                data.getPanel().write("---", xEnd, yOffset+i);
                right = true;
            }
        }

        //Display the cursor next to each item
        int x = 0;
        int y = 0;
        //Left right
        if(cursor % 2 == 0){
            x = xStart-1; //Calculate x value if even
            y = cursor/2+yOffset; //Calculate y value if even
        }else{
            x = xEnd-1;
            y = ((cursor-1)/2)+yOffset;
        }
        //
        data.getPanel().write("#", x, y, Color.cyan);


        //Display information about hovered over item
        if(data.getPlayer().getItems().size() > cursor) {
            String s = data.getPlayer().getItems().get(cursor).getStatReadOff();
            String str[] = s.split("\n");
            int ct = 0;
            for (String sN: str) {
                data.getPanel().write(sN, xEnd+10, 5+ct);
                ct += 1;
            }
        }else{
            data.getPanel().write("Empty", xEnd+10, 5);
        }



        data.getPanel().updateUI();
    }
}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\StateMachine\StateManager\StateManager.java
package StateMachine.StateManager;

import StateMachine.*;
import asciiPanel.AsciiPanel;
import Backend.GameData;

import java.util.HashMap;

/**
 * Created by evanputnam on 8/19/17.
 */
public class StateManager {


    /**Integers for the menu selection scene*/
    public static final int START_MENU = 0;
    public static final int GAME_STATE = 1;
    public static final int INVENTORY_STATE = 2;
    public static final int PAUSE_STATE =  3;

    /**
     * Hash map containing all of the different scene objects
     */
    private HashMap<Integer, State> stateHashMap;

    /**
     * Current state in the the state manager.
     */
    private State currentState;

    /**
     * Game data object which holds all information about player, map, enemies, etc.
     */
    private GameData gameData;

    public StateManager(GameData data){

        //Backend game data
        this.gameData = data;

        //Initialize different states here.
        stateHashMap = new HashMap<Integer, State>();
        stateHashMap.put(START_MENU, new StateStartMenu(data));
        stateHashMap.put(GAME_STATE, new StateGame(data));
        stateHashMap.put(INVENTORY_STATE, new StateInventory(data));
        stateHashMap.put(PAUSE_STATE, new StatePause(data));

        //Current state is by default start menu
        this.currentState = stateHashMap.get(START_MENU);
    }


    public void setGameState(int key){
        if (stateHashMap.containsKey(key)){
            currentState = stateHashMap.get(key);
        }
    }


    public State getCurrentState(){
        return this.currentState;
    }

    void processCommand(int com){
        currentState.processCommand(com);
    }

    void updateScreen(AsciiPanel panel){
        currentState.updateScreen(panel);
    }







}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\StateMachine\StatePause.java
package StateMachine;

import Backend.GameData;
import StateMachine.StateManager.StateManager;
import asciiPanel.AsciiPanel;

/**
 * Created by evanputnam on 8/19/17.
 */
public class StatePause implements State {

    //Backend
    private GameData data;

    public StatePause(GameData data){
        this.data = data;
    }


    public void processCommand(int com){
        //Set state to game with new hero
        if(com == State.ESCAPE_KEY){
            System.out.println("Going to game");
            data.getManager().setGameState(StateManager.GAME_STATE);
        }
    }


    public void updateScreen(AsciiPanel panel){}
    public void updateScreen(){
        //Clears the panel before writing
        data.getPanel().clear();
        data.getPanel().writeCenter("Press escape to resume", data.Y_HEIGHT/2);
        data.getPanel().updateUI();
    }


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\src\StateMachine\StateStartMenu.java
package StateMachine;

import Backend.GameData;
import StateMachine.StateManager.StateManager;
import asciiPanel.AsciiPanel;

import java.awt.event.KeyEvent;

/**
 * State that handles the starting of a new game
 */
public class StateStartMenu implements State {

    /**
     * Integer value for keyevent command key that represents delete key
     */
    private static final int DELETE_KEY = 8;

    /**
     * Backend data
     */
    private GameData data;

    /**
     * Constructor for start menu
     * @param data
     */
    public StateStartMenu(GameData data){
        this.data = data;
    }


    /**
     * Processes the given command based on its keyEvent int value
     * @param com
     */
    public void processCommand(int com){
        //Set state to game with new hero
        if(com == State.ENTER_KEY){
            System.out.println("CHANGE SCENE HERE!");
            data.getManager().setGameState(StateManager.GAME_STATE);
        }

        //Add char to name
        if(KeyEvent.getKeyText(com).matches("^[-a-zA-Z0-9._]+")){
            data.getPlayer().addPlayerNameCh(KeyEvent.getKeyText(com).charAt(0));
        }

        //Remove char from name
        if(com == DELETE_KEY){
            data.getPlayer().removePlayerNameCh();
        }

    }

    /**
     * Method to update the screen with the given ascii panel if so chose
     * @param panel
     */
    public void updateScreen(AsciiPanel panel){}

    /**
     * Update the screen without the given ascii panel.  Takes it from data
     */
    public void updateScreen(){
        data.getPanel().clear();
        data.getPanel().writeCenter(GameData.GAME_NAME, GameData.Y_HEIGHT/2-5);
        data.getPanel().writeCenter("Type your name then press enter", GameData.Y_HEIGHT/2+5);
        data.getPanel().writeCenter("Name: " + data.getPlayer().getPlayerName(), GameData.Y_HEIGHT/2+7);
        data.getPanel().updateUI();
    }


}
C:\Users\flori\Documents\ProiectIP_E1\GH\git\Dungeon-Crawler\D_Crawler\statExample.txt
 LVL    HP  DMG TTK
    1   15  8   1.9
    2   20  9   2.2
    3   25  10  2.5
    4   30  11  2.7
    5   35  12  2.9
    6   40  13  3.1
    7   45  14  3.2
    8   50  15  3.3
    9   55  16  3.4
    10  60  17  3.5
    11  65  18  3.6
    12  70  19  3.7
    13  75  20  3.8
    14  80  21  3.8
    15  85  22  3.9
    16  90  23  3.9
    17  95  24  4.0
    18  100 25  4.0
    19  105 26  4.0
    20  110 27  4.1
Above is an example of an enemy progression tree in a dnd style campaign.
